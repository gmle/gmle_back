{"pages":[{"title":"标签","date":"2016-04-22T04:39:04.000Z","updated":"2018-07-21T13:46:26.102Z","comments":false,"path":"tags/index.html","permalink":"http://gmle.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-04-22T04:39:04.000Z","updated":"2018-03-16T09:42:52.000Z","comments":false,"path":"categories/index.html","permalink":"http://gmle.github.io/categories/index.html","excerpt":"","text":""},{"title":"简历","date":"2018-07-12T12:10:21.077Z","updated":"2018-07-12T12:10:21.077Z","comments":true,"path":"resume/index.html","permalink":"http://gmle.github.io/resume/index.html","excerpt":"","text":"联系方式 手机：(全天) 185xxxxxxxx 136xxxxxxxx Email： xxx@xxx.com xxx@xxx.com 网络联系方式： 企鹅：122xxxx 微信：wlxxxx 个人信息 王乐/男/1996 专科/河北软件学院软件工程系软件开发与设计方向 - Java 我的博客：gmle.github.io 期望职位：大数据平台运维工程师；Hadoop开发工程师；Spark开发工程师。 期望城市：北京 工作经历廊坊市大华夏神农科技有限公司 （ 2015年11月 ~ 2015年12月 ）项目：三省农场 担任职位：信息采集，设备测试，源代码测试，服务器调试。 主要工作内容：参与需求信息调研和设计、测试数据、执行测试、提交和跟踪缺陷. 大快搜索（北京）数据技术有限公司 （ 2016年06月 ~ 至今 ）项目：DKH大快大数据平台 担任职位：DKH平台运维，测试，开发。 项目涵盖：Hadoop HA、HBase HA、Zookeeper Cluster、Spark HA、Flume、Strom、Hive、Kafka Cluster、ElasticSearch Cluster、Sqoop、分布式MySQL 主要工作内容：设计各个组件之间的耦合度，着手自动化数据平台搭建，利用Bash进行平台的自动化配置各种组件.并进行自动化测试。 项目：FreeRCH（DKH平台基础框架） 担任职位：开发，测试。 项目涵盖：NLP模块、数据导入导出模块、机器学习模块 主要工作内容：开发以DKH为基础的大数据框架，整合DKH与FreeRCH的关系，并使其具有DKH唯一性（Linux平台不可用）。 熟悉常用分类聚类机器学习算法（朴素贝叶斯、K-Means、频繁项集、PCA、ACM、随机森林等）。 技能清单以下均为我熟练使用的技能 Web开发：JavaWeb Web框架：Spring/SpringMVC/ 熟悉Centos6+、Centos7+ 熟悉Shell脚本的使用。 Hadoop、Spark、kafka、flume、storm、Zookeeper、Hive基本配置调优以及丰富的集群调错能力。 Hadoop、Spark、Hive、HBase、Zookeeper的使用 常规Hive HQL编写 版本管理：Git/Svn 系统：Win/Linux/MacOS Docker 以下是我基本掌握的技能并不断的深入 Python2 Scala CDH 自我评价本人具有比较强的专业理论知识,基础扎实，涉及广泛，为人真诚乐观自信，勤奋务实，责任感强，热爱集体，助人为乐，能恪守以大局为重的原则，愿意服从集体利益的需要，具备奉献精神。爱好专研新技术，拥有较强的自学能力，能快速学习新技术,特别爱喜欢有挑战的项目,并从中快速进步，适应出差。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"关于","date":"2018-05-10T07:06:38.245Z","updated":"2018-03-16T09:42:21.000Z","comments":true,"path":"about/index.html","permalink":"http://gmle.github.io/about/index.html","excerpt":"","text":"Info 性别 x 爱好 x #1x。"}],"posts":[{"title":"范围for语句","slug":"范围循环语句","date":"2018-07-21T13:02:16.969Z","updated":"2018-07-21T13:55:41.669Z","comments":true,"path":"2018/07/21/范围循环语句/","link":"","permalink":"http://gmle.github.io/2018/07/21/范围循环语句/","excerpt":"范围for语句是C++11的特性，这种语句可以遍历容器或其他序列的所有元素。","text":"范围for语句是C++11的特性，这种语句可以遍历容器或其他序列的所有元素。 123456789101112131415161718int main(int argc, char *argv[]) &#123; int arr[10] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; // 范围for语句语法： // 范围变量必须是引用类型，这样才能对元素执行写操作。 // 对于arr中的每个元素 ： for (auto &amp;i:arr)&#123; i *= 2; // 将arr中的每个元素值翻倍。 cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\n®----------------------\" &lt;&lt; endl; for (auto &amp;i:arr)&#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"运算符重载","slug":"运算符重载","date":"2018-07-21T11:42:34.903Z","updated":"2018-07-21T13:55:56.456Z","comments":true,"path":"2018/07/21/运算符重载/","link":"","permalink":"http://gmle.github.io/2018/07/21/运算符重载/","excerpt":"运算符重载： 对于系统内置的数据类型，编译器知道如何运算。 对于自定义的数据类型则不会运算了。 利用运算符重载，可以让符号有新的含义。","text":"运算符重载： 对于系统内置的数据类型，编译器知道如何运算。 对于自定义的数据类型则不会运算了。 利用运算符重载，可以让符号有新的含义。 Example: + 运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;class Person &#123;public: int m_A; int m_B; Person() : m_A(), m_B() &#123;&#125;; Person(int a, int b) : m_A(a), m_B(b) &#123;&#125;; Person operator+(Person &amp;person) &#123; Person tmp; tmp.m_A = this-&gt;m_A + person.m_A; tmp.m_B = this-&gt;m_B + person.m_B; return tmp; &#125; Person operator+(int num) &#123; Person temp; temp.m_A = this-&gt;m_A + num; temp.m_B = this-&gt;m_B + num; return temp; &#125;&#125;;static void test01() &#123; Person p1(10, 20); Person p2(10, 20); Person p3 = p1 + p2; cout &lt;&lt; p3.m_A &lt;&lt; \":::\" &lt;&lt; p3.m_B;&#125;static void test02() &#123; Person p1(10, 20); Person p3 = p1 + 3; cout &lt;&lt; p3.m_A &lt;&lt; \":::\" &lt;&lt; p3.m_B;&#125;static void test03() &#123; int a = 20; int b = 10; cout &lt;&lt; a+b &lt;&lt; endl;&#125;int main(int argc, char *argv[]) &#123; test01(); test02(); test03(); return 0;&#125; Example：&lt;&lt; 左移运算符重载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;class Person &#123;public: int getM_A() const; void setM_A(int m_A); int getM_B() const; void setM_B(int m_B); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Person &amp;person);private: int m_A; int m_B;&#125;;int Person::getM_A() const &#123; return m_A;&#125;void Person::setM_A(int m_A) &#123; Person::m_A = m_A;&#125;int Person::getM_B() const &#123; return m_B;&#125;void Person::setM_B(int m_B) &#123; Person::m_B = m_B;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;os, const Person &amp;person) &#123; os &lt;&lt; \"m_A: \" &lt;&lt; person.getM_A() &lt;&lt; \" m_B: \" &lt;&lt; person.getM_B(); return os;&#125;static void test01() &#123; Person p1; p1.setM_A(10); p1.setM_B(20); cout &lt;&lt; p1;&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125; Example: ++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;class MyInter &#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, MyInter &amp;inter);public: MyInter() &#123; m_Num = 0; &#125; // 前置++重载 MyInter &amp;operator++() &#123; this-&gt;m_Num++; return *this; &#125; // 后置++重载 MyInter operator++(int) &#123; MyInter tmp = *this; this-&gt;m_Num++; return tmp; &#125;private: int m_Num;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, MyInter &amp;inter) &#123; out &lt;&lt; inter.m_Num; return out;&#125;static void test01() &#123; MyInter inter; inter++; ++inter; cout &lt;&lt; (inter);&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125; Example：指针运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;class Person &#123;public: explicit Person(int age) &#123; cout &lt;&lt; \"Person的有参构造调用\" &lt;&lt; endl; this-&gt;m_Age = age; &#125; void showAge() &#123; cout &lt;&lt; \"年龄为： \" &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; \"Person的析构调用\" &lt;&lt; endl; &#125; int m_Age;&#125;;class SmartPoint &#123;public: explicit SmartPoint(Person *person) &#123; this-&gt;m_person = person; &#125; //重载-&gt;运算符 Person *operator-&gt;() &#123; return this-&gt;m_person; &#125; //重载 * 运算符 Person &amp;operator*() &#123; return *m_person; &#125; ~SmartPoint() &#123; if (this-&gt;m_person) &#123; delete this-&gt;m_person; this-&gt;m_person = nullptr; &#125; &#125;private: Person *m_person;&#125;;void test01() &#123; //Person * p = new Person(18); //(*p).showAge(); //p-&gt;showAge(); //delete p; //利用智能指针 管理 new出来的person的释放操作 SmartPoint sp(new Person(18));// sp-&gt;showAge(); // 本质sp-&gt;-&gt;showAge(); 编译器简化为 sp-&gt;showAge(); sp.m_person-&gt;showAge();// (*sp).showAge();&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125; Example：赋值运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;//编译器 默认给一个类4个函数 默认构造 析构 拷贝构造 （值拷贝） operator= (值拷贝)class Person &#123;public: Person(char *name, int age) &#123; this-&gt;m_Name = new char[strlen(name) + 1]; strcpy(this-&gt;m_Name, name); this-&gt;m_Age = age; &#125; //重载 = Person &amp;operator=(const Person &amp;p) &#123; //先判断原来堆区释放有内容，如果有先释放 if (this-&gt;m_Name != NULL) &#123; delete[] this-&gt;m_Name; this-&gt;m_Name = NULL; &#125; this-&gt;m_Name = new char[strlen(p.m_Name) + 1]; strcpy(this-&gt;m_Name, p.m_Name); this-&gt;m_Age = p.m_Age; return *this; &#125; //拷贝构造 Person(const Person &amp;p) &#123; this-&gt;m_Name = new char[strlen(p.m_Name) + 1]; strcpy(this-&gt;m_Name, p.m_Name); this-&gt;m_Age = p.m_Age; &#125; ~Person() &#123; if (this-&gt;m_Name != NULL) &#123; delete[] this-&gt;m_Name; this-&gt;m_Name = NULL; &#125; &#125; char *m_Name; int m_Age;&#125;;void test01() &#123; Person p1(\"Tom\", 10); Person p2(\"Jerry\", 19); p2 = p1; Person p3(\"\", 0); p3 = p2 = p1; Person p4 = p3; cout &lt;&lt; \"p1姓名： \" &lt;&lt; p1.m_Name &lt;&lt; \" p1年龄： \" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; \"p2姓名： \" &lt;&lt; p2.m_Name &lt;&lt; \" p2年龄： \" &lt;&lt; p2.m_Age &lt;&lt; endl; cout &lt;&lt; \"p3姓名： \" &lt;&lt; p3.m_Name &lt;&lt; \" p3年龄： \" &lt;&lt; p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); /*int a = 10; int b = 20; int c; c = a = b; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \" b = \" &lt;&lt; b &lt;&lt; \" c = \" &lt;&lt; c &lt;&lt; endl;*/ return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"构造函数的初始化列表","slug":"构造函数的初始化列表","date":"2018-07-21T11:38:22.516Z","updated":"2018-07-21T13:55:29.003Z","comments":true,"path":"2018/07/21/构造函数的初始化列表/","link":"","permalink":"http://gmle.github.io/2018/07/21/构造函数的初始化列表/","excerpt":"初始化列表语法。","text":"初始化列表语法。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Person &#123;public: //构造函数名称后 ： 属性(值), 属性（值）... Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) &#123;&#125; int m_A; int m_B; int m_C;&#125;;void test01() &#123; Person p(10, 20, 30); cout &lt;&lt; \"m_A = \" &lt;&lt; p.m_A &lt;&lt; endl; cout &lt;&lt; \"m_B = \" &lt;&lt; p.m_B &lt;&lt; endl; cout &lt;&lt; \"m_C = \" &lt;&lt; p.m_C &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return EXIT_SUCCESS;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"构造、析构。拷贝构造","slug":"构造、析构、拷贝构造","date":"2018-07-21T11:35:00.189Z","updated":"2018-07-21T13:55:17.361Z","comments":true,"path":"2018/07/21/构造、析构、拷贝构造/","link":"","permalink":"http://gmle.github.io/2018/07/21/构造、析构、拷贝构造/","excerpt":"构造函数、析构函数、拷贝构造函数 构造函数： 构造函数在函数被调用的时候调用并初始化。 构造函数必须要声明在全局作用域。 没有返回值，也不需要写void 函数名与类名相同 可以有参数，可以发生重载 构造函数由编译器自动调用且只调用一次，无需手动调用。","text":"构造函数、析构函数、拷贝构造函数 构造函数： 构造函数在函数被调用的时候调用并初始化。 构造函数必须要声明在全局作用域。 没有返回值，也不需要写void 函数名与类名相同 可以有参数，可以发生重载 构造函数由编译器自动调用且只调用一次，无需手动调用。 构造函数分类： 按照参数分类：无参构造（默认构造函数）和有参构造。 按照类型分类：普通构造函数，拷贝构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;using namespace std;class Person &#123;private: int _age;public: /** * 构造函数： * 构造函数在函数被调用的时候调用并初始化。 * 构造函数必须要声明在全局作用域。 * 没有返回值，也不需要写void * 函数名与类名相同 * 可以有参数，可以发生重载 * 构造函数由编译器自动调用且只调用一次，无需手动调用。 * 构造函数分类： * 按照参数分类：无参构造（默认构造函数）和有参构造。 * 按照类型分类：普通构造函数，拷贝构造函数。 */ Person() &#123; cout &lt;&lt; \"hei二狗\" &lt;&lt; endl; &#125; Person(int age) &#123; _age = age; cout &lt;&lt; \"hei有参二狗\" &lt;&lt; endl; &#125; /** * 拷贝构造 * 1、用已有对象初始化新的对象。 * 2、值传递的方式给函数参数传值。 * 3、以值的方式返回局部对象。 */ Person(const Person &amp;person) &#123; _age = person._age; &#125; /** * 析构函数 * 没有返回值，不需要写void * 函数名与类名相同 函数名前加 ~ * 不可以有参数，不可以重载 */ ~Person() &#123; cout &lt;&lt; \"ha二狗\" &lt;&lt; endl; &#125; int get_age() const &#123; return _age; &#125; void set_age(int _age) &#123; Person::_age = _age; &#125;&#125;;static void test01() &#123; Person person(19); // 匿名对象：特点：当执行完该函数后立即释放。 // 不要用拷贝构造函数初始化匿名对象。 Person(200); Person person1 = 20; cout &lt;&lt; person.get_age() &lt;&lt; endl;&#125;int main03(int argc, char *argv[]) &#123; test01(); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"友元函数","slug":"友元函数","date":"2018-07-21T11:29:27.206Z","updated":"2018-07-21T13:55:00.073Z","comments":true,"path":"2018/07/21/友元函数/","link":"","permalink":"http://gmle.github.io/2018/07/21/友元函数/","excerpt":"友元函数： 为在该类中提供一个对外访问的接口 友元函数不属于该类的成员函数 友元函数是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员","text":"友元函数： 为在该类中提供一个对外访问的接口 友元函数不属于该类的成员函数 友元函数是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员 使用注意： 类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。 一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。 友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。 友元函数在调用上同一般函数一样，不必通过对对象进行引用。 例子：好基友进卧室。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;class Home &#123; friend class Gay;public: Home(string sitting, string bed); string SittingRoom;private: string BedRoom;&#125;;//Home::Home() &#123;// this-&gt;setBedRoom(\"卧室\");// this-&gt;setSittingRoom(\"客厅\");//&#125;class Gay &#123;public: Gay(Home* h); void visit(); Home *home&#123;&#125;;&#125;;Home::Home(string sitting, string bed) &#123;// this-&gt;SittingRoom = sitting;// this-&gt;BedRoom = bed; Home::BedRoom = bed; Home::SittingRoom = sitting;&#125;Gay::Gay(Home* h) &#123;// this-&gt;home = new Home; this-&gt;home = h;// this-&gt;home = &amp;h;// this-&gt;home = &amp;h;&#125;void Gay::visit() &#123; cout &lt;&lt; \"Gay vising \" &lt;&lt; this-&gt;home-&gt;SittingRoom &lt;&lt; endl; cout &lt;&lt; \"Gay vising \" &lt;&lt; this-&gt;home-&gt;BedRoom &lt;&lt; endl;&#125;static void test01() &#123; Home hh(\"客厅\",\"卧室\"); Gay gay(&amp;hh); gay.visit();&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"设计模式：单例","slug":"设计模式：单例模式","date":"2018-07-21T11:15:24.799Z","updated":"2018-07-21T13:55:50.724Z","comments":true,"path":"2018/07/21/设计模式：单例模式/","link":"","permalink":"http://gmle.github.io/2018/07/21/设计模式：单例模式/","excerpt":"单例设计模式的设计思想： 在一些情形下，保持类的实例只有一个非常重要。例如：一个表示文件系统的Class。一个操作系统一定是只有一个文件系统的，因此，我们希望表示文件系统的类实例有且仅有一个。单例模式 是设计模式中一种实现这一类需求的设计方法。","text":"单例设计模式的设计思想： 在一些情形下，保持类的实例只有一个非常重要。例如：一个表示文件系统的Class。一个操作系统一定是只有一个文件系统的，因此，我们希望表示文件系统的类实例有且仅有一个。单例模式 是设计模式中一种实现这一类需求的设计方法。 该代码线程不安全。线程安全的两个操作： 对象在类外创建。 加锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;class Singleton &#123;public: static Singleton *GetInstance() &#123; if (m_pInstance == nullptr) &#123; m_pInstance = new Singleton(); &#125; return m_pInstance; &#125; int getCount() const; void printTest(const string &amp;test) &#123; count++; cout &lt;&lt; test &lt;&lt; endl; &#125; // 实现一个内嵌垃圾回收类 class CGarbo &#123; public: ~CGarbo() &#123; cout &lt;&lt; \"销毁\" &lt;&lt; endl; delete Singleton::m_pInstance; &#125; &#125;; ~Singleton()&#123; cout &lt;&lt; \"1123123\" &lt;&lt; endl; //delete m_pInstance; &#125;private: void setCount(int count); int count; // 默认构造函数私有化，防止创建多个对象。 Singleton() : count(0) &#123; setCount(0); &#125;; // 拷贝构造函数私有化，防止在堆区创建对象。 Singleton(Singleton const &amp;) : count() &#123;&#125;; static Singleton *m_pInstance;&#125;;Singleton *Singleton::m_pInstance = nullptr;int Singleton::getCount() const &#123; return count;&#125;void Singleton::setCount(int count) &#123; Singleton::count = count;&#125;Singleton::CGarbo Garbo;static void test01() &#123; Singleton *s1 = Singleton::GetInstance(); s1-&gt;printTest(\"1\"); s1-&gt;printTest(\"2\"); s1-&gt;printTest(\"3\"); cout &lt;&lt; \"s1:count\" &lt;&lt; s1-&gt;getCount() &lt;&lt; endl; Singleton *s2 = Singleton::GetInstance(); s2-&gt;printTest(\"4\"); s2-&gt;printTest(\"5\"); s2-&gt;printTest(\"6\"); cout &lt;&lt; \"s2:count\" &lt;&lt; s2-&gt;getCount() &lt;&lt; endl;&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://gmle.github.io/tags/设计模式/"},{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"二叉树","slug":"二叉树","date":"2018-07-12T13:36:40.536Z","updated":"2018-07-12T13:45:06.505Z","comments":true,"path":"2018/07/12/二叉树/","link":"","permalink":"http://gmle.github.io/2018/07/12/二叉树/","excerpt":"二叉树","text":"二叉树 基本概念定义n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。 逻辑结构一对二 基本特征 每个结点最多只有两棵子树（不存在度大于2的结点）； 左子树和右子树次序不能颠倒（有序树）。 二叉树的实现二叉树的遍历 DLR — 先序遍历，即先根再左再右 LDR — 中序遍历，即先左再根再右 LRD — 后序遍历，即先左再右再根 “先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct _BINARYNODE &#123; char ch; struct _BINARYNODE *LeftChirld; struct _BINARYNODE *RightChirld;&#125; BubaryNode;static void recursion(BubaryNode *pBINARYNODE);static void test1() &#123; BubaryNode nodeA = &#123;'A', NULL, NULL&#125;; BubaryNode nodeB = &#123;'B', NULL, NULL&#125;; BubaryNode nodeC = &#123;'C', NULL, NULL&#125;; BubaryNode nodeD = &#123;'D', NULL, NULL&#125;; BubaryNode nodeE = &#123;'E', NULL, NULL&#125;; BubaryNode nodeF = &#123;'F', NULL, NULL&#125;; BubaryNode nodeG = &#123;'G', NULL, NULL&#125;; BubaryNode nodeH = &#123;'H', NULL, NULL&#125;; // 建立关系 nodeA.LeftChirld = &amp;nodeB; nodeA.RightChirld = &amp;nodeF; nodeB.RightChirld = &amp;nodeC; nodeC.LeftChirld = &amp;nodeD; nodeC.RightChirld = &amp;nodeE; nodeF.RightChirld = &amp;nodeG; nodeG.LeftChirld = &amp;nodeH; recursion(&amp;nodeA);&#125;/** * 二叉树递归 * @param rootNode */static void recursion(BubaryNode *rootNode) &#123; if (rootNode == NULL)&#123; return; &#125; // 先序遍历 ：先根，再左，再右。 printf(\"%c \", rootNode-&gt;ch); recursion(rootNode-&gt;LeftChirld); recursion(rootNode-&gt;RightChirld); // 中序遍历 ：先左，再右，再根。/* recursion(rootNode-&gt;LeftChirld); printf(\"%c \", rootNode-&gt;ch); recursion(rootNode-&gt;RightChirld);*/ // 后序遍历 ： 先左，再右，再根。/* recursion(rootNode-&gt;LeftChirld); recursion(rootNode-&gt;RightChirld); printf(\"%c \", rootNode-&gt;ch);*/&#125;int main(int argc, char *argv[]) &#123; test1(); return 0;&#125; 二叉树的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct _BINARYNODE &#123; char ch; struct _BINARYNODE *LeftChirld; struct _BINARYNODE *RightChirld;&#125; BinaryNode;/** * 计算二叉树高度：左子树与右子树同时为NULL，则为叶子 * @param rootnode * @param p */static void calLeaves(BinaryNode *rootnode, int *p) &#123; if (rootnode == NULL) &#123; return; &#125; if (rootnode-&gt;LeftChirld == NULL &amp;&amp; rootnode-&gt;RightChirld == NULL) &#123; (*p)++; &#125; calLeaves(rootnode-&gt;LeftChirld, p); calLeaves(rootnode-&gt;RightChirld, p);&#125;/** * 二叉树遍历 * @param rootNode */static void recursion(BinaryNode *rootNode) &#123; if (rootNode == NULL) &#123; return; &#125; printf(\"%c \", rootNode-&gt;ch); recursion(rootNode-&gt;LeftChirld); recursion(rootNode-&gt;RightChirld);&#125;static int BinaryTreeHeight(BinaryNode *root) &#123; if (root == NULL) &#123; return 0; &#125; int left = BinaryTreeHeight(root-&gt;LeftChirld); int right = BinaryTreeHeight(root-&gt;RightChirld); return left &gt; right ? left + 1 : right + 1;&#125;/** * 拷贝二叉树 * @param root * @return */static BinaryNode *copyTree(BinaryNode *root) &#123; if (root == NULL) &#123; return NULL; &#125; BinaryNode *leftChild = copyTree(root-&gt;LeftChirld); BinaryNode *rightChild = copyTree(root-&gt;RightChirld); BinaryNode *newNode = malloc(sizeof(BinaryNode)); newNode-&gt;ch = root-&gt;ch; newNode-&gt;LeftChirld = leftChild; newNode-&gt;RightChirld = rightChild; return newNode;&#125;/** * 二叉树的内存释放 * @param root */static void freeTree(BinaryNode *root)&#123; if (root==NULL)&#123; return; &#125; freeTree(root-&gt;LeftChirld); freeTree(root-&gt;RightChirld); printf(\"Free:%c\\n\", root-&gt;ch); free(root);&#125;static void test01() &#123; int num = 0; BinaryNode nodeA = &#123;'A', NULL, NULL&#125;; BinaryNode nodeB = &#123;'B', NULL, NULL&#125;; BinaryNode nodeC = &#123;'C', NULL, NULL&#125;; BinaryNode nodeD = &#123;'D', NULL, NULL&#125;; BinaryNode nodeE = &#123;'E', NULL, NULL&#125;; BinaryNode nodeF = &#123;'F', NULL, NULL&#125;; BinaryNode nodeG = &#123;'G', NULL, NULL&#125;; BinaryNode nodeH = &#123;'H', NULL, NULL&#125;; // 建立关系 nodeA.LeftChirld = &amp;nodeB; nodeA.RightChirld = &amp;nodeF; nodeB.RightChirld = &amp;nodeC; nodeC.LeftChirld = &amp;nodeD; nodeC.RightChirld = &amp;nodeE; nodeF.RightChirld = &amp;nodeG; nodeG.LeftChirld = &amp;nodeH; calLeaves(&amp;nodeA, &amp;num); printf(\"二叉树叶子数量：%d\\n\", num); BinaryNode *newTree = copyTree(&amp;nodeA); recursion(newTree); printf(\"\\n二叉树高度：%d\\n\", BinaryTreeHeight(&amp;nodeA)); freeTree(newTree); printf(\":::%c\\n\", (unsigned char) newTree-&gt;RightChirld-&gt;RightChirld);&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/tags/数据结构/"}]},{"title":"队列的链表存储结构","slug":"队列","date":"2018-07-12T13:27:23.985Z","updated":"2018-07-12T13:46:34.467Z","comments":true,"path":"2018/07/12/队列/","link":"","permalink":"http://gmle.github.io/2018/07/12/队列/","excerpt":"队列的链表存储结构实现","text":"队列的链表存储结构实现 FILE1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef _LINKQUEUE_H#define _LINKQUEUE_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;typedef struct QUEUENODE&#123; struct QUEUENODE *next;&#125;QueueNode;// 队列结构体typedef struct LISTQUEUE&#123; QueueNode header; int ListQueueSize; QueueNode *tail;&#125; ListQueue;typedef void *LinkQueue;// 初始化LinkQueue init_LinkQueue();// 入队void push_LinkQueue(LinkQueue q, void *data);// 出队void pop__LinkQueue(LinkQueue q);// 队列大小int size_LinkQueue(LinkQueue q);// 队列是否为空bool isEmpty_LinkQueue(LinkQueue q);// 队列头void *front_LinkQueue(LinkQueue q);// 队列尾void *back_LinkQueue(LinkQueue q);void destory_LinkQueue(LinkQueue q);#endif //_LINKQUEUE_H FILE2: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include \"linkQueue.h\"// 初始化LinkQueue init_LinkQueue() &#123; ListQueue *queue = malloc(sizeof(ListQueue)); if (queue == NULL) &#123; return NULL; &#125; queue-&gt;header.next = NULL; queue-&gt;ListQueueSize = 0; queue-&gt;tail = &amp;queue-&gt;header; return queue;&#125;void push_LinkQueue(LinkQueue lq, void *data) &#123; if (lq == NULL || data == NULL) &#123; return; &#125; ListQueue *queue = lq; QueueNode *qNode = data; // 尾插 queue-&gt;tail-&gt;next = qNode; qNode-&gt;next = NULL; queue-&gt;tail = qNode; queue-&gt;ListQueueSize++;&#125;void pop__LinkQueue(LinkQueue q) &#123; if (q == NULL) &#123; return; &#125; ListQueue *listQueue = q; // 没有要删除的元素 if (listQueue-&gt;ListQueueSize == 0) &#123; return; &#125; // 如果只有一个节点，则将尾部节点指向头节点。 if (listQueue-&gt;ListQueueSize == 1) &#123; listQueue-&gt;header.next = NULL; listQueue-&gt;tail = &amp;listQueue-&gt;header; listQueue-&gt;ListQueueSize--; return; &#125; // 大于一个节点的情况 QueueNode *headNode = listQueue-&gt;header.next; listQueue-&gt;header.next = headNode-&gt;next; listQueue-&gt;ListQueueSize--;&#125;int size_LinkQueue(LinkQueue q) &#123; if (q == NULL)&#123; return -1; &#125; ListQueue *queue = q; return queue-&gt;ListQueueSize;&#125;bool isEmpty_LinkQueue(LinkQueue q) &#123; if (q == NULL)&#123; return -1; &#125; ListQueue *queue = q; if (queue-&gt;ListQueueSize == 0)&#123; return true; &#125; return false;&#125;void *front_LinkQueue(LinkQueue q)&#123; if (q == NULL)&#123; return NULL; &#125; ListQueue *queue = q; return queue-&gt;header.next;&#125;void *back_LinkQueue(LinkQueue q)&#123; if (q == NULL)&#123; return NULL; &#125; ListQueue *queue = q; return queue-&gt;tail;&#125;void destory_LinkQueue(LinkQueue q)&#123; if (q == NULL)&#123; return; &#125; free(q); q = NULL;&#125; FILE3:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include \"linkQueue.h\"struct Person &#123; void *node; char name[64]; int age;&#125;;void test01() &#123; //初始化队列 LinkQueue myQueue = init_LinkQueue(); //准备数据 struct Person p1 = &#123;NULL, \"aaa\", 10&#125;; struct Person p2 = &#123;NULL, \"bbb\", 20&#125;; struct Person p3 = &#123;NULL, \"ccc\", 30&#125;; struct Person p4 = &#123;NULL, \"ddd\", 40&#125;; //入队 push_LinkQueue(myQueue, &amp;p1); push_LinkQueue(myQueue, &amp;p2); push_LinkQueue(myQueue, &amp;p3); push_LinkQueue(myQueue, &amp;p4); printf(\"队列大小为：%d\\n\", size_LinkQueue(myQueue)); while (isEmpty_LinkQueue(myQueue) == 0) &#123; //访问队头 struct Person *pFront = front_LinkQueue(myQueue); printf(\"链式存储::队头元素 -- 姓名：%s 年龄： %d\\n\", pFront-&gt;name, pFront-&gt;age); //访问队尾 struct Person *pBack = back_LinkQueue(myQueue); printf(\"链式存储::队尾元素 -- 姓名：%s 年龄： %d\\n\", pBack-&gt;name, pBack-&gt;age); //出队 pop__LinkQueue(myQueue); &#125; printf(\"队列大小为：%d\\n\", size_LinkQueue(myQueue)); //销毁队列 destory_LinkQueue(myQueue);&#125;int main() &#123; test01(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/tags/数据结构/"}]},{"title":"插入排序","slug":"插入排序","date":"2018-07-12T13:24:43.925Z","updated":"2018-07-12T13:27:16.043Z","comments":true,"path":"2018/07/12/插入排序/","link":"","permalink":"http://gmle.github.io/2018/07/12/插入排序/","excerpt":"插入排序实现思路： 从I = 1位置开始 做外层循环 判断 如果 I -1 &gt; I 将i指向的数据缓存 j开始做内侧循环，找到要插入的位置 将缓存数据插入到 j +1位置上 i++","text":"插入排序实现思路： 从I = 1位置开始 做外层循环 判断 如果 I -1 &gt; I 将i指向的数据缓存 j开始做内侧循环，找到要插入的位置 将缓存数据插入到 j +1位置上 i++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;assert.h&gt;/** * 插入排序. * @param arr * @param len */void insertSort(int arr[], int len) &#123; for (int i = 1; i &lt; len; i++) &#123; if (arr[i - 1] &gt; arr[i]) &#123; int temp = arr[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j--) &#123; //数据后移 arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; int arr[10] = &#123;9, 2, 4, 7, 5, 3, 6, 8, 5, 0&#125;; insertSort(arr, sizeof(arr)/ sizeof(arr[0])); assert(arr[0]==0); assert(arr[1]==2); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"利用栈规则做就近括号匹配","slug":"利用栈规则做就近括号匹配","date":"2018-07-11T13:50:43.276Z","updated":"2018-07-11T13:53:48.751Z","comments":true,"path":"2018/07/11/利用栈规则做就近括号匹配/","link":"","permalink":"http://gmle.github.io/2018/07/11/利用栈规则做就近括号匹配/","excerpt":"利用栈规则做就近括号匹配","text":"利用栈规则做就近括号匹配 从第一个字符开始扫描当遇见普通字符时忽略，当遇见左括号时压入栈中当遇见右括号时从栈中弹出栈顶符号，并进行匹配匹配成功：继续读入下一个字符匹配失败：立即停止，并报错结束：成功: 所有字符扫描完毕，且栈为空失败：匹配失败或所有字符扫描完毕但栈非空 FILE1： 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef _SEQSTACK_H#define _SEQSTACK_H#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAX 1024struct SStack &#123; void *data[MAX]; //栈的数组 int m_Size; //栈大小&#125;;typedef void *SeqStack;//初始化栈SeqStack init_SeqStack();//入栈void push_SeqStack(SeqStack stack, void *data);//出栈void pop_SeqStack(SeqStack stack);//返回栈顶void *top_SeqStack(SeqStack stack);//返回栈大小int size_SeqStack(SeqStack stack);//判断栈是否为空bool isEmpty_SeqStack(SeqStack stack);//销毁栈void destroy_SeqStack(SeqStack stack);#endif //_SEQSTACK_H FILE2: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include \"SeqStack.h\"//初始化栈SeqStack init_SeqStack() &#123; struct SStack *myStack = malloc(sizeof(struct SStack)); if (myStack == NULL) &#123; return NULL; &#125; //初始化数组 memset(myStack-&gt;data, 0, sizeof(void *) * MAX); //初始化栈大小 myStack-&gt;m_Size = 0; return myStack;&#125;//入栈void push_SeqStack(SeqStack stack, void *data) &#123; //入栈本质 --- 数组尾插 if (stack == NULL) &#123; return; &#125; if (data == NULL) &#123; return; &#125; struct SStack *mystack = stack; if (mystack-&gt;m_Size == MAX) &#123; return; &#125; mystack-&gt;data[mystack-&gt;m_Size] = data; mystack-&gt;m_Size++;&#125;//出栈void pop_SeqStack(SeqStack stack) &#123; //出栈本质 --- 数组尾删 if (stack == NULL) &#123; return; &#125; struct SStack *mystack = stack; if (mystack-&gt;m_Size == 0) &#123; return; &#125; mystack-&gt;data[mystack-&gt;m_Size - 1] = NULL; mystack-&gt;m_Size--;&#125;//返回栈顶void *top_SeqStack(SeqStack stack) &#123; if (stack == NULL) &#123; return NULL; &#125; struct SStack *mystack = stack; if (mystack-&gt;m_Size == 0) &#123; return NULL; &#125; return mystack-&gt;data[mystack-&gt;m_Size - 1];&#125;//返回栈大小int size_SeqStack(SeqStack stack) &#123; if (stack == NULL) &#123; return -1; &#125; struct SStack *mystack = stack; return mystack-&gt;m_Size;&#125;//判断栈是否为空bool isEmpty_SeqStack(SeqStack stack) &#123; if (stack == NULL) &#123; return true;//返回-1代表真 空栈 &#125; struct SStack *mystack = stack; if (mystack-&gt;m_Size == 0) &#123; return true; &#125; return false; //返回0 代表 不是空栈&#125;//销毁栈void destroy_SeqStack(SeqStack stack) &#123; if (stack == NULL) &#123; return; &#125; free(stack); stack = NULL;&#125; FILE3: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int isLeft(char ch) &#123; return ch == '(';&#125;int isRight(char ch) &#123; return ch == ')';&#125;static void test01() &#123; char *str = \"123*(was)s(sd)sdb(fs())())))(()\"; char *p = str; SeqStack *stack = init_SeqStack(); while (*p != '\\0') &#123; //如果是左括号，入栈 if (isLeft(*p)) &#123; push_SeqStack(stack, p); &#125; else if (isRight(*p)) &#123; if (size_SeqStack(stack) &gt; 0) &#123; pop_SeqStack(stack); &#125; else &#123; error(str, \"Error!\", p); break; &#125; &#125; p++; &#125; while (size_SeqStack(stack) &gt; 0) &#123; error(str, \"Error\", top_SeqStack(stack)); pop_SeqStack(stack); &#125; destroy_SeqStack(stack); stack = NULL; bool b = isEmpty_SeqStack(stack); printf(\"\\n=-=-=-=-=-=-=-====-=-=\\n%d\\n\",b);&#125;static void error(char *str, char *string, const char *p) &#123; printf(\"\\n%s\\n\", string); printf(\"%s\\n\", str); int num = (int) (p - str); for (int i = 0; i &lt; num; i++) &#123; printf(\" \"); &#125; printf(\"I\");&#125;int main(int argc, char *argv[]) &#123; test01(); bool b = true; printf(\"%d\\n\", b); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"链表的开发实现","slug":"C语言的链表","date":"2018-07-11T13:20:20.691Z","updated":"2018-07-12T13:28:30.357Z","comments":true,"path":"2018/07/11/C语言的链表/","link":"","permalink":"http://gmle.github.io/2018/07/11/C语言的链表/","excerpt":"链表的开发实现","text":"链表的开发实现 普通实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct _LINKNODE &#123; struct _LINKNODE *next;&#125; LinkNode;typedef struct _LINKLIST &#123; LinkNode linkHeader; int linkNodeSize;&#125; LinkLists;typedef void *LinkList;LinkList LINKLIST_INIT() &#123; LinkLists *list = malloc(sizeof(LinkLists)); if (list == NULL) &#123; return NULL; &#125; list-&gt;linkHeader.next = NULL; list-&gt;linkNodeSize = 0; return list;&#125;void LINKLIST_INSERT(LinkList list, int pos, void *data) &#123; if (list == NULL || data == NULL) &#123; printf(\"Failed\"); return; &#125; LinkLists *lists = list; if (pos &lt; 0 || pos &gt; lists-&gt;linkNodeSize) &#123; pos = lists-&gt;linkNodeSize; &#125; // 数据的前四个字节存放的指针，将其强转为LinkNode指针。 LinkNode *node = data; LinkNode *p = &amp;lists-&gt;linkHeader; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; node-&gt;next = p-&gt;next; p-&gt;next = node; lists-&gt;linkNodeSize++;&#125;void PRINTF_LINKNODE(LinkList list, void(*print)(void *)) &#123; if (list == NULL) &#123; return; &#125; LinkLists *lists = list; LinkNode *node = lists-&gt;linkHeader.next; for (int i = 0; i &lt; lists-&gt;linkNodeSize; i++) &#123; print(node); node = node-&gt;next; &#125;&#125;void LINKLIST_DELETEBYPOS(LinkList list, int pos) &#123; LinkLists *lists = list; if (list == NULL || pos &lt; 0 || pos &gt; lists-&gt;linkNodeSize) &#123; return; &#125; LinkNode *qNode = &amp;lists-&gt;linkHeader; for (int i = 0; i &lt; pos; i++) &#123; qNode = qNode-&gt;next; &#125; LinkNode *delNode = qNode-&gt;next; qNode-&gt;next = delNode-&gt;next; lists--;&#125;typedef struct _PERSON &#123; void *node; char name[64]; int age;&#125; Person;void myPrintPerson(void *data) &#123; Person *p = data; printf(\"姓名： %s 年龄： %d \\n\", p-&gt;name, p-&gt;age);&#125;void test01() &#123; //初始化链表 LinkList mylist = LINKLIST_INIT(); //创建数据 Person p1 = &#123;NULL, \"aaa\", 10&#125;; Person p2 = &#123;NULL, \"bbb\", 20&#125;; Person p3 = &#123;NULL, \"ccc\", 30&#125;; Person p4 = &#123;NULL, \"ddd\", 40&#125;; Person p5 = &#123;NULL, \"eee\", 50&#125;; //插入节点 LINKLIST_INSERT(mylist, 0, &amp;p1); LINKLIST_INSERT(mylist, 2, &amp;p2); LINKLIST_INSERT(mylist, 1, &amp;p3); LINKLIST_INSERT(mylist, -1, &amp;p4); LINKLIST_INSERT(mylist, 0, &amp;p5); //遍历 PRINTF_LINKNODE(mylist, myPrintPerson); printf(\"=-=-=-=-=-=-=-=-=-=-=-=\\n\"); LINKLIST_DELETEBYPOS(mylist, 1); PRINTF_LINKNODE(mylist, myPrintPerson);&#125;void LINKNODE_RESET(LinkList list) &#123; LinkLists *lists = list; lists-&gt;linkHeader = NULL;&#125;void LINKNODE_DESTORY(LinkList list) &#123; if (list == NULL) &#123; return; &#125; free(list); list = NULL;&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125; 栈的链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct stackNode &#123; struct stackNode *next;&#125; StackNode;struct LStack &#123; StackNode nodeHead; int nodesize;&#125;;typedef void *LinkStack;LinkStack init_LinkStack() &#123; struct LStack *stack = malloc(sizeof(struct LStack)); if (stack == NULL) &#123; return NULL; &#125; stack-&gt;nodeHead.next = NULL; stack-&gt;nodesize = 0; return stack;&#125;// 对于链表而言，入栈本质为头插void push_LinkStack(LinkStack s, void *data) &#123; if (s == NULL || data == NULL) &#123; return; &#125; struct LStack *stack = s; // 将用户数据取出钱四个字节用于地址。 StackNode *node = data; // 更改指针指向 node-&gt;next = stack-&gt;nodeHead.next; stack-&gt;nodeHead.next = node; stack-&gt;nodesize++;&#125;void pop_LinkStack(LinkStack s) &#123; if (s == NULL) &#123; return; &#125; struct LStack *stack = s; if (stack-&gt;nodesize == 0) &#123; return; &#125; StackNode *firstNode = stack-&gt;nodeHead.next; stack-&gt;nodeHead.next = firstNode-&gt;next; stack-&gt;nodesize--;&#125;void *top_LinkStack(LinkStack s) &#123; if (s == NULL) &#123; return NULL; &#125; struct LStack *stack = s; if (stack-&gt;nodesize == 0) &#123; return NULL; &#125; return stack-&gt;nodeHead.next;&#125;int size_LinkStack(LinkStack s) &#123; if (s == NULL) &#123; return 0; &#125; struct LStack *stack = s; return stack-&gt;nodesize;&#125;int isEmpty_Linstack(LinkStack s) &#123; if (s == NULL) &#123; return 0; &#125; struct LStack *stack = s; if (stack-&gt;nodesize == 0) &#123; return 1; &#125; return 0;&#125;void destoryLinkStack(LinkStack s) &#123; if (s == NULL) &#123; return; &#125; free(s);&#125;//测试struct Person &#123; void *node; char name[64]; int age;&#125;;void test01() &#123; //初始化栈 LinkStack myStack = init_LinkStack(); //创建数据 struct Person p1 = &#123;NULL, \"aaa\", 10&#125;; struct Person p2 = &#123;NULL, \"bbb\", 20&#125;; struct Person p3 = &#123;NULL, \"ccc\", 30&#125;; struct Person p4 = &#123;NULL, \"ddd\", 40&#125;; struct Person p5 = &#123;NULL, \"eee\", 50&#125;; //入栈 push_LinkStack(myStack, &amp;p1); push_LinkStack(myStack, &amp;p2); push_LinkStack(myStack, &amp;p3); push_LinkStack(myStack, &amp;p4); push_LinkStack(myStack, &amp;p5); printf(\"链式存储 -- 栈的元素个数为：%d\\n\", size_LinkStack(myStack)); //栈不为空，查看栈顶元素，出栈 while (isEmpty_Linstack(myStack) == 0) &#123; struct Person *p = top_LinkStack(myStack); printf(\"姓名：%s 年龄：%d\\n\", p-&gt;name, p-&gt;age); //出栈 pop_LinkStack(myStack); &#125; printf(\"链式存储 -- 栈的元素个数为：%d\\n\", size_LinkStack(myStack)); //销毁栈 destoryLinkStack(myStack);&#125;int main(int argc, char *argv[]) &#123; test01(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/tags/数据结构/"}]},{"title":"MacOS下CLion的使用","slug":"Clion的使用技巧之MacOS篇","date":"2018-07-08T00:57:35.372Z","updated":"2018-07-09T01:22:57.976Z","comments":true,"path":"2018/07/08/Clion的使用技巧之MacOS篇/","link":"","permalink":"http://gmle.github.io/2018/07/08/Clion的使用技巧之MacOS篇/","excerpt":"CLIon介绍CLion是Jetbrains公司开发的一款编写C/C++的IDE；而且Jetbrains有特别多的IDE去供不同语言的开发者去使用,涵盖了大多数主流开发语言。 有句话说，Jetbrains出品，必属精品，作为一款有着昂贵收费的IDE，我在使用后就感受到了CLion的强大之处。我所使用的Jetbrains产品激活码由 hsweb 作者提供，感谢支持。","text":"CLIon介绍CLion是Jetbrains公司开发的一款编写C/C++的IDE；而且Jetbrains有特别多的IDE去供不同语言的开发者去使用,涵盖了大多数主流开发语言。 有句话说，Jetbrains出品，必属精品，作为一款有着昂贵收费的IDE，我在使用后就感受到了CLion的强大之处。我所使用的Jetbrains产品激活码由 hsweb 作者提供，感谢支持。 CLion开篇启动 启动界面 启动界面说明 启动界面说明 各个按钮/选项说明New Project顾名思义，新建工程。点击效果图： 新建工程界面 页面介绍： C++ Executable C++的可执行程序 C++ Library C++的动态库/静态库 C Executable C的可执行程序 C Library C的动态库/静态库…其余不再叙述，因本帖旨在介绍C/C++的IDE，若有兴趣，读者可自行尝试。 C++ Library/C Library这两个选项提供了C/C++的动态库与静态库的生成，若是对CMake比较熟悉的人应该不会陌生，因为这两个选项只是在CMakeLists.txt中提供了一个CMake的命令。 12# 生成动态库ADD_LIBRARY(libname SHARED library.c library.h) 新建一个静/动态库工程 C++ Executable/C Executable这两个选项提供的是执行项目的创建。最简单的HelloWorld会通过这两个工程项去建立。","categories":[{"name":"CLion","slug":"CLion","permalink":"http://gmle.github.io/categories/CLion/"}],"tags":[{"name":"CLion","slug":"CLion","permalink":"http://gmle.github.io/tags/CLion/"}]},{"title":"C语言中的函数指针","slug":"C语言的函数指针","date":"2018-07-06T13:36:43.611Z","updated":"2018-07-06T13:56:58.883Z","comments":true,"path":"2018/07/06/C语言的函数指针/","link":"","permalink":"http://gmle.github.io/2018/07/06/C语言的函数指针/","excerpt":"函数名本质就是一个函数指针。它是一个指向函数的地址。","text":"函数名本质就是一个函数指针。它是一个指向函数的地址。 函数指针的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** * 函数指针和指针函数的区别： * 函数指针：指向了函数的指针。 * 指针函数：函数返回至是指针的函数。 */static void func(int a, char c) &#123; printf(\"Aaa\");&#125;static void test01() &#123; // 先定义出函数类型，再通过类型定义函数指针。 typedef void (FUNC_TYPE)(int, char); FUNC_TYPE *pFunc = func; pFunc(10, 'a');&#125;static void test02() &#123; // 先定义出函数指针类型，再通过类型定义函数指针。 typedef void (*FUNC_TYPE)(int, char); FUNC_TYPE pFunc = func; pFunc(10, 'a');&#125;static void test03() &#123; // 直接定义函数指针变量。 void (*pFunc)(int, char) = func; pFunc(10, 'a');&#125;static void func1() &#123; printf(\"aaa\");&#125;static void func2() &#123; printf(\"bbb\");&#125;static void func3() &#123; printf(\"ccc\");&#125;/** * 一次性调用多个相同返回值，相同形参的函数 */static void test04() &#123; void (*pFuncArr[3])(); pFuncArr[0] = func1; pFuncArr[1] = func2; pFuncArr[2] = func3; for (int i = 0; i &lt; 3; i++) &#123; pFuncArr[i](); puts(\"\"); &#125;&#125;/** * * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123;// test01();// test02();// test03(); test04(); return 0;&#125; 函数指针作函数返回值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static void printTest(void *data, void(*print)(void *))&#123; printf(\"打印调用：\"); print(data);&#125;static void printInt(void *data)&#123; int *pData = data; printf(\"%d\\n\", *pData);&#125;static void test01()&#123; int a = 10; printInt(&amp;a); // 回调函数 printTest(&amp;a, printInt);&#125;typedef struct Person&#123; char name[100]; int age;&#125; per;static void printPerson(void *data)&#123; per *person = data; printf(\"%s, %d\\n\", person-&gt;name, person-&gt;age);&#125;static void test02()&#123; per person = &#123;\"abc\", 10&#125;; printPerson(&amp;person); printTest(&amp;person, &amp;printPerson);&#125;int main(void) &#123;// test01(); test02(); return 0;&#125; 回调函数小例子:打印任意类型的数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 打印任意类型的数组static void printArray(void *pArray, int lenth, int elementSize, void (*print)(void *)) &#123; char *p = pArray; for (int i = 0; i &lt; lenth; i++) &#123; char *elementAddress = p + elementSize * i; print(elementAddress); &#125;&#125;// 打印int类型数组回调函数实现static void printIntArr(void *data) &#123; int *pArr = data; printf(\"%d\\n\", *pArr);&#125;// 打印int类型数组static void test01() &#123; int arr[6] = &#123;1, 2, 3, 4, 5, 6&#125;; int arrLen = sizeof(arr) / sizeof(arr[0]); printArray(arr, arrLen, 4, printIntArr);&#125;typedef struct _PEOPLE &#123; char name[64]; int age;&#125; pp;static void printPeople(void *data) &#123; pp *p = data; printf(\"%s, %d\\n\", p-&gt;name, p-&gt;age);&#125;static void test02() &#123; pp p[3] = &#123; &#123;\"aaa\", 10&#125;, &#123;\"bbb\", 20&#125;, &#123;\"ccc\", 30&#125; &#125;; int pSize = sizeof(p) / sizeof(pp); printArray(p, pSize, sizeof(pp), printPeople);&#125;int main(int argc, char *argv[]) &#123; test01(); test02(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"链表与链表的基本操作","slug":"链表与基本操作","date":"2018-07-06T13:18:32.712Z","updated":"2018-07-12T13:28:46.527Z","comments":true,"path":"2018/07/06/链表与基本操作/","link":"","permalink":"http://gmle.github.io/2018/07/06/链表与基本操作/","excerpt":"为什么要使用链表： 数组缺陷 一旦分配好内存，不能再动态扩展。 如果分配过多，会造成资源浪费 对于头部插入或删除的效率低","text":"为什么要使用链表： 数组缺陷 一旦分配好内存，不能再动态扩展。 如果分配过多，会造成资源浪费 对于头部插入或删除的效率低 链表的组成 数据域 存放所存储的其类型的数据 指针域 存放节点指针(根据链表类型指定，单向链表存放下一节点指针) 链表的分类 链表分类一： 静态链表：在栈区分配内存 动态链表：在堆区分配内存 链表分类二： 单向链表；双向链表：指针域记录 一个/多个 指针 单向循环链表；双向循环链表：尾部指针域指向链表首位。 静态链表和动态链表 静态链表分配在栈上 动态链表分配到堆区 静态链表的初始化以及遍历1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct _LINKENODE_01 &#123; //数据域 int num; // 指针域 struct _LINKENODE_01 *next;&#125; lineNode;/** * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123; // 创建节点 struct _LINKENODE_01 node1 = &#123;10, NULL&#125;; struct _LINKENODE_01 node2 = &#123;20, NULL&#125;; struct _LINKENODE_01 node3 = &#123;30, NULL&#125;; struct _LINKENODE_01 node4 = &#123;40, NULL&#125;; struct _LINKENODE_01 node5 = &#123;50, NULL&#125;; // 建立关系 node1.next = &amp;node2; node2.next = &amp;node3; node3.next = &amp;node4; node4.next = &amp;node5; node5.next = NULL; lineNode *node = &amp;node1; while (node != NULL)&#123; printf(\"%d\\n\", node-&gt;num); node = node-&gt;next; &#125; return 0;&#125; 动态链表的初始化与遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct _LINKENODE_02 &#123; //数据域 int num; // 指针域 struct _LINKENODE_02 *next;&#125;;static void test01()&#123; struct _LINKENODE_02 *node1 = malloc(sizeof(struct _LINKENODE_02 *)); struct _LINKENODE_02 *node2 = malloc(sizeof(struct _LINKENODE_02 *)); struct _LINKENODE_02 *node3 = malloc(sizeof(struct _LINKENODE_02 *)); struct _LINKENODE_02 *node4 = malloc(sizeof(struct _LINKENODE_02 *)); struct _LINKENODE_02 *node5 = malloc(sizeof(struct _LINKENODE_02 *)); node1-&gt;num = 10; node1-&gt;num = 20; node1-&gt;num = 30; node1-&gt;num = 40; node1-&gt;num = 50; node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = node5; node5-&gt;next = NULL; free(node1); free(node2); free(node3); free(node4); free(node5);&#125;/** * 动态链表创建在堆上 */int main02(int argc, char *argv[]) &#123; test01(); return 0;&#125; 带头链表的基本操作FILE1: headLinkTable.h 123456789101112131415161718192021222324252627282930313233343536373839#ifndef _HEADLINKTABLE_H#define _HEADLINKTABLE_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#pragma once#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct _LinkNode &#123; int num; struct _LinkNode *next;&#125;;// 初始化链表struct _LinkNode *initLinkList();// 遍历链表void foreach_LinkList(struct _LinkNode *pHeader);// 插入链表void insert_LinkList(struct _LinkNode *pHeader, int oldVal, int newVal);// 删除链表节点void deleteNode_LinkList(struct _LinkNode *pHeader, int val);// 清空链表void clear_LinkList(struct _LinkNode *pHeader);// 销毁链表void destroy_LinkList(struct _LinkNode *pHeader);#endif // _HEADLINKTABLE_H FILE2:_headLinkTable_imp.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include \"_headLinkTable.h\"//初始化链表struct _LinkNode *initLinkList() &#123; //创建头节点 struct _LinkNode *pHeader = malloc(sizeof(struct _LinkNode)); if (pHeader == NULL) &#123; return NULL; &#125; //初始化头节点 //pHeader-&gt;num = -1; //头节点 不维护数据域 pHeader-&gt;next = NULL; //记录尾节点位置，方便插入新的数据 struct _LinkNode *pTail = pHeader; int val = -1; while (1) &#123; //让用户初始化几个节点，如果用户输入的是-1，代表插入结束 printf(\"请初始化链表，如果输入-1代表结束\\n\"); scanf(\"%d\", &amp;val); if (val == -1) &#123; break; &#125; //如果输入不是-1 插入节点到链表中 struct _LinkNode *newNode = malloc(sizeof(struct _LinkNode)); newNode-&gt;num = val; newNode-&gt;next = NULL; //更改指针的指向 pTail-&gt;next = newNode; //更新新的尾节点的指向 pTail = newNode; &#125; return pHeader;&#125;//遍历链表void foreach_LinkList(struct _LinkNode *pHeader) &#123; if (pHeader == NULL) &#123; return; &#125; struct _LinkNode *pCurrent = pHeader-&gt;next; //指定第一个有真实数据的节点 while (pCurrent != NULL) &#123; printf(\"%d\\n\", pCurrent-&gt;num); pCurrent = pCurrent-&gt;next; &#125;&#125;//插入链表void insert_LinkList(struct _LinkNode *pHeader, int oldVal, int newVal) &#123; if (pHeader == NULL) &#123; return; &#125; //创建两个临时的节点 struct _LinkNode *pPrve = pHeader; struct _LinkNode *pCurrent = pHeader-&gt;next; while (pCurrent != NULL) &#123; if (pCurrent-&gt;num == oldVal) &#123; break; &#125; //如果没找到对应的位置,辅助指针向后移动 pPrve = pCurrent; pCurrent = pCurrent-&gt;next; &#125; //创建新节点 struct _LinkNode *newNode = malloc(sizeof(struct _LinkNode)); newNode-&gt;num = newVal; newNode-&gt;next = NULL; //建立关系 newNode-&gt;next = pCurrent; pPrve-&gt;next = newNode;&#125;// 删除链表节点void deleteNode_LinkList(struct _LinkNode *pHeader, int val) &#123; if (pHeader == NULL) &#123; return; &#125; // 一前一后两个辅助指针变量 struct _LinkNode *pPrev = pHeader; struct _LinkNode *pCurrent = pHeader-&gt;next; // 循环查找val while (pCurrent != NULL) &#123; if (pCurrent-&gt;num == val) &#123; break; &#125; //没有找到数据，辅助指针向后移动 pPrev = pCurrent; pCurrent = pCurrent-&gt;next; &#125; // 没找到节点则返回 if (pCurrent == NULL) &#123; return; &#125; // 若找到该数据节点，则更改前一指针指向到目标数据节点的下一节点指针。 pPrev-&gt;next = pCurrent-&gt;next; //删除掉待删除的节点并置空 free(pCurrent); pCurrent = NULL;&#125;// 清空链表void clear_LinkList(struct _LinkNode *pHeader) &#123; if (pHeader == NULL) &#123; return; &#125; struct _LinkNode *pCurrent = pHeader-&gt;next; while (pCurrent != NULL) &#123; struct _LinkNode *nextNode = pCurrent-&gt;next; free(pCurrent); pCurrent = nextNode; &#125; pHeader-&gt;next = NULL;&#125;// 销毁链表void destroy_LinkList(struct _LinkNode *pHeader) &#123; if (pHeader == NULL) &#123; return; &#125; clear_LinkList(pHeader); free(pHeader); pHeader = NULL;&#125; FILE3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** * 带头链表的基本操作 * @param argc * @param argv * @return */#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include \"_headLinkTable.h\"void test01() &#123; //初始化链表 struct _LinkNode *pHeader = initLinkList(); //遍历链表 printf(\"遍历链表结果为：\\n\"); foreach_LinkList(pHeader); //插入链表 // 10 1000 2000 20 3000 30 500 insert_LinkList(pHeader, 20, 1000); insert_LinkList(pHeader, 20, 2000); insert_LinkList(pHeader, -1, 500); insert_LinkList(pHeader, 30, 3000); printf(\"插入链表后，遍历链表结果为：\\n\"); foreach_LinkList(pHeader); deleteNode_LinkList(pHeader, 1000); printf(\"删除1000元素后，遍历链表结果为：\\n\"); foreach_LinkList(pHeader); clear_LinkList(pHeader); destroy_LinkList(pHeader);&#125;int main() &#123; test01(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://gmle.github.io/tags/数据结构/"}]},{"title":"C语言的文件读写小案例","slug":"C语言的文件读写小案例","date":"2018-07-05T13:45:32.417Z","updated":"2018-07-06T13:58:58.887Z","comments":true,"path":"2018/07/05/C语言的文件读写小案例/","link":"","permalink":"http://gmle.github.io/2018/07/05/C语言的文件读写小案例/","excerpt":"C语言一个读写配置的简单案例","text":"C语言一个读写配置的简单案例 FILE1：1234567891011121314151617181920212223242526#ifndef _CONFIG_H#define _CONFIG_Hstruct ConfigInfo&#123; char key[64]; char value[64];&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int getConfigFileLines(char *path);int isValidLine(char *string);void fileResolving(char * filePath, int lines, struct ConfigInfo ** config);char *getValueByKey(char *key, struct ConfigInfo *config, int lines);void freeConfigInfo(struct ConfigInfo *configinfo);#endif //_CONFIG_H FILE2:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include \"config.h\"int getConfigFileLines(char *ConfigPath) &#123; FILE *configFile = fopen(ConfigPath, \"r\"); if (configFile == NULL) &#123; return -1; &#125; char tmpBuf[1024] = &#123;0&#125;; int configLine = 0; while (fgets(tmpBuf, 1024, configFile) != NULL) &#123;// printf(\"000+\"); if (isValidLine(tmpBuf)) &#123; configLine++; memset(tmpBuf, 0, 1024); &#125; &#125; fclose(configFile); return configLine;&#125;int isValidLine(char *string) &#123; if (strchr(string, ':') == NULL) &#123; return 0; &#125; return 1;&#125;void fileResolving(char *filePath, int lines, struct ConfigInfo **config) &#123; struct ConfigInfo *configInfo = malloc(sizeof(struct ConfigInfo) * lines); if (configInfo == NULL) &#123; return; &#125; FILE *file = fopen(filePath, \"r\"); if (file == NULL) &#123; perror(\"Failed\"); &#125; char key[64] = &#123;0&#125;; char value[64] = &#123;0&#125;; char tmpBuf[1024] = &#123;0&#125;; int configNum = 0; while (fgets(tmpBuf, 1024, file) != NULL) &#123; if (isValidLine(tmpBuf)) &#123; memset(configInfo[configNum].key, 0, 1024); memset(configInfo[configNum].value, 0, 1024); char *pos = strchr(tmpBuf, ':'); strncpy(configInfo[configNum].key, tmpBuf, pos - tmpBuf); strncpy(configInfo[configNum].value, pos + 1, strlen(pos + 1) - 1); printf(\"0000000000:%s\\n\", configInfo[configNum].key); printf(\"1111111111:%s\\n\", configInfo[configNum].value); configNum++; &#125; memset(tmpBuf, 0, 1024); &#125; *config = configInfo;&#125;char *getValueByKey(char *key, struct ConfigInfo *config, int lines) &#123; printf(\"aaa\"); if (key == NULL || lines == 0) &#123; perror(\"aaa\"); return NULL; &#125; for (int i = 0; i &lt; lines; i++) &#123; if (strcmp(key, config[i].key) == 0) &#123; return config[i].value; &#125; &#125; return NULL;void freeConfigInfo(struct ConfigInfo *configinfo) &#123; if (configinfo != NULL) &#123; free(configinfo); configinfo = NULL; &#125;&#125; FILE3:1234567891011121314151617181920212223#include \"config.h\"int main(int argc, char *argv[]) &#123; char *configPath = \"config.ini\"; int lines = getConfigFileLines(configPath); printf(\"%d\\n\", lines); struct ConfigInfo *configInfo = NULL; fileResolving(configPath, lines, &amp;configInfo); printf(\"%s\\n\", getValueByKey(\"heroId\", configInfo, lines)); freeConfigInfo(configInfo); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言中结构体的偏移量与内存对齐","slug":"C语言中结构体的偏移量","date":"2018-07-05T13:28:28.344Z","updated":"2018-07-05T13:42:02.936Z","comments":true,"path":"2018/07/05/C语言中结构体的偏移量/","link":"","permalink":"http://gmle.github.io/2018/07/05/C语言中结构体的偏移量/","excerpt":"C语言中结构体在内存中的偏移量问题。","text":"C语言中结构体在内存中的偏移量问题。 查看对齐模数#pragma pack(show)默认对齐模数是8。 自定义数据的对齐规则 第一个属性开始 从0开始偏移 第二个属性开始 要放在 该类型的大小 与 对齐模数比 取小的值 的整数倍 所有属性都计算完后，再整体做二次偏移，将整体计算的结果 要放在 结构体最大类型 与对齐模数比 取小的值的 整数倍上 结构体嵌套结构体 结构体嵌套结构体时候，子结构体放在该结构体中最大类型，和对齐模数比的整数倍上即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;stddef.h&gt;struct Teacher &#123; char a; //0 ~ 3 int b; //4 ~ 7&#125;;void test01() &#123; struct Teacher t1; struct Teacher *p = &amp;t1; printf(\"b的属性偏移量为：%d\\n\", (int) &amp;(p-&gt;b) - (int) p); printf(\"b的属性偏移量为：%d\\n\", offsetof(struct Teacher, b));&#125;//通过偏移量 操作内存void test02() &#123; struct Teacher t1 = &#123;'a', 10&#125;; printf(\"t1.b = %d\\n\", *(int *) ((char *) &amp;t1 + offsetof(struct Teacher, b))); printf(\"t1.b = %d\\n\", *(int *) ((int *) &amp;t1 + 1));&#125;struct Teacher2 &#123; char a; int b; struct Teacher c;&#125;;void test03() &#123; struct Teacher2 t1 = &#123;'a', 10, 'b', 20&#125;; int offset1 = offsetof(struct Teacher2, c); int offset2 = offsetof(struct Teacher, b); printf(\"%d\\n\", *(int *) ((char *) &amp;t1 + offset1 + offset2)); printf(\"%d\\n\", ((struct Teacher *) ((char *) &amp;t1 + offset1))-&gt;b);&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言中结构体的二级指针","slug":"C语言结构体的二级指针","date":"2018-07-05T13:17:17.743Z","updated":"2018-07-05T13:18:37.342Z","comments":true,"path":"2018/07/05/C语言结构体的二级指针/","link":"","permalink":"http://gmle.github.io/2018/07/05/C语言结构体的二级指针/","excerpt":"C语言中结构体嵌套二级指针申请内存。","text":"C语言中结构体嵌套二级指针申请内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct Teacher &#123; char *name; char **students;&#125;Teacher;static void allocateSpace(struct Teacher ***teachers) &#123; if (teachers == NULL) &#123; return; &#125; //开辟内存 struct Teacher **ts = malloc(sizeof(struct Teacher *) * 3); //给每个老师分配内存 for (int i = 0; i &lt; 3; i++) &#123; ts[i] = malloc(sizeof(struct Teacher)); //给老师的姓名分配内存 ts[i]-&gt;name = malloc(sizeof(char) * 64); //给老师起名称 sprintf(ts[i]-&gt;name, \"Teacher_%d\", i + 1); //给学生的数组分配内存 ts[i]-&gt;students = malloc(sizeof(char *) * 4); //给学生的姓名开辟内存 以及赋值 for (int j = 0; j &lt; 4; j++) &#123; ts[i]-&gt;students[j] = malloc(sizeof(char) * 64); sprintf(ts[i]-&gt;students[j], \"%s_Student_%d\", ts[i]-&gt;name, j + 1); &#125; &#125; *teachers = ts;&#125;static void printTeachers(struct Teacher **pArray) &#123; if (pArray == NULL) &#123; return; &#125; for (int i = 0; i &lt; 3; i++) &#123; printf(\"%s\\n\", pArray[i]-&gt;name); for (int j = 0; j &lt; 4; j++) &#123; printf(\" %s\\n\", pArray[i]-&gt;students[j]); &#125; &#125;&#125;static void freeSpace(struct Teacher **pArray) &#123; if (pArray == NULL) &#123; return; &#125; for (int i = 0; i &lt; 3; i++) &#123; //先释放老师姓名 if (pArray[i]-&gt;name != NULL) &#123; free(pArray[i]-&gt;name); pArray[i]-&gt;name = NULL; &#125; //释放学生姓名 for (int j = 0; j &lt; 4; j++) &#123; if (pArray[i]-&gt;students[j] != NULL) &#123; free(pArray[i]-&gt;students[j]); pArray[i]-&gt;students[j] = NULL; &#125; &#125; //释放学生的数组 if (pArray[i]-&gt;students != NULL) &#123; free(pArray[i]-&gt;students); pArray[i]-&gt;students = NULL; &#125; //释放老师 if (pArray[i] != NULL) &#123; free(pArray[i]); pArray[i] = NULL; &#125; &#125; //释放老师数组 if (pArray != NULL) &#123; free(pArray); pArray = NULL; &#125;&#125;static void test01() &#123; struct Teacher **pArray = NULL; //开辟内存 allocateSpace(&amp;pArray); //打印数组 printTeachers(pArray); //释放数组 freeSpace(pArray); pArray = NULL;&#125;int main01() &#123; test01(); system(\"pause\"); return EXIT_SUCCESS;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的深拷贝与浅拷贝","slug":"C语言中struct的深拷贝与浅拷贝","date":"2018-07-03T11:45:05.240Z","updated":"2018-07-03T11:58:12.221Z","comments":true,"path":"2018/07/03/C语言中struct的深拷贝与浅拷贝/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言中struct的深拷贝与浅拷贝/","excerpt":"系统提供的赋值操作是 浅拷贝 – 简单值拷贝，逐字节拷贝如果结构体中有属性 创建在堆区，就会出现问题，在释放期间，一段内存重复释放，一段内存泄露","text":"系统提供的赋值操作是 浅拷贝 – 简单值拷贝，逐字节拷贝如果结构体中有属性 创建在堆区，就会出现问题，在释放期间，一段内存重复释放，一段内存泄露 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct People &#123; char *name; int age;&#125; peo;static void test01() &#123; peo p1; peo p2; p1.name = malloc(sizeof(char) * 64); strcpy(p1.name, \"a\"); p2.name = malloc(sizeof(char) * 128); strcpy(p2.name, \"bbbbbbbbb\"); p1.age = 10; p2.age = 20; p1 = p2; // 浅拷贝，值拷贝。 /** * 出现的问题： * 1、p1指向的内存会发生内存泄漏 * 2、p1、p2指向的内存在释放的时候会发生重复释放。 */ // 解决方法 p1.name = realloc(p1.name, strlen(p2.name)); memset(p1.name, 0, strlen(p2.name)); strcpy(p1.name, p2.name); p1.age = p2.age; if (p1.name != NULL) &#123; free(p1.name); p1.name = NULL; &#125; if (p2.name != NULL) &#123; free(p2.name); p2.name = NULL; &#125;&#125;int main06(int argc, char *argv[]) &#123; typedef struct Teacher &#123; char name[64]; int age; &#125; Teacher_t; int offset = (int)&amp;(((Teacher_t *) 0)-&gt;age); printf(\"%d\", offset); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的数组选择排序","slug":"C语言中的数组之选择排序","date":"2018-07-03T11:27:40.679Z","updated":"2018-07-03T11:49:01.970Z","comments":true,"path":"2018/07/03/C语言中的数组之选择排序/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言中的数组之选择排序/","excerpt":"选择排序的核心：开始认定最小值下标为i，从j = i+1的位置起找真实最小值下标，如果计算的真实最小值下标与i不等，互换元素。","text":"选择排序的核心：开始认定最小值下标为i，从j = i+1的位置起找真实最小值下标，如果计算的真实最小值下标与i不等，互换元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static void chooseSort4Str(char **arr, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; int min = i; for (int j = i + 1; j &lt; len; j++) &#123; if (strcmp(arr[min], arr[j]) &lt; 0) &#123; min = j; &#125; &#125; if (i != min) &#123; char *temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125;&#125;static void test01() &#123; char *pArray[] = &#123;\"fff\", \"bbb\", \"ccc\", \"aaa\", \"eee\", \"ddd\"&#125;; int arrLen = sizeof(pArray) / sizeof(pArray[0]); chooseSort4Str(pArray, arrLen); for (int i = 0; i &lt; arrLen; i++) &#123; printf(\"%s\\n\", pArray[i]); &#125; printf(\"%d\\n\", arrLen);&#125;/** * 选择排序： * 认定最小值下表为i，从开始i+1位置起，找真实下标值，若真实下标值与i不等，则互换元素。 * @param arr * @param len */static void chooseSort(int *arr, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; int min = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125;&#125;static void test02() &#123; // 选择排序 int arr[] = &#123;3, 1, 2, 5, 4&#125;; int lenArr = sizeof(arr) / sizeof(arr[0]); chooseSort(arr, lenArr); for (int i = 0; i &lt; lenArr; i++) &#123; printf(\"%d\\n\", arr[i]); &#125;&#125;int main04(int argc, char *argv[]) &#123; // test02(); test01(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言中的二维数组指针","slug":"C语言中的二维数组指针","date":"2018-07-03T11:18:58.068Z","updated":"2018-07-03T11:59:42.086Z","comments":true,"path":"2018/07/03/C语言中的二维数组指针/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言中的二维数组指针/","excerpt":"C语言中的一维数组指针","text":"C语言中的一维数组指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;static void test01() &#123; int arr[3][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;; /** * 除两种特殊情况外，二维数组名称是指向第一个一维数组的指针。 * 1、sizeof * 2、对数组名取地址，获取的是二维数组的数组指针，步长是整个二维数组的长度。 */ printf(\"%u\\n\", (unsigned int) sizeof(arr)); // int (*pArr)[3] = arr; // int (*pArr2)[3][3] = &amp;arr; assert(arr[1][2] == *(*(pArr + 1) +2)); printf(\"%d\\n\", arr[1][2]); printf(\"%d\\n\", *(*(pArr + 1) +2));&#125;// static void print2Arr(int (*arr)[3], int len)&#123;// static void print2Arr(int arr[][3], int len)&#123;static void print2Arr(int arr[3][3], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; printf(\"%d \", arr[i][j]); &#125; puts(\"\"); &#125;&#125;int main(int argc, char *argv[]) &#123;// test01(); int arr[3][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;; print2Arr(arr, 3); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的一维数组指针","slug":"C语言中的一维数组指针","date":"2018-07-03T11:05:24.699Z","updated":"2018-07-03T11:59:26.799Z","comments":true,"path":"2018/07/03/C语言中的一维数组指针/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言中的一维数组指针/","excerpt":"C语言中的一维数组指针","text":"C语言中的一维数组指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 数组指针的定义方式： * 1、先定义数组类型，再通过类型定义数组指针。 * 2、先定义数组指针类型，再通过类型定义数组指针 * 3、直接定义数组指针变量 */&lt;!-- more --&gt;// 1、先定义数组类型，再通过类型定义数组指针。static void test01() &#123; int arr[5] = &#123;1, 2, 3, 4, 5&#125;; typedef int (ARRAY)[5]; ARRAY *pArr = &amp;arr; for (int i = 0; i &lt; 5; i++) &#123; printf(\"%d\\n\", (*pArr)[i]); &#125;&#125;// 先定义数组指针类型，再通过类型定义数组指针static void test02() &#123; int arr[5] = &#123;1, 2, 3, 4, 5&#125;; typedef int (*ARRAY)[5]; ARRAY pArr = &amp;arr; for (int i = 0; i &lt; 5; i++) &#123; printf(\"%d\\n\", (*pArr)[i]); &#125;&#125;// 直接定义数组指针变量static void test03() &#123; int arr[] = &#123;1, 2, 3, 4, 5&#125;; int (*pArr)[5] = &amp;arr;&#125;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; //test01(); //test02(); test01(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的一维数组","slug":"C语言中的一维数组","date":"2018-07-03T02:08:34.069Z","updated":"2018-07-03T11:59:13.299Z","comments":true,"path":"2018/07/03/C语言中的一维数组/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言中的一维数组/","excerpt":"C语言中的一维数组","text":"C语言中的一维数组 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; // 一维数组名是不是指针? int arr[5] = &#123;1, 2, 3, 4, 5&#125;; printf(\"%u\\n\", (unsigned int) sizeof(arr)); /* * 两种特殊情况，一维数组不是指向第一个元素的指针： * sizeof。 * 对数组名取地址，得到数组指针 步长是整个数组长度 * */ printf(\"%p\\n\", &amp;arr); printf(\"%p\\n\", &amp;arr + 1); //arr数组名 它是一个指针常量 指针的指向不可以修改的，而指针指向的值可以改 int * const a ; //arr[0] = 1000; //arr = NULL; //数组索引 可不可以为负数 int * p = arr; p = p + 3; printf(\"%d\\n\",p[-1]); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言实现strstr","slug":"C语言实现strstr","date":"2018-07-03T00:46:49.906Z","updated":"2018-07-03T11:58:58.743Z","comments":true,"path":"2018/07/03/C语言实现strstr/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言实现strstr/","excerpt":"C语言中有一个内置库函数 strstr，实现了一个自己的strstr。","text":"C语言中有一个内置库函数 strstr，实现了一个自己的strstr。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const char *isSub(const char *str, const char *subs) &#123; // 特殊情况 if (!*subs) return str; const char *tmp = str; while (*tmp != '\\0') &#123; // 记录父串地址 const char *tmp1 = tmp; // 记录子串地址 const char *sub1 = subs; while (*sub1 != '\\0' &amp;&amp; *tmp1 != '\\0') &#123; // 若不相等则跳出，将父串后移一个字符 if (*sub1 != *tmp1) break; // 若相等且子串下一个字符是末尾则是这个父串的子串 if (*sub1 == *tmp1 &amp;&amp; *(sub1 + 1) == '\\0') return tmp; // 若相等则继续比较下一个字符 if (*sub1 == *tmp1) &#123; sub1++; tmp1++; &#125; &#125; tmp++; &#125; return NULL;&#125;int main(int argc, char *argv[]) &#123; char a[] = \"aaaaabbbcdef\"; const char *res = isSub(a, \"ab\"); printf(\"%p\\n\", &amp;res); return 0;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的sscanf","slug":"C语言的sscanf","date":"2018-07-03T00:43:30.123Z","updated":"2018-07-03T12:00:29.367Z","comments":true,"path":"2018/07/03/C语言的sscanf/","link":"","permalink":"http://gmle.github.io/2018/07/03/C语言的sscanf/","excerpt":"sscanf中正则的使用","text":"sscanf中正则的使用 sscanf的使用中间夹取正则表达式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static void test01() &#123; char str[] = \"11111aaaa\"; char buf[] = &#123;0&#125;; sscanf(str, \"%*d%s\", buf); printf(\"%s\\n\", buf);&#125;static void test02() &#123; char str[] = \"11111aaaa\"; char buf[] = &#123;0&#125;; sscanf(str, \"%[0-9]\", buf); printf(\"%s\\n\", buf);&#125;static void test03() &#123; char str[] = \"hello@123.com\"; char name[100] = &#123;0&#125;; char net[100] = &#123;0&#125;; sscanf(str, \"%[^@]%*[@]%s\", name, net); printf(\"%s\\n\", name); printf(\"%s\\n\", net); strstr(name, net);&#125;int main(int argc, char *argv[]) &#123;// test01();// test02(); test03(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的malloc、calloc、realloc","slug":"C语言的calloc.malloc.realloc","date":"2018-07-02T13:50:20.582Z","updated":"2018-07-03T11:53:41.823Z","comments":true,"path":"2018/07/02/C语言的calloc.malloc.realloc/","link":"","permalink":"http://gmle.github.io/2018/07/02/C语言的calloc.malloc.realloc/","excerpt":"calloc 和 realloc","text":"calloc 和 realloc calloc 和malloc 都是在堆区分配内存 与malloc不同的是，calloc会将空间初始化为0 calloc（个数，大小） realloc 重新分配内存 如果重新分配的内存比原来大，那么不会初始化新空间为0 先看后续空间，如果足够，那么直接扩展 如果后续空闲空间不足，那么申请足够大的空间，将原有数据拷贝到新空间下，释放掉原有空间，将新空间的首地址返回 如果重新分配的内存比原来小，那么释放后序空间，只有权限操作申请空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** * calloc 自动将开辟的内存置0. */static void usecalloc() &#123; int *p = calloc(1, sizeof(int)); printf(\"%d\\n\", *p); free(p);&#125;static void userelloc() &#123; int *p = calloc(1, sizeof(int)); for (int i = 0; i &lt; 4; i++) &#123; p[i] = i + 1; &#125; for (int i = 0; i &lt; 6; i++) &#123; printf(\"%d\\n\", p[i]); &#125; printf(\"%p\\n\", p); printf(\"-------------------\\n\"); p = realloc(p, sizeof(int) * 20); printf(\"%p\\n\", p); for (int i = 0; i &lt; 10; i++) &#123; printf(\"%d\\n\", p[i]); &#125; free(p);&#125;int main(int argc, char *argv[]) &#123;// usecalloc(); userelloc(); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的一点语言特性","slug":"C语言的一点语言特性","date":"2018-06-29T13:47:23.022Z","updated":"2018-06-30T13:35:44.692Z","comments":true,"path":"2018/06/29/C语言的一点语言特性/","link":"","permalink":"http://gmle.github.io/2018/06/29/C语言的一点语言特性/","excerpt":"关于C语言的一些特性。","text":"关于C语言的一些特性。 这些特性可能会被称为bug，但它确实是特性。 malloc开辟char字符串的内存空间无论在什么时候出现这样一条语句： 1malloc(strlen(str)); 几乎可以判定它是错误的，而 1malloc(strlen(str)+1); 才是正确的。这是因为其它的字符串处理库函数几乎都包含一个额外空间，用于容纳字符串结尾处的‘\\0’字符。 C语言中的const并非真正的cosnt123456789101112131415161718192021int main(int argc, char *argv[]) &#123; const int one = 10; const int two = 20; char str[10] = &#123;10&#125;; scanf(\"%s\",str); switch (str)&#123; case one: printf(\"%u\",one); break; case two: printf(\"%u\",one); break; default:break; &#125; return 0;&#125; 上面这段代码会出现编译错误，这并不是switch语句本身的错误，但这条语句展示了其const并非真正的常量。 字符串的自动合并12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char *str[] = &#123; \"aaa\", \"bbb\" // 少了个逗号，则在编译的时候回自动合并。 \"ccc\", \"ddd\", &#125;; for (int i = 0; i &lt; strlen(str); i++) &#123; printf(\"%s\\n\", (char *) str[i]); &#125; printf(\"%s\", *str); return 0;&#125; 上例中，如果在写代码的时候不小心漏掉一个逗号，在程序编译的时候，编译器将不会报错，而是会自动合并为一个字符串。而最后一个字符串的逗号存在与否都没有意义。但这种拖尾的逗号将会抑制程序的正确行为，这对程序没有任何好处。 缺省关键字的可见性定义C函数或者是全局变量的时候，在缺省情况下函数名字是全局可见的。可以在函数或者全局变量的前面加上‘extern’关键字，也可以不加，想过是一样的。如果想限制函数或者变量的访问，则需要加上‘static’关键字。 事实上，几乎没有人所有人都没有在其前面加上村塾类型说明符的习惯，所以函数大多数是全局可见的。 根据实际经验，这种缺省的全局可见性多次被证明是个错误。这种太大范围的全局可见性会与C语言的另一个特性相互产生影响，那就是interpositioning。就是用户编写和库函数同名的函数并取而代之的行为 范围过宽的问题常见于库中：一个库需要让一个对象在另一个库中可见，唯一的方法就是让它全局可见。但这样一来，它对于链接到该库的所有对象都是可见的了，在C语言中，对信息可见性的选择就是这么有限。 没有人会记得在他们之前加上static限定符，所以它们在缺省情况下是全局可见的。 C语言简洁之过C语言中属于“误做值过”的特性，就是语言中有误导性质或者不适当的特性。这些特性有些跟C语言的简洁有关（部分与符号的过度复用有关），有些则与操作符的有限及有关。 重载许多符号被重载的在不同的上下文环境里有不同的意义。 符号 意义 static 在函数内部，表示该便拉近的值在各个调用间一直保持延续性 在函数这一级，表示该函数只对本文件可见 extern 用于函数定义，表示全局可见（冗余） 用于变量，表示它在其他地方定义 void 作为函数的返回类型，表示不返回任何值 在指针声明中，表示通用指针的类型 位于参数列表中目标是没有参数 * 乘法运算符 用户指针，间接引用 在声明中，表示指针 &amp; 位运算符 AND操作符 取地址操作符 = 赋值运算符 == 比较运算符 &lt;= 小于等于运算符 &lt;== 左移复合运算符 () 在函数定义中，包围形式参数表 调用一个函数 改变表达式的运算顺序 强制类型转换 定义带参数的宏 包围sizeof操作符的操作数 重载问题之例： 12345678// 1p = N * sizeof * p;// 2r = malloc(p);// 3 运算符优先级：先括号，所以先算sizeof(int) = 4, 后4*pa = sizeof(int) * p; 让一个符号表达的意思越多，编译器就越难检测到这个符号在你的使用中所存在的异常情况。 C语言的运算符优先级问题 优先级问题 表达式 误以为的结果 实际结果 .的优先级高于*， -&gt; 操作符用于消除这个问题。 *p.f p所指对象的字段f, (*p).f 对p取f偏移，作为指针，然后解引用。 *(p.f) []高于* int *ap[] ap是个指向int数组的指针。 int (*ap)[] ap是个元素为int指针的数组 int *(ap[]) 函数()高于* int *fp() fp是个函数指针，所指函数返回int。 int(*fp)() fp是个函数，返回int . int (fp()) 逗号运算符在所有运算符中优先级最低 i=1,2; i=(1,2) (i=1),2 我们在表达式中如果有布尔操作、算术运算、位操作等混合计算，始终应该在适当的地方加括号。","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言练习题","slug":"C语言练习题","date":"2018-06-06T12:13:20.353Z","updated":"2018-06-06T12:24:25.907Z","comments":true,"path":"2018/06/06/C语言练习题/","link":"","permalink":"http://gmle.github.io/2018/06/06/C语言练习题/","excerpt":"小算法练习题，巩固基础","text":"小算法练习题，巩固基础 韩信点兵 相传韩信才智过人，从不直接清点自己军队的人数。 只要让士兵先后以三人一排、五人一排、七人一排地变换队形，而他每次只看一眼队伍的排尾就知道总人数了。 输入3个非负整数a,b,c ，表示每种队形排尾的人数（a&lt;3,b&lt;5,c&lt;7），输出总人数的最小值（或报告无解）。 已知总人数不小于10，不超过100 。 解析：通过条件排尾人数知道站完队之后最后一排会余下的人数，此操作对应取余。而又有三次队形变换，则每次变换取余得到的人数与输入的人数一致。所以有判断条件：\b假设兵数量为i，则i % 3 == a &amp;&amp; i &amp; 5 == b &amp;&amp; i % 7 == c 人数 不超过100，则人数\b在100以内，所以在 10 &lt; i &lt; 100 中 找到符合条件的人数。 代码：1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; unsigned int a = 0, b = 0, c = 0, i = 0; scanf(\"%u%u%u\", &amp;a, &amp;b, &amp;c); // 总人数不小于10，不超过100 for (i = 10; i &lt;= 100; i++) &#123; if (i % 3 == a &amp;&amp; i % 5 == b &amp;&amp; i % 7 == c) &#123; printf(\"兵：%u\\n\", i); break; &#125; &#125; if (i &gt; 100) &#123; printf(\"超过100\"); &#125; return 0;&#125; 兰州烧饼烧饼有两面，要做好一个兰州烧饼，要两面都弄热。当然，一次只能弄一个的话，效率就太低了。有这么一个大平底锅，一次可以同时放入k个兰州烧饼，一分钟能做好一面。而现在有n个兰州烧饼，至少需要多少分钟才能全部做好呢？","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"征服C指针","slug":"征服C指针","date":"2018-06-04T11:44:18.266Z","updated":"2018-06-15T11:29:55.421Z","comments":true,"path":"2018/06/04/征服C指针/","link":"","permalink":"http://gmle.github.io/2018/06/04/征服C指针/","excerpt":"疑惑我这种菜鸟在学习指针的时候往往会有一些困惑","text":"疑惑我这种菜鸟在学习指针的时候往往会有一些困惑 什么是 “指向int的指针”？ 指针不是地址吗？怎么还有指向类型的指针呢？ scanf在使用 d% 的情况下，变量之前需要加上取地址符 &amp; 才能进行传递，为什么在使用 %s 的时候就可以不加 &amp; 了呢 学习得到将数组名赋值给指针的时候，将指针和数组完全混为一谈： 将没有分配内存区域的指针当做数组进行访问 将指针赋给数组 导致这一系列事件的原因是： C语言砌块的语法 数组和指针之间微妙的兼容性 有经验的程序员会有些疑问： C的声明中，[] 比 * 的优先级高，因此 char *s[10] 这样的声明意为 “指向char的指针的数组” ？ 搞不明白double (*p)[3]; 和 void (*func)(int a); 这样的声明到底怎么阅读。 int *a中，声明a为 ”指向int的指针”。可是表达式中的指针变量前*却代表其他意思。明明是同样的符号，意义为何不同？ int *a和inta[] 在什么情况下可以互换？ 空的[] 可以在什么地方使用，它又代表什么意思呢？ 目标读者和内容结构􏰕􏰄􏰯􏱶􏱾􏱍􏰌􏱞􏰆本书的目标读者为： 粗略的学过C语言的基础，但对指针不太理解的人 平时能自如的使用C语言，但实际对指针理解不够深入的人 本书的内容： 1、从基础开始–预备知识 2、做个试验–C是怎样使用内存的 3、解密C的语法–它到底是怎么回事 4、数组和指针的常用用法 5、数据结构–真正的指针使用方法 6、补充 通过printf来亲眼目睹地址的实际值，这不失为理解指针的一个非常简单有效的方式。 对于那些 “尝试学习了C语言，但对指针还不太理解”的人来说，通过自己的机器实际的输出指针的值，可以将对简单的领会地址的概念 阅读本书，让我们做到 知其然知其所以然。 第一章 从基础开始C是什么样的语言C语言是一门什么语言？ 为了解决眼前问题，由开发现场的人发明的。 虽然使用方便，但看上去不怎么顺眼 如果不熟悉的人稀里糊涂的使用了它，难免会带来悲剧的语言。 C语言的出现C原本是为了开发Unix才做系统内而设计的语言，但早起打的Unix是由汇编开发出来的。后来经过发展，出现的C语言 不完备和不统一的语法 C语言是开发现场的人们根据自身的需要开发出的的语言所以具备极高的实用性。但反过来从人类工程学的角度来看，他就不是那么完美了。 比如：123if (a = 5) &#123; // 本来应该写成==的地方却写成了= /* code */&#125; 相信大家都犯过这种错误吧。 或者：123for (i - 0; i &lt; count; i++) &#123; /* code */&#125; 将赋值的‘=’号写成‘-’；或者在使用switch case的时候，也经常发生忘记写breaak的错误。 幸运的是，如今的编译器对于容易犯的语法错误，在很多地方可以给我们警告提示。因此，不但不能无视这些警告，相反应该提高编译器的警告级别，让编译器替我们指出尽可能多的错误。 C语言是在使用中成长起来的语言，因此\b，由于很多历史原因遗留的一些奇怪的问题。具有代表性的有 位运算符“&amp;”和“|”的优先顺序问题 通常，如“==”的比较运算符的优先级要低于那些做计算的运算符。因此：1if(a &lt; b + 3) 这样的表达式中，虽然可以不适用括号来写，但是当时用了位运算符的时候，就行不通了。想要进行 将a和MASK进行按位与运算后的结果，再和b做比较运算1if (a &amp; MASK == b) 按照上面的写法，因为&amp;运算符的优先级低于==运算符，所以被解释成了下面这样1if (a &amp; （MASK == b）) 这是因为在没有“&amp;&amp;”和“||”运算符的时代，使用“&amp;“和”|”来代替而留下的后遗症。 C的理念 C是危险的语言\b。尤其是，在几乎所有的C语言实现中，运行时的检查总是不充分的。比如：数组越界，在C的大部分处理中，总是悄悄的将数据写入，从而破坏了完全不想管的内存区域。 C是抱着“程序员万能”的理念设计出来的。在C的设计中名优先考虑的是： 如何才能简单的实现编译器（而不是让使用C的人们能够简单化的编程） 如何才能让程序员写出能够生成高效率的执行代码的程序（而不是考虑优化编译器，使编译器生成高效率的执行代码）而安全问题完全被忽略了。但无论怎样，C语言原本就是“仅仅为了自己使用”而开发出来的语言。 C的主体下面的单词中，哪些是C语言中规定的保留字：1if printf main malloc sizeof 答案是 if 和 sizeof。 “printf和malloc不必多说，连main也不是C的保留字吗？”请查一查手头的C语言参考书。相信大部分的C入门书籍中都有C语言保留字的列表 相对于把输入输出作为语言自身功能的一部分，C语言将printf() 这样的输入输出功能从语言的主体中分离出来，让它单纯的成为库函数。对于编译器来说，printf() 函数和其他由程序员写的函数并没有什么不同。 C是只能使用标量的语言对于标量这个词，大家可能有些陌生。简单地说，标量就是指char、int、double和枚举等树枝类型以及指针。相对的，像数组，结构体和共用体这样的将多个标量进行组合的类型，我们应称之为聚合类型。提问：1if (str == \"abc\") 这样的代码为什么不能执行预期的动作呢？对于这样的\b疑问，通常给出的答案是“这个表达式不是在比较字符串的内容，它只是在比较指针”其实还可以给出另一个答案： 字符串其实就是char类型的数组，也就是说它不是标量，当然在C里面不能用==进行比较了。 如今的C用过以下几个追加的功能，已经能够让我们整合的使用聚合类型了。 结构体的一次性赋值 将结构体作为函数参数值传递 将结构体作为函数返回值返回 auto变量的初始化 关于指针指针究竟是什么关于“指针\u001d”一词，在C语言程序设计中有这样的说明： 指针是一种保存变量地址的变量，在C中频繁的使用。 C语言标准中出现过这句话：指针类型可由函数类型。对象类型或不完全的类型派生，派生指针类型的类型称为引用类型。\b指针类型描述一个对象，该类的对象的值提供对该引用类型实体的引用由引用类型T派生的指针类型有时称为“（指向）T的指针”。从引用类型构造指针的过程称为“指针类型的派生”。这些构造派生类型的方法可以递归地应用 第一句话出现了指针类型。“指针类型”其实不是单独存在的，它是由其它类型派生而成的。以上对标准内容的引用中也提到 “由引用类型T派生的指针类型有时称为‘（指向）T的指针’” 也就是说，实际上存在的类型是“指向int/double/char的指针类型”等等。 因为“指针类型”是类型，所以它和innt类型、double类型一样，也存在“指针类型变量”和“指针类型的值”。糟糕的是，”指针类型”、“指针类型变量”和“指针类型的值”经常被简单的统称为“指针”，所以非常容易造成歧义，这一点需要提高警惕。 要点：先有“指针类型”。因为有了类型，才有了此类型的变量，才有了值。 比如，在C中，使用int类型表示整数。因为int是类型，所以存在用于保存innt类型的变量，当然也存在int类型的值。 指针类型同样如此，既存在指针类型的变量，也存在指针类型的值。 因此，几乎所有的处理程序中，所谓的“指针类型的值”，实际是指内存的地址。 和指针的第一次接触下面我们通过实际代码来尝试输出指针的值1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int a = 5; int b = 10; int *a_p = NULL; printf(\"&amp;a = %p\\n\", &amp;a); printf(\"&amp;b = %p\\n\", &amp;b); a_p = &amp;a; printf(\"&amp;a_p = %p\\n\", a_p); printf(\"a_p = %d\\n\", *a_p); *a_p = 19; printf(\"&amp;a_p = %p\\n\", a_p); printf(\"a_p = %d\\n\", *a_p); return 0;&#125; 变量不一定按照声明的顺序保存在内存中 要点： 对变量\b使用&amp;运算符，可以取得该变量的地址。这个地址称为指向该变量的指针。 指针变量保存了指向其他变量的地址的情况下，可以说指针变量指向其变量。 对指针变量运用运算符，就等于同于它指向的变量。如果指针变量指向\b变量，则 x = x. 补充：在说明地址概念的时候，通常使用十六进制来表示地址。如果想要了解地址的真面目，把地址实际的表示出来才是最好的的方式。 指针和地址之间的关系几乎所有的程序中，所谓的“指针类型的值”，实际是指内存的地址。对于这句话，有人也许会产生疑问：一： 归根结底，指针就是地址，地址就是内存中那个被分配的“门牌号”。所以，指针类型和int类型应该是一回事吧。实际上，从某种意义来看，这种认识也不无道理。其实在很多运行环境中，int类型和指针类型的长度并不相同。 二： 指针就是地址吧，那么，指向int的指针、指向double的指针，他们有什么区别么？，有必要区分它们吗？实际上，从某种意义来看，这种说法也有一定道理。 对于大部分的运行环境来说，当程序运行时，不管是指向int的指针，还是指向double的指针，都保持相同的表现形式（偶尔也会有一些运行环境，它们对于指向char的指针和指向int的指针有着不一样的内部表示和位数）。 不仅如此，C还为我们准备了可以指向任何类型的指针类型：void* 类型：123int a = 5;void a_p;a_p = &amp;a; 这并不会报错，但是会出现警告：void* 类型的指针无效 所以需要将地址的数据类型强转为int类型：1*(int*)a_p = &amp;a; 在大部分的运行环境里，不管是指向int的指针，还是指向double的指针，在运行时\b都是相同的事物。可是，通过在int类型的变量去地址锁喉利用指针间接取出来的值，不出意外肯定是int类型。为什么？ 因为int和double的内部表示完全不同。 因此，如今的运行环境，像下面这样取得指向double类型变量的指针，之后将其赋给指向int的指针变量，编译器必定会提示警告。伪代码：123int int_p;double double_p;int_p = &amp;double_value; 将指向double变量的指针赋予指向int的指针变量会出现警告。","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C++ Primer 读书笔记","slug":"cpp_primer","date":"2018-06-03T11:48:50.333Z","updated":"2018-07-21T13:54:23.971Z","comments":true,"path":"2018/06/03/cpp_primer/","link":"","permalink":"http://gmle.github.io/2018/06/03/cpp_primer/","excerpt":"做点什么吧","text":"做点什么吧 第一章 开始 本书采用的C++版本为 C++11 编写一个简单的C++程序 \b就像Java有程序入口一样，C++程序也有入口，它们的入口函数都是 main 函数。 在执行成程序的时候，系统会调用 main 来运行程序。 \bExample：123int main() &#123; return 0;&#125; 我保留了Java的书写习惯，将左大括号放在了函数的一行，（大括号另起一行的都是异教徒！)。 这是一个C++里最简单的函数，这段代码的作用是返回给操作系统一个值：0 。 C++函数构成包括四个部分： 返回值类型 main函数的返回值类型必须为 int，即整数类型。 int类型是一种内置的数据类型。 函数名 主函数名字为main函数，自定义的函数名字可以自行取，而且main函数是程序的一个入口点。 参数列表 本例中没有带有任何参数。 函数体 大括号括起来的语句块即为函数体，此例中函数体中只包含一条语句。 此语句是结束词函数的执行，并向调用者返回一个值；此返回值类型必须与函数的返回值类型相同 重要概念：数据类型 因为Java是从C++演变而来，所以对于数据类型也有很深的认识： 类型是程序设计的\b\b最基本的概念之一，一种数据类型不仅仅定义了数据元素的内容，还定义了这类数据上可以进行的运算 程序所处理的数据都保存在变量中，而每个变量都有自己的数据类型。 编译、运行程序编写好程序之后 我们就需要去编译它。 编译环境我用的是CMake；CMake的使用，我参考了这份资料CMake实践 输入输出C++并没有定义输入输出语句，但是它有一个全面的标准库(std)来提供IO机制以及其他操作。 标准输入输出对象本示例使用的 iostream 库， iostream 库中包含两个基础类型 istream 和 ostream，分别表示输入流和输出流。 ‘流’想要表达的是：随着时间的推移，自复式顺序生成或者消耗的。 标准库定义了四个IO对象。 为了处理输入，我们使用一个\b名为cin的istream类型的对象。这个对象成为标准输入。 为了处理输出，我们使用一个\b名为cout的ostream类型的对象。这个对象成为标准输出。 为了处理警告和错误消息，我们使用一个\b名为cerr的ostream类型的对象，我们称之为标准错误 clog则用来输出程序运行时的一般性信息。 一个使用 IO 库的程序 ​1234567891011121314151617#include &lt;iostream&gt; //告诉编译器我们要使用的库为 iostreamusing namespace std; // using 指令可以告诉我们使用命名空间std，std中包含了 包括cout/cin等常用的函数。int main()&#123; cout &lt;&lt; \" Enter two numbers: \"&lt;&lt;endl; //定义两个int类型的变量 v1,v2 int v1 = 0, v2 = 0; // 使用输入功能 cin,运算符 &gt;&gt;：从键盘接受输入，使接收到的输入内容接收到v1,v2中 cin &gt;&gt; v1 &gt;&gt; v2; // 使用输出功能 cout,运算符 &lt;&lt;：输出内容到屏幕，可以将cout寓意为屏幕，箭头寓意为输出到cout/即屏幕。 cout &lt;&lt; \"The sum of \" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \" is \" &lt;&lt;v1+v2 &lt;&lt; \" .\" &lt;&lt;endl; return 0;&#125; #include (iostream) # 告诉编译器我们要使用的库为 iostream std指代库iostream中的命名空间。 当useing编译指令与变量定义同时出现，优先使用定义。 endl 则被称之为 操纵符 的特殊值，写入endl的效果是结束当前行。并将与设备关联的缓冲区(buffer)刷到设备中。 缓冲刷新操作可以保证截至到目前的所有输出都写入到输出流中。 如果在调试的时候，我们不应该去执行endl将它写入到缓冲区中，应该一直使这个输出流报纸刷新。 注释注释可以帮助人类读者理解带有注释的程序。在编译的时候，编译器会自动忽略注释。 Example：1234567891011121314151617#include (iostream)/** * 这是多行注释 * 请注意 注释 界定符不能嵌套 * */ int main()&#123; std::cout &lt;&lt; \" Enter two numbers: \"&lt;&lt;std::endl; // 这是单行注释。 int v1 = 0, v2 = 0; std::cin &gt;&gt; v1 &gt;&gt; v2; std::cout &lt;&lt; \"The sum of \" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \" is \" &lt;&lt;v1+v2 &lt;&lt; \" .\" &lt;&lt;std::endl; return 0;&#125; 运算符： (&lt;&lt;) 输出运算符 // 还有其他含义 (&gt;&gt;) 输入运算符 // 还有其他含义 (&lt;=) 小于等于 (&gt;=) 大于等于 控制流字面意思：控制程序的运行路径。 while语句while语句会反复执行一段带吗，直到给定的条件为假为止。Example：​12345678910111213141516#include &lt;iostream&gt;int main()&#123; int sum = 0, val = 1; while (val &lt;= 1000) &#123; // 只要val的值小于10，循环就会持续执行， sum += val; // 将sum+val赋值给sum ++val; //val+1 &#125; std::cout &lt;&lt; sum &lt;&lt;std::endl; return 0;&#125; 复合赋值运算符： += 将右侧的运算对象加到左侧运算对象上。 前缀递增运算符 ++ 前缀++可以作为左值来使用，将运算的对象+1 1.4.2 for语句上个while例子中的循环条件检测变量，再循环体中增加变量的模式使用非常频繁，所以C++专门定义了第二种循环语句：for语句。 使用for语句重写从1加到10的程序：Example：123456789101112131415#include &lt;iostream&gt;int main () &#123;​ int num1 = 0, num2 = 0; std::cout &lt;&lt; \"输入 num1： \"&lt;&lt;std::endl; std::cin &gt;&gt; num1; std::cout &lt;&lt; \"输入 num2： \"&lt;&lt;std::endl; for (std::cin &gt;&gt; num2; num2&gt;=num1; ++num1) &#123; std::cout &lt;&lt; num1 &lt;&lt;std::endl; &#125; return 0;&#125; 读取数量不定的输入数据如果我们预先不知道要对多少个数求和，这就需要不断读取数据直至没有新的数据输入为止。 ​12345678910#include &lt;iostream&gt;int main() &#123; int sum = 0, value = 0; while (std::cin &gt;&gt; value)&#123; sum += value; &#125; std::cout &lt;&lt; \"sum is \" &lt;&lt; sum &lt;&lt; std::endl;&#125; 因为 value定义为 int类型，所以如果你输入了别的类型的字符，就会导致判断失败，从而不会再次进行循环，然后返回你输入的值的和。 1.4.4 if语句与大多数语言一样，c++也提供了 if语句来支持条件执行。 Example：123456789101112131415161718192021#include &lt;iostream&gt;int main ()&#123; int isnums = 0, nums = 0; if (std::cin &gt;&gt; isnums) &#123; int count = 1; while (std::cin &gt;&gt; nums) &#123; if (isnums == nums) &#123; ++count; &#125;else &#123; std::cout &lt;&lt; \"The \"&lt;&lt; isnums &lt;&lt; \" occurs \"&lt;&lt; count &lt;&lt; \" times.\" &lt;&lt; std::endl; isnums = nums; count = 1; &#125; &#125; std::cout &lt;&lt; \"The \"&lt;&lt; isnums &lt;&lt; \" occurs \"&lt;&lt; count &lt;&lt; \" times.\" &lt;&lt; std::endl; &#125; return 0;&#125; 类简介在C++中，我们铜鼓哦定义一个类来定义自己的数据结构。一个类定义了一个类型以及与其关联的一组操作。类机制就是C++最重要的特性之一。实际上，C++最初的一个设计焦点上就是能定义使用上像内置类型一样自然的类类型。为了使用类，我们需要了解三件事情。 类名是什么 它是在哪儿定义的 它支持什么操作 对于我们即将写的书店程序来说，假定我们的类名为Sales_item，头文件 Sales_item.h中已经定义了这个类。 Sales_item类Sales_item 类的作用是表示一本书的总销售额、售出册数和平均售价。我们现在不关心这些数据如何存储、如何计算。为了使用一个雷，我们不必关心它是如何实现的，只需要知道类对象可以执行什么操作每个类实际上都定义了一个新的类型，其类型名就是类名。因此，我们的Sales_item类定义了一个名为Sales_item的类型，与内置类型一样，我们可以定义类类型的变量。Example:1Sales_item item; 此语句是想表达item是一个Sales_item类型的对象，我们通常将 “item是一个Sales_item类型的对象” 简单说成 “一个Sales_item对象”或者更简单的说成“一个Sales_item”。 除了定义Sales_item类型的变量之外呢，我们还可以： 调用一个名为isbn的函数从一个Sales_item对象中提取 ISBN 书号 用输入运算符（&gt;&gt;）和输出运算符（&lt;&lt;）读写Sales_item类型的对象。 用加法运算符（+）将两个Sales_item对象相加，两个对象必须表示同一本书。加法结果是一个新的Sales_item对象，其ISBN与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和。 使用复合赋值运算符讲一个Sales_item对象加到另一个对象上。 重要概念：类定义了行为 当你度这些程序时，类Sales_item的作者定义了类对象可以执行的所有动作。即，Sales_item类定义了创建一个Sales_item对象时会发生什么事情。以及对Sales_item对象进行赋值、加法或输入输出运算时会发生什么事情。 一般而言，类的作者决定了类类型对象上可以使用的所有操作。 读写Sales_item 既然即应知道可以对Sales_item对象执行哪些操作，，我们现在就可以便携使用类的程序了。 例如，下面的程序从标准输入读入数据，存入一个Sales_item对象中，然后将Sales_item的内容写回到标准输出。1234567891011121314#include \"Sales_item.hpp\"#include &lt;iostream&gt;int main()&#123; Sales_item book; // 读入ISBN号、售出的册数以及销售价格。 std::cin &gt;&gt; book; // 写入ISBN号、售出的册数、总销售额和平均价格。 std::cout &lt;&lt; book &lt;&lt; std::endl; return 0;&#125; 新的include形式： 来自标准库的头文件 用 ( &lt;&gt; )包围头文件名。 来自不属于标准库的头文件，用 ( “” )包围。 Sales_item 对象的加法下面是一个对象相加的例子。 1234567891011121314151617#include \"addItems.hpp\"#include &lt;iostream&gt;#include \"Sales_item.hpp\"int main()&#123; Sales_item item1, item2; // 读取一对交易记录 std::cin &gt;&gt; item1 &gt;&gt; item2; //打印和 std::cout &lt;&lt; item1 + item2 &lt;&lt; std::endl; return 0;&#125; 初识成员函数将两个Sales_item对象相加的程序首先应该价差两个对象是否具有相同的ISBN。方法如下：12345678910111213141516171819202122#include \"CheckSame.hpp\"#include &lt;iostream&gt;#include \"Sales_item.hpp\"int main()&#123; Sales_item item1, item2; // 读取一对交易记录 std::cin &gt;&gt; item1 &gt;&gt; item2; //首先检查item1和item2是否表示相同的书 if (item1.isbn() == item2.isbn()) &#123; std::cout &lt;&lt; item1 + item2 &lt;&lt;std::endl; &#125; else &#123; std::cerr &lt;&lt; \"Data must refer to same ISBN\" return -1; &#125; return 0;&#125; 这个if语句的检测条件1item1.isbn() == item2.isbn() 调用名为isbn的成员函数。成员函数式定义为类的一部分函数，有时也被称为方法(method)。我们通常使用 点运算符(.)来调用方法。通常，此方法必须是当前类类型的。当我们访问一个成员函数时，通常我们是想调用该函数，我们使用调用运算符( () )来调用一个函数，调用运算符是一顿圆括号，里面放置参数列表(可能为空)。因为我们现在的成员函数 isbn并不接受参数，因此：1item1.isbn() 调用名为 item1 的对象的成员函数 isbn，此函数返回 item1 中保存的 ISBN书号。 自此下面的就不去写了， 感觉本书对此处写的像是磕磕绊绊，一些细节性的东西没有去发现， 可能不适合初学者读吧。初学者只想知道为什么运行不起来，不会去关心这些跑不起来的东西竟然还要写例子。 第二章 变量和基本类型数据类型是程序设计的基础，它告诉我们数据的意义以及我们能在数据上执行的操作 数据类型决定了程序中数据和操作的意义。如下所示的语句是一个简单示例： 1i = i + j; 其含义依赖于 i 和 j 的数据类型。 如果i j 是整形数，那么这条语句执行的就是最普通的加法运算。 基本内置类型C++定义了一套包括 算数尅性 和 空类型（void） 在内的基本数据类型。其中算术类型包含了 字符、整形数、布尔值、和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。例如最常见的是，如果函数不返回任何值的时候使用空类型作为返回类型。 算术类型算术类型分为两类： 整形（包括字符和布尔类型在内）和浮点型。算数类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别，所表示的范围也不一样。 布尔类型的取值是 真（true）/假（false）。 带符号类型和无符号类型 除去布尔型和扩展的字符型之外，其他整形可以划分为带符号的和无符号的两种。带符号类型可表示正数、负数或0，无符号的类型则仅能表示大禹等于0的值。 类型int、short、long、和long long 都是带符号的，通过在其前面加 unsigened就可以得到无符号类型。 Example： 1unsigened int 与其他整形不同，字符型被分为了三种： char、sigend char 和 unsigned char。尽管字符型有三种，但表现形式却只有两种，带符号的和无符号的。具体是哪种由编译器决定。 建议：如何选择类型 和C语言一样，C++的设计准则之一也是尽可能的接近硬件。C++的算数类型必须满足各种硬件特质。 - 当明确知道数值不可能为负时，选用无符号类型。 - 使用int执行整数运算。 - 执行浮点数运算选用double。 类型转换对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是讲对象从一种给定的类型转换为另一种相关类型。当我们像下面这样发吧一种算术类型的值付给另外一种类型时：123456bool b = 42; //bw为真int i = b; //i的值为1i = 3.14; //i的值为3double pi = i; //pi的值为3.0unsigend char c = -1; //假设char占8bytes c的值为255sigend char c2 = 256; //假设char占8bytes c2的值是未定义的。 类型所能表示的值的范围决定了转换的过程。 当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则为true。 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，否则为1. 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当我们把一个整数值赋给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的，此时，程序有可能继续工作，可能崩溃，也可能生成垃圾数据。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示树枝总数取模后的余数。 建议：避免无法预知和依赖于实现环境的行为。 无法预知的行为源于编译器无需检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。 不幸的是，在某些情况或某些编译器下，含有无法预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作。甚至已经编译通过的代码再次执行也可能会出错。 程序也应尽量避免依赖于实现环境的行为。 字面值常量一个形如42的值被称作字面值常量，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常来你的形式和值决定了他的数据类型。 整型和浮点型字面值我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或者0X开头的代表十六进制。 整型字面值具体的数据类型由它的值和符号决定，默认情况下，十进制字面值是带符号数，八进制和十六进制字面值极可能带符号也可能是无符号。浮点型字面值是一个double。 字符和字符串字面值由单引号括起来的一个字符成为char型字面值，双引号括起来的另个或多个字符则构成字符串型的字面值‘a’ – 字符型字面值“abc” – 字符串型字面值 转义序列有两类字符程序员不能直接使用，一类是 不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号，双引号，问号，反斜线）。在这些情况下需要用到\b转义序列，转义序列均以反斜线作为开始。 换行符 \\n 横向制表符 \\t 报警符 \\a纵向制表符 \\v 退格符 \\b 双引号 \\”反斜线 \\\\ 问号 \\? 单引号 \\’回车符 \\r 进纸符 \\f 在程序中，上述转义序列被当做一个字符使用。 布尔字面值和指针字面值true和false是布尔类型的字面值。bool test = false;nullptr 是指针字面值。 变量变量提供一个具体名字，可供程序操作的存储空间，c++中的每个变量都有其数据类型。数据类型决定着变量所占内存空间的大小和布局方式。该空间能存储的值的范围以及变量能参与的运算， 对C++程序员来说，“变量”和“对象”一般可以互换使用。 变量定义变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后1️以分号结束。列表中每个便来匿名的类型都由类型说明敷指定，定义时还可以为一个或多个变量赋初值。 1234int sum - 0, value // sum。value 都是int sum初值为0；Sales_item item; //item的类型是Sales_item。//string 是一种库类型，表示一个可变长的字符序列。std::string book (0-123-45678-X); 何为对象： C++程序员们在很多场合都会使用对象这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的空间。 一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象和未命名的对象区分开来，其中对象指能被程序修改的数据，而值指制度的数据。 初始值当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。用于初始化便拉近的值可以使任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用箱定义跌变量值去初始化后定义的其他变量。 Example:1234//用price的值初始化discountdouble price = 109.99, discount = price * 0.16;//调用函数applyDiscount并返回值用来初始化salePricedouble salePrice = applyDiscount(price, discount); 列表初始化C++定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为units_soid的int变量并初始化为0，以下的四条语句都可以做到：1234int units_soid = 0;int units_soid = &#123;0&#125;;int units_soid(0);int units_soid&#123;0&#125;; 作为C++新标准的一部分，永花括号来初始化变量得到了全面应用，在此之前仅在某些受限的场合下使用。这种初始化的形式被称为列表初始化。 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化切初始值存在丢失信息的风险，则编译器会报错：123long double id = 3.1415926536;int a&#123;id&#125;, b = &#123;id&#125;; // 错误：转换未执行，因为存在信息丢失的危险。int c(id), d = id; // 正确：转换执行，且确实丢失了部分值。 默认初始化如果定义变量时没有指定初始值。则变量就会被默认初始化，此时变量被赋予了‘默认值’，默认值到底是什么由变量类型决定。同时顶一边拉怪in的位置也会对此有影响。 如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0.一种例外情况是，定义在函数体内部的内置类型白能量将不被初始化。一个未被初始化的内置类型变量的值是未定义的。如果试图拷贝或以其他形式访问此类值将引发错误。 每个类格子决定其初始化对象的方式。而且，是否允许不精初始化就定义对象也由类型自己决定，如果类允许这种行为，它将决定对象的初始值到底是什么。 绝大多数类都至此无需显示初始化而定义对象，这样的类提供了一个合适的默认值。例如，string类规定如果没有指定初值则生成一个空串：12std::string empty; // 默认值为空 \"\"Sales_items item; // 被默认初始化的Sales_item对象。 一些类要求每个对象都显示初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示的初始化，则其值由类决定。 执行默认初始化时，内置类型的值是未定义的.这句话是有前提的，前提就是这个内置类型在哪申请的空间。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//,在静态存储区申请，所以初始化为0int a;//这个叫做值得初始化，3作为初始值int a_1 = 3;int main() &#123; //这个叫做有初始化值 int k = 5; //这个不是初始化，叫赋值 k = 8; //b也是内置类型，但是他在函数体申请，所以是在栈申请的空间，所以值未定义 int b; //new出来的空间都是在堆申请的，有操作系统自动分配可用空间，所以不会初始化 int *p = new int; //static申明的成员是存储在静态存储空间的，所以会初始化为0 static c; return 0;&#125; 提示：未初始化变量引发运行时故障。 未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的变成行为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告，但严格来说编译器并未被要求检查此类错误。使用未初始化的便拉近将带来无法预计的后果。有时我们足够幸运，一访问此类对象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没有初始化的问题。另外一些时候，程序会一直执行完并产生错误的结果。更\b糟糕的错误是，程序结果时对时错，无法把握。而且往无关的位置添加代码还会导致我们误以为程序对了，其实结果依旧有错。 梳理一下堆栈 定义： 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。 区别和联系： 申请方式 堆是由程序员自己申请并指明大小，在c中malloc函数 如p = (char *)malloc(10); 栈由系统自动分配，如声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 申请后系统的响应 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历改链表。寻找第一个空间大于所申请的堆节点，然后将该节点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放此内存空间。另外，由于找到的堆结点的大小不一定正海等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请大小的限制 栈：在win下，栈是像低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和站的最大容量是系统预先规定好的，在win下，栈的大小是2M，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获取的空间较小。 堆：堆是像高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不了徐的，而链表的遍历方向是由低到高地址。堆的大小受限于计算机系统中的有小雨你内存。所以堆的空间比较灵活，也比较大。 申请效率比较 栈：由系统自动分配，速度较快。但程序员无法控制。 堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。 变量声明和定义的关系为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。定义还会申请存储空间，也可能会为变量赋一个初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字 extern， 而且不要显式的初始化变量：12extern int i; //声明而非定义。int j; //声明并定义。 任何包含了显式初始化的声明即成为定义。我们能给出 extern 关键字标记的拜年啦给你赋一个初始值，但是这么做就抵消了extern的作用。 extern语句如果包含初始值就不再是声明，而变成定义了：1extern int i = 19; //定义。 在函数体内部，如果试图初始化一个由extern关键字修饰的变量，将引发错误。 变量能且只能被定义一次，但是可以被多次声明。 概念：静态类型 \b\bC++是一种静态类型语言，其含义是在编译节点检查类型。其中，检查类型的过程成为类型检查。我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。程序越复杂，静态类型检查越有助于发现问题，然而，前提是编译器必须知道每一个实体对象的类型。 标识符C++的标识符由字母、数字、下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写敏感。C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。 变量命名规范变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性： 标识符要能体现实际含义。 变啦滚名一般用小写字母，如index，不要使用Index或 INDEX。 用户自定义的类名一般以大写字母开头，如 Sale_item。 如果标识符由多个单词组成，则单词间应用明显区分。 名字的作用域不论是在圣墟的什么位置，使用到的每个名字都会执行一个特定的实体：变量、函数、类型等，同一个名字如果出现在程序的不同位置，也可以执行的是不同实体。 作用域是程序的\b一部分，在其中名字有其特定的含义。C++语言中大多数组用于都以花括号分离。同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 建议：当使用变量的时候再去定义 一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有利于更容易的找到便来那个的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。 嵌套的作用域作用域能彼此包含，被包含的作用域称为内层作用域，包含着别的作用域称为外部作用域。作用域中一旦声明了某个名字，它所嵌套的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：123456789101112131415161718192021/** *函数内部不宜定义与全局变量同名的新变量 */#include &lt;iostream&gt;//全局变量int reused = 42;int main(int argc, char *argv[])&#123; //块变量 int unique = 0; //输出 #1:使用全局变量reused std::cout &lt;&lt; reused &lt;&lt; \" \" &lt;&lt; unique &lt;&lt; std::endl; //覆盖全局变量reused int reused = 0; // 输出 #2:使用局部变量reused std::cout &lt;&lt; ::reused &lt;&lt; \" \" &lt;&lt; unique &lt;&lt; std::endl; //输出 #3:显式的访问全局变量reused， std::cout &lt;&lt; ::reused &lt;&lt; \" \" &lt;&lt;unique &lt;&lt; std::endl;&#125; 解释：输出#1：出现杂我jububianlaignreused定义之前，因此这条语句使用全局作用域中定义的名字reused，输出42 0.输出#2：发生咋已局部变量reused定义之后，此时局部变量reused正在作用域内，因此第二条输出语句使用的是局部变量reused而非全局变量，输出0 0.输出#3：使用域操作符 :: 来覆盖默认的作用域规则，因为全局作用域本身并没有名字，所以当作用域左侧为空时，向全局作用域发憷请求获取作用域\b操作符右侧名字对应的变量。结果是，第三条输出语句使用全局变量reused，输出42 0 建议 如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。 复合类型复合类型 是指基于其他类型定义的类型。C++语言有几种复合类型，下面介绍 引用和指针。与我们已经掌握的变量声明相比，定义复合类型的便拉近要复杂很多。之前 提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个基本数据类型和紧随其后的一个\b声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增了一种引用：所谓的“右值引用”，这种引用主要用于内置类。严格来说，当我们使用术语“引用”时，指的其实是“左值引用”。 引用 为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明写成 &amp;d 的形式来定义引用类型，其中d是声明的变量名。123int ival = 1024;int &amp;refival = ival; //refval指向ival（ival的另一个名字）int &amp;refval2; //报错：引用必须初始化 一般在初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时，程序会把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值对象一直绑顶在一起，因为无法令引用重新把那个顶到另外一个对象，因此引用必须初始化。 引用即别名 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 为引用赋值，实际上是把值付给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[]) &#123; int a = 10; int b = 20; int &amp;ra = a; ra= b; cout &lt;&lt; ra &lt;&lt; endl; // 输出10 cout &lt;&lt; a &lt;&lt; endl; // 输出20 return 0;&#125; 因为引用本身不是一个对象，所以不能定义引用的引用。 引用的定义允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：1234567int i = 1024, i2 = 2048; // 都是intint &amp;r = i, r2 = i2; // r是一个引用，与i绑在一起，r2是intint i3 = 1024m &amp;ri = i3; // i3是int，ri是一个引用，与i3绑定在一起int &amp;r3 = i3, &amp;r4 = i2; // r3和r4都是引用int &amp;refNum = 10; //错误//引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。 指针指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且咋指针的生命周期内它可以先后指向几个不同的对象。其二，指针无需在定义时赋初值。和其他内置类型一样，在快块作用域内定义的指针如果没有被初始化，也将又有一个不确定的值。 指针通常难以理解，即使有经验的程序员也常常因为调试指针引发的错误而烦恼 定义指针类型的方法将声明符写成 x(变量) 的形式。如果在一条语句中定义了几个指针变量，每个变量都要有 。12int *pi1, *pi2, *pi3; //都是指向int类型对象的指针。double *pd1, pd2; //pd1是指向double类型对象的指针 获取对象的地址指针存放某个对象的地址，要想获取该地址，需要使用取地址符(&amp;)12int ival = 42;int *pval = &amp;ival; //pval存放变量ival的地址，或者说pval是指向val变量的指针。 第二条语句吧pval定义为一个指向int的指针，随后初始化pval另其指向名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。和引用一样，指针只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。123456double dval;double *pd = &amp;dval; //正确：初始值是double型对象的地址。double *pd2 = pd; //正确：初始值是指向double对象的指针int *pi = pd; //错误：指针类型和pd类型不匹配pi = &amp;dval; //错误：视图把double型对象的地址赋给int型指针 因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。 指针值指针的值（即地址）应属于下列四中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值， 试图拷贝火以其他方式访问无效的指针豆浆引发错误。编译器并不负责检查此类错误。，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。 尽管第二种和第三种形式的指针是有效的，蛋其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。 利用指针访问对象如果指针指向了一个对象，则允许使用解引用符(*)来访问对象。123int ival - 42; int *p = &amp;ival; //p存放着变量ival的地址，或者说p是指向变量ival的指针cout &lt;&lt;*p&lt;&lt;endl; //由符号*得到指针p所指的对象，输出42。 对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。解引用操作仅适用于那些确实指向了某个对象的有效指针。 关键概念：某些符号有多重含义 像 &amp; * 这样的符号，技能用做表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的\u001b意义：12345int i = 42;int &amp;r = i; //&amp;紧随类型名出现，因此是声明的一部分，所以是引用int *p; //*紧随类型名出现，因此是声明的一部分，所以是指针p = &amp;i; //&amp;出现在表达式中，是一个取地址符int &amp;r2 = *p; //&amp;是声明的一部分，*是一个解引用符。 在声明语句中， &amp; 和 * 用于组成复合类型；在表达式中，他们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以吧它当做不同的符号来看待。 空指针空指针不指向任何对象，在\b试图使用一个指针之前，代码可以首先检查它是否为空，以下列出几个生成空指针的方法：123int *p1 = nullptr;int *p2 = 0;itn *p3 = NULL; 得到空指针最直接的办法就是采用字面值 nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。过去的程序还会用到一个名为NULL\b的预处理变量来给指针赋值，这个变量在头文件catdlib中定义，它的值就是0。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理白能量儿无需在前面加域操作符当用到一个预处理变量时，预处理器会自动的将它替换为实际值，因此用NULL初始化指针和0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同事尽量避免使用NULL。 把int变量直接赋给指针是错误的操作，即使int变量的值签好等于0也不行。12int zero = 0;ip = zero; 建议：初始化所有指针 使用未经初始化的指针是引发运行时错误的一大原因。和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置讲师特别棘手的问题。在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将会被看做一个地址值。访问该指针们相当于去访问一个本不存在位置上的本不存在的对象。如果指针所占内存空间中恰好有内容，而这些内容又恰好被当做了某个地址，我们就很难分清它是合法的还是非法的了。因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向他的指针，如果实在步行出指针应该指向何处，就初始化为nullptr，这样程序就能检测并知道它有没有指向任何具体的对象了。 赋值和指针指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非是一个对象。一旦定义了引用，就无法另其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：1234567int i = 42;int *pi = 0; //pi被初始化,没有指向任何对象int *pi2 = &amp;i; //pi2被初始化并指向了i的地址\b。int *pi3; //pi3被定义，但未被初始化，所以pi3的值不确定。pi3 = pi2; //pi3和pi2指向同一个对象ipi2 = 0; //pi2又被初始化，并\u001b不指向任何对象 其他指针操作只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算数值作为条件遵循的规则类似，如果指针的值是0\b；则条件取false。12345678910int ival = 1024; //int *pi = 0; // pi是一个空指针。int *pi2 = &amp;ival; // pi2存这ival的地址、if(pi)&#123; // pi的值是0，因此条件为false //...&#125;if(pi2)&#123; // pi2的值是1024，因此条件为true //...&#125; 结论：任何非0指针对应的条件都是true。对于两个类型的合法指针，可以用相等操作符(==)或不相等操作符(!=)来比较他们，比较的结果是布尔类型。如果两个指针村法规的地址值相同，则他们相等，反之则不等。这里两个指针存放的地址值相同(两个指针相等),有三种可能，它们都为空，都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。 void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*的指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：1double obj = 3.14, *pd = &amp;obj; 利用viod*指针能做的事情比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另一个void*指针。不能直接操作void*所指的对象，因为我们并不知道这个对象的类型，也就无法确定能在这个对象上进行什么操作。概括来讲，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。 理解复合类型的声明变量的定义包括一个基本数据类型和一组声明符。子啊同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是说，一条定义语句可能定义出不同类型的变量。12// i是一个int型的整数，p是一个int型的指针，r是一个int型的引用。int i = 1024, *p - &amp;i, &amp;r = i; 很多程序员迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分。 定义多个变量经常有一种观点会误以为，在定义语句中，类型修饰符(*或&amp;)作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间1int* p; // 合法但是容易产生误导。 我们说这种写法可能产生误导是因为int放在一起好像是这条语句中所有变量共同的类型一样，其实恰恰相反，基本数据类型是int而非int\\。 *仅仅是修饰了p而已，对该声明语句中的其它变量，它并不产生任何作用：12// p1是指向int类型的指针，p2是intint* p1, p2; 涉及指针或引用的声明，一般有两种写法，第一种把修饰符和变量标识符写在一起：1int *p1, *p2; // p1 和 p2都是指向int的指针。 这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名卸载一起，并且每条语句只定义一个变量。12int* p1; // p1 是指向int的指针。int* p2; // p2 是指向int的指针。 这种形式则强调了本次声明定义了一种复合类型。 上述两种定义指针或引用的不同方法没有对错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。 指向指针的指针一般来说，盛明富中修饰符的个数并没有显示。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再放到另一个指针中。 通过*的个数可以区分指针的级别，也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推。123int ival = 1024;int *pi = &amp;ival; // p1 指向一个int类型的数。int **ppi = &amp;p1; // p2 指向一个int类型的指针。 此处pi是指向int型数的指针，而ppi是指向int型指针的指针。解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的对象，需要对指针的指针 做两次解引用。 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。123456789101112131415161718int main(int argc, char *argv[]) &#123; int i = 42; // p是一个int型指针。 int *p; //r是对指针p的引用 int *&amp;r = p; // r 引用 i 的指针，因此给 r 赋值 &amp;i 就是令 p 指向 i r = &amp;i; //解引用 r 得到 i，也就是p指向的对象，将i的值改为0。 *r = 0; return 0;&#125; 要理解 r 的类型到底是什么，最简单的办法就是从右向左阅读 r 的定义。离变量名最近的符号 &amp; 对变量的类型有最直接的音箱，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号 * 说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个int指针。 const限定符有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定。 1const int bufSize = 512; // 输入缓冲区大小 这样就把bufSize定义成了一个常亮。任何试图为bufSize赋值的行为都将引发错误。1bufSize = 512; // 错误：试图像const对象写入。 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以使任意复杂的表达式。123const int i = getsize(); // 正确：运行时初始化。const int j = 42; // 正确：编译时初始化。const int k; // 错误：k是一个未经初始化的常量。 初始化和const正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是只能在const类型的对象上执行不改变其内容的操作。例如，const int 和普通的 int 一样都能参与算术运算，也都能转换成一个布尔值。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。123int i = 42;const int ci = i;int j = ci; 尽管ci是整型常量，但无论如何 ci 中的值还是一个整型数。ci 的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用 ci 去初始化j时，根本无需在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。 默认状态下，const对象仅在文件内有效当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：1const int bufSize = 512; // 输入缓冲区大小 编译器将在编译的过程中把用到该变量的地方都替换成相对应的值。也就是说，编译器会找到代码中所有用到 bufSize 的地方，然后用 512 替换。 为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问它的初始值才行，要做到这一点，就必须在每个用到变量的的文件中都有对它的定义。为了支持这一用法，同时避免对同一个变量的抽工夫定义，默认情况徐昂西啊，const对象被设定为仅在文件内有效。但你给多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他(非常量)一样工作。也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。 而解决方法非常简单，对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次。12345678910111213141516171819202122232425262728293031// FILE1: str.h#ifndef STR_H#define STR_H#include &lt;iostream&gt;// 在头文件中可以选择将其初始化。// extern const std::string str = \"AB\";// 也可以选择不初始化，到引用头文件的地方进行初始化。extern const std::string str;class str &#123;&#125;;#endif //STR_H// FILE2: str.cpp#include \"str.h\"extern const std::string str = \"ABCDE\";int main(int argc, char *argv[]) &#123; std::cout &lt;&lt; \"abc\"&lt;&lt; ceshi &lt;&lt; std::endl; // 输出字符为 AB std::cout &lt;&lt; \"abc\"&lt;&lt; ceshi &lt;&lt; std::endl; // 输出字符为 AB return 0;&#125; 因为str是一个常量，所以必须用 extern关键字修饰。 const的作用可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。1234const int c1 = 1024;const int &amp;r1 = c1 // 引用及其对应的对象都应该是常量r1 = 42; // 错误， r1是常量。int &amp;r2 = c1 // 错误，非常量不能引用常量。 因为不允许直接为c1赋值，当然也就不能通过引用取改变c1，因此，对r2的初始化是错误的。假设改初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。 const属性在C++中是内部链接属性。在其他文件访问无法访问到。12345678910FILE1:int a = 100;FILE2:extern int a;// 无法输出。链接时链接不到该属性。cout &lt;&lt; a &lt;&lt; endl;解决方法：在C++中，全局const变量没有隐式的加入extern关键字。只需要加入extern关键字即可。 C++程序员经常把词组 “对const的引用” 简称为 “常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记着这就是个简称而已。严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。 初始化和对const的引用上一节提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象，字面值，甚至是一个表达式。12345int i = 42;const int &amp;r1 = i; // 允许将const引用绑定到普通int对象上。const int &amp;r2 = 42; // 正确。r1是一个常量引用。const int &amp;r3 = r1 * 2; // 正确。r2是一个常量引用int &amp;r4 = r1 * 2; // 错误。r4是一个普通的非常量引用。非const引用的右值不能是表达式 要想理解这种例外情况的原因，最简单的办法就是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：12double dval = 3.14;const int &amp;ri = dval; 此处ri引用了一个int型的数，对ri的操作应该是整数运算，但dval却是一个双精度浮点而非整数。因此为了缺包让ri的绑定一个整数，编译器吧上述代码变成了如下形式：12const int temp = dval;const int &amp;ri = temp; 在这种情况下，ri做了一个临时量对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求职结果时，临时常见的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。 接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果\bri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时变量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变\bdval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。 对const的引用可能引用一个并非const的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许其他途径改变它的值。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; int i = 42; int &amp;r1 = i; // 引用r1 绑定对象i。 const int &amp;r2 = i; // 引用r2也绑定了对象i，但因为r2是const，所以不允许通过其修改i的值 std::cout &lt;&lt; r1 &lt;&lt; std::endl; std::cout &lt;&lt; r2 &lt;&lt; std::endl; // 通过更改源的方式来改变const引用的值 r1 = 0; // r1 不是常量，i的值被修改为0；// r2 = 0; // 错误：r2 是常量引用。 std::cout &lt;&lt; r1 &lt;&lt; std::endl; std::cout &lt;&lt; r2 &lt;&lt; std::endl; // const常量不能更改 r1 = 15; const int num = i;; std::cout &lt;&lt; num &lt;&lt; std::endl; // 输出15 i = 20; r1 = 20; std::cout &lt;&lt; num &lt;&lt; std::endl; // 输出15，const常量不可更改。 return 0;&#125; r2 绑定整数i是合法的，然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i复制，也可与通过像r1一样绑定到i的其他引用来修改。 指针和const与引用一样，也可以令指针指向常量或非常量。类似于常量引用。,指向敞亮的指针不能用不改变其所指对象打的值。要想存放敞亮的对象的地址，只能使用指向常量的指针：1234const double pi = 3.14; // pi是个常量，他的值不能改变。double *ptr = &amp;pi; // 错误：ptr是一个普通指针。const double *cptr = &amp;pi; // 正确：cptr可一直想一个双精度常量*cptr = 42; // 错误：不能给*cptr赋值。 2.3.2节提到，只针对的类型必须与其所指对象的类型一直，但是有两个例外、第一种类外情况是允许另一个纸箱厂凉的指针指向一个非常量对象：12double dval = 3.14; // dval是一个双精度浮点数，它的值可以改变。cptr = &amp;dval; // 正确：但是不能通过cptr改变dval的值。 和常量引用一样，指向敞亮的指针也没有规定其所指的对象必须是一个常量。所谓指向敞亮的指针仅仅要求不能通过该指针改变的对象的值，而没有规定那个对象的值不能通过其他途径改变。 试试这样想：所谓指向敞亮的指针或引用，不过是指针或引用“自以为是”罢了。它们觉得自己指向了常量，所以自觉地不去改变所指向对象的值。 const指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定位常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：1234int errNumb = 0;int*const curErr = &amp;errNumb // curErr将一直直系那个errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; // pip是一个指向常量对象的常量指针 如同2.3.2节所讲的，要想弄清楚这些生命的含义，最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是 const，意味着curErr 本身是一个常量对象，对象的了O型由声明福的其余部分决定。声明福中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型，例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般非常量整数，那么就完全可以用curErr去修改errNumb的值：123456*pip = 2.72； // 错误：pip是一个指向常量的指针if(*curErr)&#123; // 如果curErr所指的对象（也就是errNumb）的值不为0 errorHandler(); // *curErr = 0; // 正确：把curErr所指的对象的值重置&#125; 顶层const如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const表示指针本身是个常量，而用名词底层const表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。如算数类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。 123456int i = 0; int *const p1 = &amp;1; // 不能改变p1的值，这是一个顶层const。const int ci = 42; // 不能改变ci的值，这是一个顶层constconst int *p2 = &amp;ci // 允许改变p2的值，这是一个底层constconst int *const p3 = p2; // 不能修改p3的值，右边顶层const，左边是底层constconst int &amp;r = ci; // 用于声明引用的const都是底层const 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响：12i = ci; // 正确：拷贝ci的值，ci是一个顶层const，对此操作无影响p2 = p3; // 正确：p2和p3指向的对象类型相同，p3顶层const的部分不受影响 执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。 另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者来年各个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行：12345int *p = p3; // 错误，p3有const定义而p没有。p2 = p3; // 正确：p2和p3都是底层constp2 = &amp;1; // 正确，int*能转换成 const int*int &amp;r = ci; // 错误，普通的int&amp;不能绑定在int常量上const int &amp;r2 = 1; // 正确：const int&amp;可以绑定到一个普通int上。 p3即是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须说清楚它指向的对象得是一个常量。因此，不能用p3区初始化p，因为p指向的是一个普通的(非常量)整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针(顶层const)，仅就这次赋值而言不会有什么影响。 constexpr和常量表达式常量表达式是指值不会发生改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式。用常量表达式初始化的const对象也是常量表达式。后面将会提到。C++语言中有几种情况下是要用到常量表达式的。1234const int max_files = 20; //const int limit = max_files + 1; //int staff_size = 27; //const int sz = get_size(); // 尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const_int，所以他不属于常量表达式。另一方面，尽管sz本身是一个常量，但它的具体值知道运行时才能获取到，所以也不是常量表达式。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"C语言的文件操作","slug":"C语言的文件操作","date":"2018-05-28T12:50:08.471Z","updated":"2018-07-05T13:44:05.089Z","comments":true,"path":"2018/05/28/C语言的文件操作/","link":"","permalink":"http://gmle.github.io/2018/05/28/C语言的文件操作/","excerpt":"读写文件与printf、scanf关联printf : 将数据写出到屏幕 stdin 标准输入 –&gt; 0scanf : 从键盘获取用户数据 stdout 标准输出 –&gt; 1perror : 将错误信息写出到屏幕 stderr 标准错误 –&gt; 2","text":"读写文件与printf、scanf关联printf : 将数据写出到屏幕 stdin 标准输入 –&gt; 0scanf : 从键盘获取用户数据 stdout 标准输出 –&gt; 1perror : 将错误信息写出到屏幕 stderr 标准错误 –&gt; 2 系统文件： 标准输入、标准输出。标准错误。 会在程序加载到内存后运行时，由操作系统自动打开，自动关闭， 文件指针和普通指针的区别 定义文件指针12File *fp; // 一定是野指针。通过fopen将fp初始化为有效指针。 文件分类：设备文件= 屏幕、键盘等。 磁盘文件 各种文件 在计算机内数据以各种格式的文件存储。 文件操作 打开文件 fopen123456FILE *fopen( const char *filename, const char *mode );// 1、文件路径// 2、打开文件的方式 读/写// 返回值：执行成功打开的文件的 “文件指针”// 成功：指针。// 失败：NULL。 文件打开的方式r : 读文件，若文件存在，则返回成功指针；若文件不存在，报错。w : 写文件，若文件存在，则清空文件，若文件不存在，则创建文件a : 追加打开。r+: 读写方式打开文件，若文件存在，则返回成功指针；若文件不存在，报错。w+: 读写方式打开文件，若文件存在，则清空文件，若文件不存在，则创建文件a+: 追加打开。b : 表示打开的是一个二进制文件。 写方式打开文件：写方式打开文件： 对文件进行读写操作： 按字符读写文件：fputc(), fgetc(); 按行读写文件。 fgets(), fputs(); 找文件结束标记。（EOF） 12 关闭文件，123int fclose( FILE *stream );// 1、传入文件指针，fopen的指针值。// 返回值：success：0，failed：-1. 文件访问路径绝对路径 从系统根目录位置起始，描述的文件访问路径。 相对路径 相对于当前的工作目录。不纠结编译工具。 fputc1int fputs( const char *str, FILE *stream ); fgetc1int fputs( const char *str, FILE *stream ); Example12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main0201(int argc, char *argv[]) &#123; FILE *fp = fopen(\"abc.txt\",\"w\"); // 输出到文件26个字母。 for (int i = 65; i &lt; 91; i++) &#123; fputc(i, fp); &#125; fclose(fp); FILE *fp2 = fopen(\"abc.txt\",\"r\"); char c = 0; for (int j = 0; j &lt; 26; j++) &#123; c = (char) fgetc(fp2); printf(\"%c\",c); &#125; return 0;&#125; 文件结束标记：值为-1 feof函数 技能判断文本文件，也能判断二进制文件的结尾，-1也可以读出来。要使feof函数生效，必须在feof函数调用前进行读文件操作。 fgets 从文件中读取字符串数据，保存在存储空间中。 一次读一行，一行内默认\\n结束。会读取到\\n。 当char *str【n】空间不足，则预留\\0的位置，实际读到 n-1个字符。 12345char * fgets(char * str, int size, FILE * stream);// 1、存储读到的数据空间// 2、空间大小// 3、数据来源的文件。// 4、返回值：成功：读到的字符串/失败：NULL/读到文件末尾：NULL 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main0301 (int argc, char *argv[]) &#123; // 文件指针 FILE *fp = fopen(\"/Users/lele/Desktop/default.txt\", \"r\"); // 判空 if (!fp)&#123; perror(\"error\"); return -1; &#125; // 定义存储大小 int sizenum = sizeof(char)*4096; char *str = malloc((size_t) sizenum); // 字符串置空 memset(str, 0, sizenum); // 逐行打印文件内容 while (!feof(fp)) &#123; fgets(str, sizenum, fp); printf(\"%s\", str); &#125; // 释放并置空malloc的内存 free(str); str = NULL; fclose(fp); return 0;&#125; fputs 将一个字符串的数据写入到文件中， 12345char * fgets(char * str, int size, FILE * stream);// 1、存储读到的数据空间// 2、空间大小// 3、数据来源的文件。// 4、返回值：成功：读到的字符串/失败：NULL/读到文件末尾：NULL 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main0401(int argc, char *argv[]) &#123; FILE *fp = fopen(\"./hello.c\", \"w\"); if (!fp)&#123; perror(\"error\"); &#125; int sizenum = sizeof(char); char *buf = malloc((size_t) sizenum); while (1)&#123; memset(buf, 0, sizenum); scanf(\"%[^\\n]\", buf); getchar(); if (strcmp(buf, \":quit\") == 0)&#123; break; &#125; strcat(buf, \"\\n\"); fputs(buf, fp); &#125; free(buf); buf = NULL; fclose(fp); return 0; fprintfprintf sprintf fprintfscanf sscanf fscanf 键盘、屏幕 string file 共性：都有格式串“%d, %s, %c, %x…”，变参 1int fprintf( FILE *stream, const char *format, ... ); 参数一：待写入文件的指针 参数二：格式串 变参：对应格式串的数据 返回值： 成功：成功写入字符串的个数/失败：-1 fscanf1​int scanf( const char *format, ... );​ 参数一：待写入文件的指针 参数二：格式串 变参：对应格式串的数据 返回值： 成功：成功写入字符串的个数/失败：-1 特性：fscanf函数每次调用时，会判断下一次参数是否满足匹配条件，若不满足，提前返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/28. * FileName: 0x01_fscanf_sprintf.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;void random2file()&#123; srand(time(NULL)); FILE *fp = fopen(\"num.txt\", \"w\"); if (!fp) &#123; perror(\"fopen error\"); &#125; for (int i = 0; i &lt; 100; i++) &#123; fprintf(fp, \"%d\\n\", rand() % 100); &#125; fclose(fp);&#125;void BubbleSort(int *arr, int n)&#123; int tmp = 0; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (arr[j] &gt; arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125;&#125;void file2arr()&#123; int num = 0, i = 0; FILE *fp = fopen(\"num.txt\", \"r\"); if (!fp) &#123; perror(\"fopen error\"); &#125; int *arr = malloc(sizeof(int)*1024); while (1) &#123; fscanf(fp, \"%d\\n\", &amp;num); arr[i] = num; i++; if (feof(fp))&#123; break; &#125; &#125; printf(\"i = %d\\n\", i); BubbleSort(arr, i); fclose(fp); for (int j = 0; j &lt; i; j++) &#123; printf(\"%d\\n\", arr[j]); &#125; fp = fopen(\"num.txt\", \"w\"); for (int j = 0; j &lt; i; j++) &#123; fprintf(fp, \"%d\\n\", arr[j]); &#125; free(arr); arr = NULL; fclose(fp);&#125;int main(int argc, char *argv[]) &#123; random2file(); file2arr(); return 0;&#125; Windows二进制的读写 二进制读写的参数，只在Windows下用b权限，在linux下不需要。 freadfwrite12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;enum &#123; SIZE = 5&#125;;int main(int argc, char *argv[]) &#123; double a[SIZE] = &#123;1.21, 2.32, 3.23, 4.34, 5.45&#125;; FILE *fp = fopen(\"test.bin\", \"wb\"); // Write double array to file. fwrite(a, sizeof(*a), SIZE, fp); fclose(fp); // Read file double b[SIZE]; fp = fopen(\"test.bin\", \"rb\"); // Return success write to file's number size_t ret_code = fread(b, sizeof(*b), SIZE, fp); if (ret_code == SIZE) &#123; puts(\"Read successfully!, This array contents:\"); for (int i = 0; i &lt; SIZE; ++i) &#123; printf(\"%lf \", b[i]); &#125; putchar('\\n'); &#125; else &#123; // Error handling if (feof(fp)) printf(\"Error reading test.bin: unexpected end of file\\n\"); else if (ferror(fp)) &#123; perror(\"Error reading test.bin\"); &#125; &#125; return 0;&#125; 文件的随机读写fseek12fseek()int fseek(FILE *stream, long offset, int whence); 参数： 参数1：文件指针 参数2：偏移量（正、负)） 参数3：偏移的其实文职：SEEK_SET：文档开头SEEK_CUR：当前位置 seek_END：文件结尾 返回值： 成功：0 失败：-1 ftell 光标到文件开头的偏移量 1long ftell(FILE *stream) 返回值： 光标到文件开头的偏移量。 rewind 将光标移动至文件起始位置。 1void rewind(FILE *stream) 更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** * 按照字符读写文件 */static void test01() &#123; //写文件 FILE *fp = fopen(\"test\", \"w+\"); if (fp == NULL) &#123; return; &#125; char str[] = \"Test0101001\"; for (int i = 0; i &lt; strlen(str); i++) &#123; fputc(str[i], fp); &#125; fclose(fp); // 读文件 FILE *fp_r = fopen(\"test\", \"r\"); if (fp_r == NULL) &#123; return; &#125; int ch; while ((ch = fgetc(fp_r)) != EOF) &#123; printf(\"%c\", ch); &#125; fclose(fp_r);&#125;// 按照行读写文件static void test02() &#123; FILE *fp_w = fopen(\"test2\", \"w+\"); if (fp_w == NULL) &#123; return; &#125; char *buf[] = &#123; \"锄禾日当午\\n\", \"汗滴禾下土\\n\", \"谁知盘中餐\\n\", \"粒粒皆辛苦\\n\"&#125;; for (int i = 0; i &lt; 4; i++) &#123; fputs(buf[i], fp_w); &#125; fclose(fp_w); FILE *fp_r = fopen(\"test2\", \"r\"); if (fp_r == NULL) &#123; return; &#125; while (!feof(fp_r)) &#123; char buf2[1024] = &#123;0&#125;; fgets(buf2, 1024, fp_r); printf(\"%s\", buf2); &#125; fclose(fp_r);&#125;typedef struct _HERO &#123; char name[64]; int age;&#125; Hero;// 按照块读写文件static void test03() &#123; FILE *fp_w = fopen(\"test03\", \"wb\"); if (fp_w == NULL) &#123; perror(\"Failed\"); return; &#125; Hero hero[] = &#123; &#123;\"a\", 10&#125;, &#123;\"b\", 20&#125;, &#123;\"c\", 34&#125;, &#123;\"d\", 55&#125; &#125;; int heroLen = (int) (sizeof(hero) / sizeof(hero[0])); for (int i = 0; i &lt; heroLen; i++) &#123; fwrite(&amp;hero[i], sizeof(Hero), 1, fp_w); &#125; fclose(fp_w); FILE *fp_r = fopen(\"test03\", \"rb\"); if (fp_r == NULL) &#123; perror(\"Failed\"); return; &#125; Hero tmp[4]; for (int i = 0; i &lt; 4; i++) &#123; fread(&amp;tmp[i], sizeof(Hero), 1, fp_r); printf(\"%s, %d\\n\", tmp[i].name, tmp[i].age); &#125; fclose(fp_w);&#125;// 利用格式化读写static void test04() &#123; FILE *f_write = fopen(\"./test04\", \"w\"); if (f_write == NULL) &#123; return; &#125; fprintf(f_write, \"hello world %d年 %d月 %d日\", 2018, 7, 5); fclose(f_write); FILE *f_read = fopen(\"./test04\", \"r\"); if (f_read == NULL) &#123; return; &#125; char buf[1024] = &#123;0&#125;; while (!feof(f_read)) &#123; fscanf(f_read, \"%s\", buf); printf(\"%s\\n\", buf); &#125; fclose(f_read);&#125;int main03(int argc, char *argv[]) &#123;// test01();// test02();// test03(); test04(); return 0;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的结构体","slug":"C语言的结构体","date":"2018-05-28T00:27:22.648Z","updated":"2018-05-28T00:27:22.648Z","comments":true,"path":"2018/05/28/C语言的结构体/","link":"","permalink":"http://gmle.github.io/2018/05/28/C语言的结构体/","excerpt":"结构体定义 结构体：通常定义为全局位置，放在.h头文件中 成员变量不允许赋初始值。 结构体仅是一个数据类型。","text":"结构体定义 结构体：通常定义为全局位置，放在.h头文件中 成员变量不允许赋初始值。 结构体仅是一个数据类型。 结构体变量定义及初始化普通变量初始化指针变量初始化1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct student&#123; int age; char name[10]; int num;&#125;;int main(int argc, char *argv[]) &#123; // 定义时初始化 struct student stu = &#123;19, \"lele\", 123&#125;; // 普通变量初始化 struct student stu2; stu2.age = 10; strcpy(stu2.name, \"andy\"); stu2.num = 1234; // 用指针初始化 struct student *p_sut = &amp;stu; p_sut-&gt;num = 20; strcpy(p_sut-&gt;name, \"andy\"); p_sut-&gt;age = 30; printf(\"st2 age = %d, st2 name = %s, st2 num = %d.\\n\", stu2.age, stu2.name, stu2.num); return 0; 非常规定义方法访问结构体成员的方法普通变量 使用. 访问 使用&amp;(obj)-&gt;age = 1234;指针变量 使用-&gt;访问指针不能是野指针(未赋初值的)结构体的数组成员，如果没有在定义时初始化，那么后期赋值，只能用strcpy,strncpy,memcpy 结构体数组123456789int arr[10] = &#123;1,2,3,4,5&#125;char arr[5];struct studennt arr[5] = &#123; &#123;10, \"andy\", 10&#125;, &#123;11, \"bndy\", 11&#125;, &#123;12, \"cndy\", 12&#125;, &#123;13, \"dndy\", 13&#125;, &#123;14, \"endy\", 14&#125;&#125; 结构体数组的初始化批量初始化1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct student&#123; int age; char name[20]; int num;&#125;;int main(int argc, char *argv[]) &#123;// struct student stu = &#123;stu.age = 10&#125;;// printf(\"age = = = = =%d\\n\", stu.age); struct student stuarr[5] = &#123; &#123;22, \"aaa\", 001&#125;, &#123;23, \"bbb\", 002&#125;, &#123;21, \"ccc\", 003&#125;, &#123;25, \"ddd\", 004&#125;, &#123;24, \"eee\", 005&#125; &#125;; int sizearr = sizeof(stuarr)/sizeof(stuarr[0]); int avgAge = 0; for (int i = 0; i &lt; sizearr; i++) &#123; avgAge+=stuarr[i].age; printf(\"%d \", stuarr[i].age); &#125; puts(\"\"); printf(\"avgAge = %d\", avgAge/sizearr); return 0;&#125; 逐个初始化12345678910111213141516171819202122stuarr[0].age = 19;strcpy(stuarr[0].name, \"1111\");stuarr[0].num = 19;(*(stuarr+1)).age = 191;strcpy((*(stuarr + 1)).name, \"2222\");(*(stuarr + 1)).num = 192;(stuarr + 2)-&gt;age = 193;strcpy((stuarr + 2)-&gt;name, \"333\");(stuarr + 2)-&gt;num = 192;struct student *p = stuarr;(*(p + 3)).age = 194;strcpy((*(p + 3)).name, \"444\");(*(p + 3)).num = 192;(p + 4)-&gt;age = 196;strcpy((p + 4)-&gt;name, \"444\");(p + 4)-&gt;num = 192; 结构体嵌套12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct peaple&#123; char name[100]; int age;&#125;;struct student&#123; struct peaple pp; int score;&#125;;int main0301(int argc, char *argv[]) &#123; struct student *stu = NULL; stu = malloc(sizeof(struct student)); strcpy(stu-&gt;pp.name, \"hello\"); stu-&gt;score = 100; printf(\"stu.pp.name = %s\\n stu.pp.age = %d\\n stu.score = %d\\n\", stu-&gt;pp.name, stu-&gt;pp.age, stu-&gt;score); return 0;&#125; 结构体内的数组成员，如果没有在定义时初始化，那么后期赋值，只能使用strcpy,strncpy,memcpy。 同类型结构体变量赋值 要求被赋值的结构体变量和源结构体变量成员的类型、个数、顺序必须严格一致。 结构体做函数参数传值 在函数内部赋值，只可以修改结构体形参，无法改变外部变量。 传址 在函数挖爱步赋值，可以借助地址修改函数以外的变量值。 好处：节省栈的空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/24. * FileName: 0x04_jiehoutihavepoint.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct student &#123; int age; char *name; int num;&#125;;// 结构体外部初始化函数 **p == &amp;pvoid init_stu(struct student **p) &#123; // *p == p的内容 == NULL。 *p = malloc(sizeof(struct student)); if (*p == NULL) printf(\"Malloc Error!\"); // *p malloc 赋值为堆空间的地址 (*p)-&gt;age = 199; (*p)-&gt;name = malloc(sizeof(char) * 20); /** * 不允许直接赋值，直接赋值会出现如下问题： * 0x008_day09(92229,0x7fffb2197380) malloc: *** error for object 0x10d67ef8c: pointer being freed was not allocated * *** set a breakpoint in malloc_error_break to debug */ // (*p)-&gt;name = \"hello\"; strcpy((*p)-&gt;name, \"hello\"); (*p)-&gt;num = 29;&#125;int main0401(int argc, char *argv[]) &#123; // 定义结构体指针 struct student *p = NULL; // *p = null, &amp;p = 在栈中的0xxxxxxx 地址 init_stu(&amp;p); // p 为struct student * 类型，是指针类型。所以 p是地址。 printf(\"age = %d\\nname = %s\\nnum = %d\\n\", p-&gt;age, p-&gt;name, p-&gt;num); free(p-&gt;name); free(p); return 0;&#125; 含有指针成员的结构体 见上例。12345struct student&#123; int age = 10; char *name; int num;&#125;; 联合体和共用体12345union test&#123; char a; short b; int c;&#125;; 所有联合体成员公用一片地址空间 修改任意一个成员变量，其他成员都会发生变化 整个联合体大小为最大成员变量的大小。 枚举 枚举常量默认从0开始计数，后一个元素的值是前一个元素的值+1，也可任意指定一个元素的初值。123456789101112131415// 默认值enum num&#123; a, // 0 b, // 1 c, // 2 d // 3&#125;;enum color&#123; red = 0010, yellow = 0020, pink = 0030, green = 0040,&#125;; typedef 给类型起别名 1typedef int a_t; 给较长的变量起一个别名，便于使用。 大多用于结构体。 便于结构体的定义和理解。 便于代码的修改和维护。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;// 加上typedef使其定义自定义变量的时候更简单。typedef struct student&#123; int age; char name[20]; int num;&#125; stu;int main(int argc, char *argv[]) &#123; stu s1 = &#123;0, \"\", 0&#125;; return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的内存管理","slug":"C语言的内存管理","date":"2018-05-23T11:13:52.754Z","updated":"2018-05-23T11:13:52.754Z","comments":true,"path":"2018/05/23/C语言的内存管理/","link":"","permalink":"http://gmle.github.io/2018/05/23/C语言的内存管理/","excerpt":"C语言的内存管理：理论居多，有助于理解理论。","text":"C语言的内存管理：理论居多，有助于理解理论。 局部变量 局部变量就是定义在函数内部的变量。 作用域 从定义位置开始，到包裹该变量的第一个右大大括号结束。 生命周期 等同于作用域 auto auto 关键字用来修饰局部变量。通常可以省略。 12auto int a = 10;int a = 10; 全局变量 定义在函数外部的变量 如果全局变量和局部变量重名，采用就近原则。 作用域 从定义位置开始，到当前文件结束。 可以再本项目的其他文件中，通过‘声明’的方式导出该变量打的作用域。 如果全局变量和static局部变量重名，采用就近原则 生命周期 从程序创建开始，到程序终止结束。 static局部变量 static局部变量：加了static关键字，定义在函数内部的变量 static局部变量只能定义一次并且不能跟随函数的的调用儿产生。只随程序的创建而产生。 生命周期 从程序创建开始，到程序终止结束。 static全局变量 static全局变量：加了static关键字，定义在函数外部的变量 作用域 从定义位置开始，到当前文件结束。即使使用声明也不能导出作用域，相当于static全局变量限定在了本文件内。 生命周期 从程序创建开始，到程序终止结束。 全局函数 默认定义的所有函数都是全局函数。 作用域 从定义位置开始，到当前文件结束。 在调用之前，没有函数定义时没需要使用声明向编译器做注册。 生命周期- static全局函数 限定在了文件内部。即使通过生命呢也不能导出作用域。 总结： static对于变量、全局函数起限定作用域的作用。被限定在定义的文件内。 变量内存存储data区 初始化为非0的全局变量 和 初始化为非0的static变量 bss区 初始化为、未初始化的全局变量、static变量。 rodata 常量 代码区(text区) 程序内容 代码片段 函数定义 变量定义 数据区(rodata|bss|data) data:初始化为非-的全局变量和static变量 bss：未初始化和初始化未0的全局变量、static变量。程序编译成功，加载执行时该数据区会被自动置0。 rodata：常量 stack(栈) 普通局部变量，默认大小：Windows：1-10M/ Linux:8-16M 存放位置：栈帧，为函数运行提供空间。 heap(堆) 用户自定义申请的内存空间。大小 ：1G+ 堆空间的使用 malloc 申请堆空间 123// 参数：要申请的空间大小。void *malloc(size_t size);// 返回值，成功申请的空间的首地址。失败返回NULL。 申请的空间是一片连续的地址空间。 几乎每次都将这片空间当成数组使用。 free 释放堆空间 123// 参数：malloc申请的首地址。void *malloc(size_t size);// 返回值，成功 的空间呢的首地址。失败返回NULL。 错误应用12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; int *p = malloc(0); p[0] = 10; p[1] = 11; p[2] = 'c'; p[3] = 'd'; printf(\"%d\\n\", *p); printf(\"%d\\n\", p[0]); printf(\"%d\\n\", p[1]); printf(\"%d\\n\", p[2]); printf(\"%d\\n\", p[3]); printf(\"%d\\n\", p[4]); free(p); printf(\"free\"); return 0;&#125; 二级指针对应的堆空间申请 先申请外层指针，再循环申请内层指针。 释放 先释放内层内存，再释放外层内存。12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main0201(int argc, char *argv[]) &#123; // 申请一个二维指针// int **p = (int **)malloc(sizeof(int *) * 4); // 不能忘掉int * int **p = malloc(sizeof(int *) * 4); // 二维指针对应空间的申请 for (int i = 0; i &lt; 4; i++) &#123; p[i] = malloc(sizeof(int) * 4); &#125; // 二维指针对应一个二维数组，填满二维数组。 for (int j = 0; j &lt; 4; j++) &#123; for (int i = 0; i &lt; 4; i++) &#123; p[i][j] = j+i; &#125; &#125; // 打印二维数组 for (int k = 0; k &lt; 4 ; k++) &#123; for (int i = 0; i &lt; 4; i++) &#123; printf(\"%d \", p[k][i]); &#125; puts(\"\"); &#125; // 释放内层内存。 for (int l = 0; l &lt; 4; l++) &#123; free(p[l]); &#125; // 释放外层内存。 free(p); return 0;&#125; 栈空间的存储特性局部变量内存分配 地址从高到低 不连续分配，先进后出，后进先出。 形参内存分配 压栈顺序：从右向左 int abc(int a, int b, int c) 从右向左 地址从高到低 连续分配内存 申请内存的两种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/23. * FileName: 0x03_main_mem.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;// 传二级指针void malloc_mem1(int **p) &#123; *p = (int *) malloc(199); printf(\"mem1_malloc = %p\\n\", *p);&#125;// 返回指针接收void *malloc_mem2(int *p) &#123; p = malloc(199); printf(\"mem1_malloc = %p\\n\", p); return p;&#125;int main(int argc, char *argv[]) &#123; int *p = NULL; // malloc_mem1(&amp;p); // printf(\"p = %p\\n\", p); // 接收初始化完成后返回的地址。 p = malloc_mem2(p); printf(\"p = %p\\n\", p); free(p); return 0;&#125; 内存操作函数 头文件为string.h memset 将指定的你内存空间存入指定值。通常用来置零 123456void *memset(void *s, int c, size_t n);// - 1&gt;待设置的内存地址// - 2&gt;要设置的值，通常为0// - 3&gt;大小:单位字节// 返回值：成功置零的首地址(传入的地址) 123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; int *p = malloc(sizeof(int) * 10); printf(\"%d\\n\", *p); // 将申请来的内存置空。 memset(p, 0, 10); printf(\"%d\\n\", *p); return 0;&#125; memcpy 内存拷贝。 123456void* memcpy( void *dest, const void *src, size_t count );// - 1：目标位置// - 2：源位置// - 3：字节个数// 返回值：dest的地址 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(int argc, char *argv[]) &#123; int arr1[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int arr2[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; memcpy(arr1, arr2, sizeof(int)*5); for (int i = 0; i &lt; 10; i++) &#123; printf(\"%d\", arr1[i]); &#125; return 0;&#125; memmove 类似memcpy 123456void* memmove( void *dest, const void *src, size_t count );// - 1：目标位置// - 2：源位置// - 3：字节个数// 返回值：dest的地址 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main0601(int argc, char *argv[]) &#123; int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; memmove(arr, (arr+1), sizeof(int)*5); for (int i = 0; i &lt; 10; i++) &#123; printf(\"%d\", arr[i]); &#125; return 0;&#125; memcmp 比较内存单元。相同：return 0,对应位上的 1&gt;2 则return 1，否则 return -1. 1234int memcmp(const void *s1, const void *s2, size_t n)// 地址1// 地址2// 比较的字节 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(int argc, char *argv[]) &#123; int arr1[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int arr2[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; if (memcmp(arr1, arr2, sizeof(int)*5) == 0)&#123; printf(\"等\"); &#125; return 0;&#125; 内存应用细节： 可以申请大小为0字节的空间，并且可以对返回的地址空间做free操作。 要么不做解引用，直接free。 要么不free，可以解引用，但无意义。 开辟多大空间，使用多大空间，不要越界访问。 free释放的地址，不是malloc的返回值，通常是由于做了++操作。 在malloc的时候，定义临时变量存储返回值。 free后的地址 通常置NULL。 非空地址，不可以反复free ， NULL 反复free多次不会出错。 在子函数内部，给main中为NULL的指针初始化。 main中的NULL指针，值传递给子函数并malloc申请空间，初始化是失败的。 main中的NULL指针，将地址传递给子函数并malloc申请空间你则初始化成功。 main中的NULl指针，借助子函数的返回值初始化malloc的堆空间。","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的灵魂--指针","slug":"C语言的指针","date":"2018-05-22T14:18:52.783Z","updated":"2018-05-22T14:18:52.783Z","comments":true,"path":"2018/05/22/C语言的指针/","link":"","permalink":"http://gmle.github.io/2018/05/22/C语言的指针/","excerpt":"指针 指针就是内存地址。","text":"指针 指针就是内存地址。 内存地址：内存最小存储单元 –&gt; “内存单元” 大小为一个字节 每一个内存单元都有唯一的一个编号此编号就是内存地址 指针的定义和使用 指针类型：基础数据类型 int *a; *p含义 将p变量的内容取出当成地址看待，找到该地址。 如果*p在左侧，则指代该空间； 如果在等号右侧，则取出该变量值。12345678910111213141516int main0301(int argc, char *argv[]) &#123; int a = 10; // 定义一个int类型的变量a赋值为10 int *p = &amp;a; // 定义一个int*类型的变量p赋值为a的地址 /** * 重要解释： * p是 int*类型的变量，存放的是地址。 * *p是int*类型p的解引用，即：**p，*p为地址， * 则**p为解引用，所以 下面的*p是int类型的变量，所以可以赋值 */ *p = 122; return 0;&#125; 野指针 定义但未指定有效地址的指针。 空指针 在指针刚刚定义的时候，指针为NULL。 在明确指针变量不再使用的地方，手动置空。 泛型指针void* 泛型指针可以接受任意数据类型的地址。泛型指针不可以直接解引用读取数据，必须强转为具体数据类型。 12345678910111213#include&lt;stdio.h&gt;int main0101(int argc, char *argv[]) &#123; void *p = NULL; // 泛型指针 int a = 10; p = &amp;a; printf(\"%d\\n\", *(int *)p); return 0;&#125; const修饰指针变量 const右边，限制到谁，谁将不可改变。通常用于函数形参修饰，限制参数不可改变。 const int p; p可以改变，p不可改变。 int const p; p可以改变，p不可改变。 int const p; p不可改变，p可以改变。 const int *const p 都不可改变。 Mac电脑下并不可以，编译器不同引起的一些异同。12345678910111213141516171819202122232425262728293031323334353637/** * const变量可以通过指针修改。 * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123; const int a = 10;// a = 20; // wwindows 下可以改， const int *p1;// p1 = &amp;a;// *p1 = 20;// printf(\"%d\", *p1); int const *p2 = &amp;a; const int *const p3;// 3. int *const p; int *const p; p = &amp;a; *p = 234;// 4. const int *const p;// const int *const p;// system(\"pause\");// p = &amp;a;// *p = 234; return 0;&#125; 指针和数组 数组名是地址常量。不能被赋值。但可以赋值给指针变量。 123int arr[] = &#123;1,2,3,4&#125;int *p = arr;p[i] = arr[i] = *(arr+i) = *(p+i) 指针和数组名的区别 指针是变量，数组名是常量。 sizeof(p)获取的是指针大小，sizeof(arr)，是数组大小。 直接使用指针操作数组 p会随着读取数据元素不断变化，结束时变成一个野指针。 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; int arrLengh = sizeof(arr) / sizeof(arr[0]); int *p = arr; for (int i = 0; i &lt; arrLengh; i++) &#123; printf(\"%d \", *(p + i)); &#125; printf(\"\\n************************************\\n\"); /** * 循环结束后，p将变为一个野指针 */ for (int j = 0; j &lt; arrLengh; j++) &#123; printf(\"%d \", *p++ );// p++; &#125; printf(\"\\n************************************\\n\"); int *p2 = &amp;arr[5]; // int *p = arr == &amp;arr[0] printf(\"p[-2] = %d\\n\", p2[-2]); printf(\"*(p-2) = %d\\n\", *(p2-2)); printf(\"*(p-2) = %d\\n\", *(p2+2)); return 0;&#125; 指针的算术运算 指针对 * / % 运算无意义。 指针+-整数普通变量 +1是加的一个sizeof(指针数据类型)的的大小。 // 此处是数据类型大小，非指针类型大小！ 12345678910111213int main(int argc, char *argv[]) &#123; int a = 0x12345678; // 普通指针变量+-整数 short *p = &amp;a; printf(\"p = %p\\n\", p); printf(\"p+1 = %p\\n\", p+1); // sizeof(short) * 1 = 2 printf(\"p-1 = %p\\n\", p-2); // sizeof(short) * 2 = 4 // +1是加的一个sizeof(指针数据类型)的的大小。 // 此处是数据类型大小，非指针类型大小！ return 0;&#125; 数组 由于数组中的数组元素是连续存储， 所以可以使用指针+-整数操作取出元素。 1234567891011int main(int argc, char *argv[]) &#123; int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *p = &amp;arr[5]; printf(\"p = %p, p-1=%p\\n\", p, p - 1); // 向前偏移 4 字节 printf(\"*p = %d, *(p-1)=%d\\n\", *p, *(p - 1)); system(\"pause\"); return EXIT_SUCCESS;&#125; 指针+-指针指针+指针 不允许的操作。指针-指针普通变量指针 语法允许，但无实际意义。数组变量指针 结果为数组的偏移量/sizeof(数组的类型) 1234567891011121314151617181920212223242526int main(int argc, char *argv[]) &#123; int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *p = arr; // 首元素地址 printf(\"p = %p\\n\", p); // 首元素地址 printf(\"arr = %p\\n\", arr); // 整个数组的地址。 printf(\"&amp;arr = %p\\n\", &amp;arr); // printf(\"p+1 = %p\\n\", p + 1); // +4 // printf(\"arr+1 = %p\\n\", arr + 1); // +4 // 数组地址取地址 = 整个数组的地址，但是地址值还是首元素的地址。 printf(\"&amp;arr+1 = %p\\n\", &amp;arr + 1); // +40 一个数组的大小。 system(\"pause\"); return EXIT_SUCCESS;&#125; 指针比较运算 可以在指针之间比较地址值。1234567if (p == NULL)&#123; ...&#125;if (p != NULL)&#123; ...&#125; 指针数组 一个数组，数组内部元素为指针。 指针数组表现形式可以是一个二级指针/二维数组、 12345678910111213141516171819#include&lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int a = 10; int b = 20; int c = 30; int *arr[] = &#123;&amp;a, &amp;b, &amp;c&#125;; int n = sizeof(arr) / sizeof(arr[0]); for (size_t i = 0; i &lt; n; i++) &#123; printf(\"%d\\n\", *(arr[i])); // *(*(arr+i)) &#125; return 0;&#125; 二级指针和多级指针123int a = 10;int *p = &amp;a;int **pp = &amp;p; 指针和函数指针作为函数参数传值 在函数调用期间，实参将自己的值拷贝一份给形参。传址 赞函数滴啊用期间，实参将自己的地址值拷贝给形参。 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;/** * 不会交换变量 * @param a * @param b */void swap(int a, int b)&#123; int tmp = 0; tmp = a; a = b; b = tmp;&#125;/** * 会交换变量，传的是个指针，修改的原始值。 * @param a * @param b */void swap2(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;int main(int argc, char *argv[]) &#123; int a = 10, b = 20; swap2(&amp;a, &amp;b); printf(\"%d\", a); return 0;&#125; 函数封装 在封装含有数组作为参数的函数时，一般封装至少两个参数: 一个表示数组首地址， 一个表示数组元素个数。1234567891011121314151617181920212223242526272829303132333435363738394041void bubbleSort(int *arr, int arrLengh)&#123; int tmp = 0; for (int i = 0; i &lt; arrLengh - 1; i++) &#123; for (int j = 0; j &lt; arrLengh - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125;&#125;int main0701(int argc, char *argv[]) &#123; int arr[] = &#123; 1, 44, 22, 12, 43, 55, 63, 90, 87, 74, 123, 4566, 2, 4, 6 &#125;; int arrLengh = sizeof(arr)/ sizeof(arr[0]); printf(\"%d \\n\", arrLengh); bubbleSort(arr, sizeof(arr)/ sizeof(arr[0])); for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++) &#123; printf(\"%d \", arr[i]); &#125; return 0;&#125; 指针作为函数的返回值 不能返回局部变量的地址. 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;/** * 指针在返回后，一定要接收，不然栈帧销毁后将没有值。 * @param a * @param b * @return */int *sum(const int *a, const int *b)&#123; // 相加本就是int类型，为什么还要强转。// return (int *) (*a + *b); int tmp = 0; int *p_tmp = (int *) (*a + *b); // tmp是int*类型。 return p_tmp;&#125;int main(void) &#123; int a = 10; int b = 10; int suma = (int) sum(&amp;a, &amp;b); printf(\"%d\", suma); return 0;&#125; 指针和字符串1234567// 定义数组char str1 - &#123;'h', 'e', 'l', 'l', 'o'&#125;char str2[] = \"hello\"// 定义在栈上 str1 == str2;char *str3 = \"hello\"// 存储在ro(read only)data上 -&gt; 不能修改：相同的字符串常量在rodata上只存储一份 int 和 char 作为函数参数的区别： 字符串含有\\0结束标记，不需要辅助参数 整形数组作为函数参数，由于调用传递的是地址值，因此需要元素个数的参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include &lt;string.h&gt;/** * 去除空格。 * @param str */void noSpace(const char *str) &#123; int i = 0; char tmp[100] = &#123;0&#125;; while (*str) &#123; if (*str != ' ') &#123; tmp[i] = *str; i++; &#125; str++; &#125; printf(\"%s\\n\", tmp);&#125;/** * 实现strstr，查找子串 * @param src * @param sub * @return */char *strr(char *src, char *sub) &#123; // 记录原位置 char *_src = src; // 记录子字符串位置 char *_sub = sub; // 记录回滚位置。 char *_tmp = src; while (*_src) &#123; // 回滚位置 _tmp = _src; while (*_src == *_sub &amp;&amp; *_sub != '\\0') &#123; // 出现相等字符，继续向下比较 _src++; _sub++; &#125; if (*_sub == '\\0') &#123; // 子串读取完成，即 已经包含子串，返回src串的地址。 return _tmp; &#125; // 不满足条件，回滚至相等的字符串的下一个位置。 _src = _tmp; _sub = sub; _src++; &#125; return NULL;&#125;/** * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123; char str[] = \"i fjiodsj faios jfiasd jaisgoa if spofnaos\"; // noSpace(str); printf(\"%s\", strr(str, \"fi\")); return 0;&#125; 带参数的main函数main函数 无参数 123int main(void) &#123; return 0;&#125; 有参数 123int main(int argc, char *argv[]) &#123; return 0;&#125; 字符串操作函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/20. * FileName: 0x02_charReverse.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;/** * 字符串倒置 * @param str */void strReverse(char *str) &#123; char *start = str; char *end = str + strlen(str) - 1; char tmp = 0; while (start &lt; end) &#123; tmp = *start; *start = *end; *end = tmp; start++; end--; &#125; printf(\"%s\", str);&#125;/** * 是否为回文字符串 ：abcdcba * @param str * @return */int isBack(char *str) &#123; char *start = str; char *end = str + strlen(str) - 1; while (start &lt; end) &#123; if (*start != *end) return 0; start++; end--; &#125;// printf(\"%s\", str); return 1;&#125;int main(int argc, char *argv[]) &#123; char str[] = \"abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba\"; char str2[] = \"aab\"; printf(\"%d\", isBack(str2));// strReverse(str); return 0;&#125; 字符串拷贝strcpy 字符串拷贝,若空间不足，会发生数据溢出。 strncpy 字符串拷贝,拷贝n个字节，拷贝中需要预留 \\0的位置 1234567891011121314151617181920212223242526int main(int argc, char *argv[]) &#123; char src[] = \"fdfhelfjljkljke\"; char dest[10] = &#123;0&#125;; char *p = strcpy(dest, src); printf(\"dest = %s\\n\", dest); printf(\"p = %s\\n\", p); return 0;&#125;int main(int argc, char *argv[]) &#123; char src[] = \"hello world\"; char dest[100] = &#123;0&#125;; char *p = strncpy(dest, src, 99); printf(\"dest = %s\\n\", dest); printf(\"p = %s\\n\", p); return 0;&#125; 字符串拼接strcat 字符串拼接，自动添加 \\0 strncat 字符串拼接，拼接位n个字节。自动添加 \\0 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main0401(int argc, char *argv[]) &#123; char src[] = \"hello\"; char dest[100] = \"world\"; printf(\"%s\\n\", strcat(dest, src)); return 0;&#125;int main0402(int argc, char *argv[]) &#123; char src[] = \"hello\"; char dest[100] = \"world\"; char *p = strncat(dest, src, 8); printf(\"%s\\n\", p); return 0;&#125; 字符串比较strcmp 比较字符串，如果相同，返回0，不同则按位比较ASCII码 若大则返回1，小则返-1 strncmp 比较前n个字符串，如果相同，返回0，不同则按位比较ASCII码 若大则返回1，小则返-1 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main0901(void) &#123; char str1[] = \"hello world\"; char str2[] = \"hello z\"; int ret = strcmp(str1, str2); printf(\"ret = %d\\n\", ret); return 0;&#125;int main0902(void) &#123; char str1[] = \"hello world\"; char str2[] = \"hello worlD\"; int ret = strncmp(str1, str2, 5); printf(\"ret = %d\\n\", ret); return 0;&#125; 字符串打印sprintf 按格式匹配符匹配对应数据输出到字符数组中。 1234int sprintf( char *buffer, const char *format, ... );(until C99)int sprintf( char *restrict buffer, const char *restrict format, ... );(since C99) sscanf 从指定字符串中获取指定数据。以空格和\\n为分隔依据，即终止。可以使用正则表达式。 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; char str[100]; sprintf(str, \"%d + %d = %d\", 1, 2, 1 + 2); puts(str); printf(\"%s\\n\", str); return 0;&#125; 字符串查找strchr 在字符串中，自左向右查找指定字符的函数。 12345678910111213#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void) &#123; char str[] = \"helfjwoefjidjfle\"; char ch = 'e'; char *p = strrchr(str, 'l'); printf(\"p = %s\\n\", p); return 0;&#125; 字符串拆分strtok 返回值为按分隔符分割后的第一个子串。拆分多个字串 分隔符如果有多个，则罗列到条件参数中。 第一次调用时，参数1传递待分割的字符串，循环调用的时候传NULL值。123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main0801(void) &#123; char *str = \"aaa...bb.dsaf.asdf\"; char *p = strtok(str, \".\"); printf(\"p = %s\\n\", p); for (size_t i = 0; i &lt; 14; i++) &#123; printf(\"%c\", str[i]); &#125; printf(\"\\n\"); return 0;&#125;int main0802(void) &#123; char str[] = \"sadn. ksdljf&amp;$jlasdf asdojf\"; char *p = strtok(str, \".$ \"); while (p != NULL) &#123; printf(\"%s\\n\", p); p = strtok(NULL, \".$ \"); &#125; return 0;&#125; 字符串转换atoi、atof、atol 自动忽略空格。可以识别负号。 从左向右判断，遇到非数字类型的则直接返回。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main0901(void) &#123; char str1[] = \" -10\"; int num1 = atoi(str1); printf(\"num1 = %d\\n\", num1); char str2[] = \"0.123\"; double num2 = atof(str2); printf(\"num2 = %.2f\\n\", num2); char str3[] = \"123L\"; long num3 = atol(str3); printf(\"num3 = %ld\\n\", num3); return EXIT_SUCCESS;&#125;int main(void) &#123; char str1[] = \"12abc10\"; int num1 = atoi(str1); printf(\"num1 = %d\\n\", num1); printf(\"------%p\\n\", main0901); return EXIT_SUCCESS;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言字符串输入输出的几个函数","slug":"C语言中关于字符串的几个函数","date":"2018-05-17T13:21:24.837Z","updated":"2018-07-03T11:59:47.782Z","comments":true,"path":"2018/05/17/C语言中关于字符串的几个函数/","link":"","permalink":"http://gmle.github.io/2018/05/17/C语言中关于字符串的几个函数/","excerpt":"C语言中有几个字符串输入输出的函数很重要。","text":"C语言中有几个字符串输入输出的函数很重要。 gets：键盘 -&gt; 标准输入 – stdin 以 ‘\\n’ 作为从stdin读取字符串的结束标记 不读取 ‘\\n’, 不以空格为结束标记 若字符串的输入大于字符串定义的空间大小，则会出现运行时异常：数组溢出. puts 不安全的(暂不讨论) 输出到屏幕 – 标准输出 – stdout 将字符串写出到stdout 自动添加换行符 \\n 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/17. * FileName: 0x01_gets_puts.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char arr[] = &#123;0&#125;; int arrlengh = sizeof(arr) / sizeof(arr[0]); printf(\"%d\", arr[0]); printf(\"%d\\n\", arrlengh); printf(\"%p\\n\", &amp;arr); printf(\"%u\", (unsigned int) sizeof(arr));// strcpy(arr, 'a'); arr[0] = 'a'; gets(arr); printf(\"!@#!!!!!!!!!!!!!\\n\"); printf(\"%u\\n\", (unsigned int) sizeof(arr)); printf(\"!@#!!!!!!!!!!!!!\\n\"); puts(arr+2); strcpy(arr, \"asdf\"); puts(arr); return 0;&#125; 在使用gets的过程中出现了一个很有意思的问题。12// 将如上代码的char数组值置空即可得到如下说明的情况。char arr[] = &#123;&#125;; 此语句既没有赋初始值，也没有设定长度/大小.但竟然可以编译通过，但在运行后会报错。不过在IDE下没有办法显示错误。12345678910$ ./a.out010x7ffeed6b3a5fwarning: this program uses gets(), which is unsafe.1nuiuhn!@#!!!!!!!!!!!!!1!@#!!!!!!!!!!!!!iuhn[1] 54873 abort ./a.out 说明一下我的环境：123456789$ gcc -vConfigured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1Apple LLVM version 9.1.0 (clang-902.0.39.1)Target: x86_64-apple-darwin17.5.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/binIDE:Jetbrans Clion fgetsfgets(str, sizeof(str), stdin)1: 数组 2。大小。3：读入源。 以 ‘\\n’ 作为从stdin读取字符串的结束标记 输入完毕后自动添加’\\n’ 当空间不足时，自动给读取的字符串添加’\\0’的字符串结束标记，但字符串会因此不完整。 当空间足够时，会在读取的字符串再添加’\\n’的结束标记。 在内存中的存储：“hello\\n\\0” 以\\0为结束标记，所以会将 \\0放在最后。 fputs 安全的(暂不讨论) int fputs(const char str, FILE stream) 1:写出的字符串。2：输出目标 不自动添加换行符 \\n 12345678910111213int main(int argc, char *argv[]) &#123; char arr[] = &#123;0&#125;; fgets(arr, 100, stdin); // 数组，大小，标准输入(键盘) fputs(arr, stdout); // 数组，标准输出(屏幕) return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言中的函数","slug":"C语言的函数","date":"2018-05-17T13:08:01.370Z","updated":"2018-05-17T13:08:01.370Z","comments":true,"path":"2018/05/17/C语言的函数/","link":"","permalink":"http://gmle.github.io/2018/05/17/C语言的函数/","excerpt":"C语言中的函数：每时每刻都在用到，只要你写C。","text":"C语言中的函数：每时每刻都在用到，只要你写C。 函数： 完成某一特定功能的代码片段。 封装函数的目的：代码复用，使代码简洁。 函数分类： 系统库函数 自定义函数 函数的定义和使用：函数定义(函数原型/接口)： C语言中，一个函数有且只有一次返回值类型： 返回给调用者的数据类型 void表示无返回函数名： 见名知意。推荐用英文名次。形参列表： 形式参数列表：包含类型名，形参名，可有多个。 函数体： 若函数有返回值，函数中必须有return关键词并有实际返回。 函数声明： C语言中，有 0-n次。 响编译器注册该函数。 使用场景：在函数调用之前没有函数定义时，需要声明。 函数调用： 使用该函数实现对应的功能。 需匹配形参列表，与形参类型严格匹配。 若函数无返回值，则参数不写。 1234567891011121314151617181920212223242526272829303132/** * 函数引用 - 无返回值 * @param a * @param b */void printMax(int a, int b) ;/** * 函数引用 - 有返回值 * @param a * @param b * @return */int add(const int *a, const int *b) ;int main(int argc, char *argv[]) &#123; int a = 19, b = 21; int sum = add(&amp;a, &amp;b); printf(\"sum = %d\\n\", sum); printMax(a, b); return 0;&#125;void printMax(int a, int b) &#123; printf(\"Max = %d \\n\", a &gt; b ? a : b);&#125;int add(const int *a, const int *b) &#123; return *a + *b;&#125; exit()函数： 退出当前程序。 exit如果包含在main函数中使用，与return作用相同，但不建议使用。 return：返回当前函数条用。 多文件编译 一个main函数，其他源文件都是功能函数。 文件1：12345678910111213141516/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/17. * FileName: sorts.h. *///***** Code is coming! *****//#ifndef INC_0X005_DAY05_SORTS_H#define INC_0X005_DAY05_SORTS_Hint bubbleSort(int arr[]);#endif //INC_0X005_DAY05_SORTS_H 文件2：1234567891011121314151617181920212223242526272829/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/17. * FileName: bubbleSort.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;void bubbleSort(int arr[10])&#123; // int lengh = sizeof(arr) / sizeof(arr[0]); int tmp = 0; for (int i = 0; i &lt; lengh - 1; i++) &#123; for (int j = 0; j &lt;= 10 - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; for (int k = 0; k &lt; 10; k++) &#123; printf(\"%d \", arr[k]); &#125;&#125; 文件3：123456789101112131415161718192021222324252627/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/17. * FileName: main.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include \"includes/sorts.h\"int main001(int argc, char *argv[]) &#123; int arr[10] = &#123;3, 6, 78, 9, 64, 12, 34, 87, 55, 1&#125;; int lengh = sizeof(arr) / sizeof(arr[0]); printf(\"%d\\n\", lengh); bubbleSort(arr[10]); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的数组","slug":"C语言的数组","date":"2018-05-15T12:26:40.990Z","updated":"2018-05-15T12:26:40.991Z","comments":true,"path":"2018/05/15/C语言的数组/","link":"","permalink":"http://gmle.github.io/2018/05/15/C语言的数组/","excerpt":"数组定义 定义：数组就是在内存中连续的相同类型的变量空间。 数组创建在栈上。 数组的下标从0开始。 数组类型 数组名[数组大小];","text":"数组定义 定义：数组就是在内存中连续的相同类型的变量空间。 数组创建在栈上。 数组的下标从0开始。 数组类型 数组名[数组大小]; 求数组的元素个数 1int num = sizeof(arr)/sizeof(arr[0]); 一维数组1234567891011121314151617181920212223242526/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/15. * FileName: 0x01_array.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;int main(int argc, char *argv[]) &#123; int arr[] = &#123;1,2,3,4,5&#125;; int arr[5] = &#123;1,2,3,4,5&#125;; int arr[5] = &#123;1,2,3&#125;; int arr[5; int arr[5 = &#123;0&#125;; // 将数组的所有元素全部初始化为0. int arr[10]; // 随机显示各个值 return 0;&#125; C语言的数组首地址和第一个元素的地址相同 一维数组练习练习1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/15. * FileName: 0x01_array.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;/** * 数组倒置打印 * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123; int arr[] = &#123;3, 4, 1, 2, 6, 8, 9, 5&#125;; // 数组大小 int num = sizeof(arr) / sizeof(arr[0]); printf(\"%d \\n\", num); // 大小下标与临时变量。 int index_min = 0; int index_max = num - 1; int tmp = 0; while (index_min &lt; index_max) &#123; printf(\"arrmin = %d---\", arr[index_min]); printf(\"arrmax = %d\\n\", arr[index_max]); tmp = arr[index_min]; arr[index_min] = arr[index_max]; arr[index_max] = tmp; index_min++; index_max--; &#125; for (int i = 0; i &lt; num; i++) &#123; printf(\"%d \", arr[i]); &#125; return 0;&#125; 练习2：12345678910111213141516171819202122/** * 十只猪称体重 * @param argc * @param argv * @return */int main(int argc, char *argv[]) &#123; int arr[] = &#123;123, 213, 333, 412, 234, 452, 112, 341, 122, 142&#125;; int num = sizeof(arr) / sizeof(arr[0]); int weight = 0, pigx = 0; for (int i = 0; i &lt; num; i++) &#123; if (weight &lt; arr[i]) &#123; weight = arr[i]; pigx = i; &#125; &#125; printf(\"第%d只小猪重量：%d\", pigx + 1, weight); return 0;&#125; 冒泡排序123456789101112131415161718192021222324252627282930313233343536/** * 冒泡排序 * @param argc * @param argv * @return */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;int main(int argc, char *argv[]) &#123; int arr[] = &#123;3, 6, 78, 9, 64, 12, 34, 87, 55, 1&#125;; int lengh = sizeof(arr) / sizeof(arr[0]); int tmp = 0; for (int i = 0; i &lt; lengh - 1; i++) &#123; for (int j = 0; j &lt;= lengh - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; for (int k = 0; k &lt; lengh; k++) &#123; printf(\"%d \", arr[k]); &#125; return 0;&#125; 二维数组二维数组的使用： 数组类型 数组名称 [行数] [列数] int arr[] = {{1, 2, 3, 4},{5, 6, 7, 8}} 常用定义地址二维数组的首地址与首行元素的地址与首个元素的地址相同。 123printf(\"%p\\n\",arr)printf(\"%p\\n\",arr[0])printf(\"%p\\n\",arr[0][0]) 二维数组的大小1printf(\"%u\\n\",sizeof(arr)); 二维数组的行数二维数组的列数二维数组元素的个数123456789101112131415161718192021222324252627282930313233/** * * @param argc * @param argv * @return */int main0301(int argc, char *argv[]) &#123; int arr[2][5] = &#123;&#123;1, 2, 3, 4, 5&#125;, &#123;6, 7, 8, 9, 0&#125;&#125;; // 地址 printf(\"%p\\n\", arr); printf(\"%p\\n\", arr[0]); printf(\"%p\\n\", &amp;arr[0][0]); // 大小 printf(\"数组大小：%u\\n\", (unsigned int) sizeof(arr)); // 元素个数 printf(\"数组行数：%u\\n\", (unsigned int) (sizeof(arr) / sizeof(arr[0]))); printf(\"数组列数：%u\\n\", (unsigned int) (sizeof(arr[0]) / sizeof(arr[0][0]))); printf(\"元素个数：%u\\n\", (unsigned int) (sizeof(arr) / sizeof(arr[0][0]))); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; printf(\"%d\\t\", arr[i][j]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 练习：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 学生成绩 * @param argc * @param argv * @return */int main0302(int argc, char *argv[]) &#123;/**12 23 24 5612 42 45 3233 22 11 4212 54 12 53*/ int score[4][4] = &#123;0&#125;; int row = sizeof(score) / sizeof(score[0]); int col = sizeof(score[0]) / sizeof(score[0][0]); for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; scanf(\"%d\", &amp;score[i][j]); &#125; &#125; printf(\"************************************\\n\"); for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; printf(\"%d\\t\", score[i][j]); &#125; printf(\"\\n\"); &#125; printf(\"************************************\\n\"); for (int i = 0; i &lt; row; i++) &#123; int sum = 0; for (int j = 0; j &lt; col; j++) &#123; sum += score[i][j];// printf(\"第%d个学生的成绩为%d\", i, sum); &#125; printf(\"第%d个学生的成绩为%d\\n\", i, sum); &#125; printf(\"************************************\\n\"); for (int k = 0; k &lt; col; k++) &#123; int sum = 0; for (int i = 0; i &lt; row; i++) &#123; sum += score[i][k]; &#125; printf(\"第%d门学科的总成绩为%d\\n\", k + 1, sum); &#125; return 0;&#125; 三维数组数组的首地址 = 数组首层的地址 = 数组的首层首行的地址 = 数组的首层首行首列的地址。arr = arr[0] = arr[0][0] = arr[0][0][0] 字符数组 一系列连续的字符集合，没有 \\0结束标记。含有结束标记的，称之为 字符串。 字符串字符串长度strlen() 获取字符串的字符个数，不包含`\\0` scanf 添加正则12scanf(\"%[.*]s\", &amp;str)scanf(\"%[^\\n]s\", &amp;str) // 获取带有空格的字符串 C语言中 数组中的数值必须为常量，不能为变量。 ```cchar str[] = helloworld;scanf(“%s”, &amp;str);/** 最后的 \\0 无法存储。*/","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的运算符","slug":"C语言的运算符","date":"2018-05-15T11:16:43.424Z","updated":"2018-05-15T11:16:43.424Z","comments":true,"path":"2018/05/15/C语言的运算符/","link":"","permalink":"http://gmle.github.io/2018/05/15/C语言的运算符/","excerpt":"小知识随机数：1234// 放入随机数种子，若无则随机数将只有一个值srand(time(NULL));// 限定随机数范围int num = rand() % 100;","text":"小知识随机数：1234// 放入随机数种子，若无则随机数将只有一个值srand(time(NULL));// 限定随机数范围int num = rand() % 100; 运算符： 除法：不能除0 取模：不能对小数取余。 自增自减a++ = a = a + 1 前自增/减,先+1，再取值 后自增/减,先取值，再+1 运算符优先级 后缀运算符比前缀运算符优先级高。 三目运算符 格式： a&gt;b?a:b 成立则a，不成立则b 逗号运算符： 逗号运算符的结果是表达式最后一个值 123456789101112131415161718192021222324252627282930313233343536373839/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/12. * FileName: 0x05_yunsuanfu.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main02(int argc, char *argv[]) &#123; int a = 10; int b = 5; printf(\"%d-%d=%d \\n\",a, b, a - b); printf(\"%d+%d=%d \\n\",a, b, a + b); printf(\"%d*%d=%d \\n\",a, b, a * b); printf(\"%d/%d=%d \\n\",a, b, a / b); printf(\"%d%%%d=%d \\n\",a, b, a % b); printf(\"a++=%d \\n\",a++); printf(\"a--=%d \\n\",++a); printf(\"a--=%d \\n\",a--); printf(\"--a=%d \\n\",--a); printf(\"a+=a=%d \\n\",a+=a); printf(\"a-=a=%d \\n\",a-=a); printf(\"%d \\n\",a!=b); printf(\"%d \\n\",a=b); return EXIT_SUCCESS; &#125; 类型转换 隐式类型转换 自动转换，小类型转大类型 char/short -&gt; signed int -&gt; unsigned int -&gt; long -&gt; double &lt;- short 强制类型转换 int a = 10 (double)a = 10; 变量或表达式都可强制转换。 123456789101112131415161718192021222324252627282930/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/14. * FileName: 0x04_qiangzhuan.c. *///***** Code is coming! *****//#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;int main04(int argc, char *argv[]) &#123; // 做一个隐式类型转换。 int a = 10.123; // 写一个强制类型转换转换变量 int b = 10.123; printf(\"%lf\", (double) b); // 写一个强制类型转换转换表达式 printf(\"%lf\", (double) b * a); return 0;&#125; if条件判断语句123456789101112131415161718192021222324252627/** * 猜数字大小 * @return */int main() &#123; int value; srand(time(NULL)); int num = rand() % 100; for (;;) &#123; printf(\"请输入猜测的数字：\"); scanf(\"%d\", &amp;value); if (num &lt; value) &#123; printf(\"大大大大大大大大大大大大了\\n\"); &#125; else if (num &gt; value) &#123; printf(\"小小小小小小小小小小小小了\\n\"); &#125; else &#123; printf(\"猜对对对对对对对对对对对了\\n\"); break; &#125; &#125; return EXIT_SUCCESS;&#125; 宏定义的三目运算符： #define MAX(m,n) (m)(n)?(m):(n) breakbreak是一个关键字 1、跳出循环（for、while、do..while） 2、switch分支 case 中使用。 continue结束当前循环，只应用在循环语句中12345678910111213int main(int argc, char *argv[]) &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 1)&#123; continue; &#125; printf(\"%d \\n\", i); &#125; return 0;&#125; switch 只能精确匹配，无法匹配范围 比if效率高 每一个case分支都必须有一个break，否则会发生case穿透 case穿透：执行完当前case之后若无break将继续向下执行下一个case中的语句。 while break,一次跳一层循环123while(1 == i)&#123; // 将值放在前面是为了防止少写一个等号 ...&#125; do while 先执行一次，再看表达式12345do&#123; &#125; while()&#123;&#125; for 嵌套外循环一次，内循环一整个条件 12345678910111213141516171819202122232425262728293031/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/12. * FileName: 0x02_for.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/** * 九九乘法表 * 嵌套循环 * @param argc * @param argv * @return */int main02(int argc, char *argv[]) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; int s = i * j; printf(\"%d*%d=%2d\\t \", i, j, s); &#125; printf(\"\\n\"); &#125; return EXIT_SUCCESS;&#125; goto跳转至自定义标签处。使用dowhile替代goto12345// 代替方法：do&#123; if（） break；&#125; while (0);","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"Shell的加减乘除操作","slug":"Shell中的加减乘除","date":"2018-05-15T03:06:09.818Z","updated":"2018-05-15T03:06:09.818Z","comments":true,"path":"2018/05/15/Shell中的加减乘除/","link":"","permalink":"http://gmle.github.io/2018/05/15/Shell中的加减乘除/","excerpt":"写了这么长时间的Shell竟然不知道乘除怎么写。。。","text":"写了这么长时间的Shell竟然不知道乘除怎么写。。。 表达式1234((i=$j+$k)) i=`expr $j + $k`((i=$j-$k)) i=`expr $j -$k`((i=$j*$k)) i=`expr $j \\*$k`((i=$j/$k)) i=`expr $j /$k` let Let expressions 执行一个或多个表达式。表达式中的变量前不必有$. 如果表达式中包含了空格或其他特殊字符，则必须引起来。 123let “I = I + 1”let i=i+1 算术运算算术运算符指的是可以在程序中实现加、减、乘、除等数学运算的运算符。Shell中常用的数学运算符如下所示。 — +：对两个变量做加法。 — -：对两个变量做减法。 — *：对两个变量做乘法。 — /：对两个变量做除法。 — **：对两个变量做幂运算。 — %：取模运算，第一个变量除以第二个变量求余数。 — +=：加等于，在自身基础上加第二个变量。 — -=：减等于，在第一个变量的基础上减去第二个变量。 — *=：乘等于，在第一个变量的基础上乘以第二个变量。 — /=：除等于，在第一个变量的基础上除以第二个变量。 — %=：取模赋值，第一个变量对第二个变量取模运算，再赋值给第一个变量。 在使用这些运算符时，需要注意到运算顺序的问题。例如输入下面的命令，输出1+2的结果。 1echo 1+2 Shell并没有输出结果3，而是输出了1+2。在shell中有三种方法可以更改运算顺序。 用expr改变运算顺序。可以用echo expr 1 +2来输出1+2的结果，用expr表示后面的表达式为一个数学运算。需要注意的是，`并不是一个单引号，而是“Tab”键上面的那个符号。 用let指示数学运算。可以先将运算的结果赋值给变量b，运算命令是b=let 1 + 2。然后用echo$b来输出b的值。如果没有let，则会输出1+2。 用$[]表示数学运算。将一个数学运算写到$[]符号的中括号中，中括号中的内容将先进行数学运算。例如命令echo$[1+2]，将输出结果3。 下面是一个shell程序实例，实现数学函数S=3(xy)+4x2+5y+6的运算。在程序中以位置变量的方式输入x与y的值。程序的编写步骤如下所示。 123456789101112131415161718192021222324252627#!/bin/bash#4.4.shs=0 #定义一个求和变量，初值为0。t=`expr$1**$2` #用expr改变运算顺序，求x的y次方。t=$[t*3] #t乘以3。s=$[s+t] #结果相加。t=$[$1**2] #求x的平方。t=$[t*4] #结果乘以4。s=$[s+t] #结果相加。t=`expr$2*5` #求5y的值。s=$[s+t] #结果相加。s=$[s+6] #结果加上6。echo$s #输出结果。echo$((a%b)) #取余 在这个程序中，需要注意算术运算的写法。如果没有expr或$[]更改运算顺序，则会将运算式以字符串的形式赋值，而不会赋值运算结果。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gmle.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gmle.github.io/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"http://gmle.github.io/tags/Linux/"}]},{"title":"C语言字符串与处理","slug":"C语言的字符串&输入输出","date":"2018-05-14T10:18:32.325Z","updated":"2018-05-14T12:14:05.573Z","comments":true,"path":"2018/05/14/C语言的字符串&输入输出/","link":"","permalink":"http://gmle.github.io/2018/05/14/C语言的字符串&输入输出/","excerpt":"C语言中，字符串的处理尤为重要。 字符串 printf函数，在打印字符串的时候，遇见’\\0’就停止打印，否则继续打印。","text":"C语言中，字符串的处理尤为重要。 字符串 printf函数，在打印字符串的时候，遇见’\\0’就停止打印，否则继续打印。 1char str[11] = \"Hello\"; //'H', 'e', 'l', 'l', 'o', '\\0'; 格式化输出 %m,n 用于小数，m为输出的总位数(包括小数部分，整数部分，小数点)。 n为输出的小数的位数。 ‘%’字符在转义的时候用%本身。 putchar 向标准输出设备输出一个字符。输出方式：借助ASCII输出 scanf 当scanf 函数使用%s 获取字符串的时候，空格和\\n是scanf判断终止的依据 %Ns, 获取N个字符 getchar 从标准输入设备获取用户输入的一个字符，返回该字符的ASCII码 char ch = getchar() getchar()可以造成进程停止，等待用户输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/14. * FileName: 0x06_str.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; // 定义一个char数组，内容为“Hello World” char ch[] = \"Hello World\"; // 打印数组中的所有内容 printf(\"%s\\n\", ch); // // 打印15个字符，向左填充空格 printf(\"%15s\\n\", ch); // // 打印15个字符，向右填充空格 printf(\"%-15s\\n\", ch); // // 打印15个字符，向左填充0 printf(\"%015s\\n\", ch); // // 打印15个字符，向右填充0 printf(\"%-015s\\n\", ch); // // 定义一个float浮点类型的数字 值等于'12.34568' float fl = 12.34568; // 打印上面的数字并保留三位小数。 printf(\"%.3f \\n\", fl); // 打印上面的数字并保留共三位数。 printf(\"%3f \\n\", fl); // 添加百分号并输出此数字。 printf(\"%f%% \\n\", fl); // 定义一个字符，值为'A' char c = 'A'; putchar(c); // 使用putchar函数输出任意字符 putchar('a'); // 使用putchar输出一个ASCII码并记录结果 putchar(97); // 从键盘获取用户输入。 // 输入并打印一个int类型的变量。 int in = 0; scanf(\"%d\", &amp;in); // 输入并打印一个char类型的变量。 scanf(\"%c\", &amp;c); // 获取多个字符并打印多个字符。 scanf(\"%c%c%c\", &amp;c, &amp;c, &amp;c); // 获取一个字符串 // 打印字符串 putchar('A'); // 隐式类型转换。 char --&gt; int putchar(100); // 使用getchar获取字符并用putchar打印 c = (char) getchar(); char a, b; scanf(\"%c%c\", &amp;a, &amp;b); printf(\"a = %c \\n\", a); printf(\"b = %c \\n\", b); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"C语言的数据类型与存储","slug":"C语言的常量与变量","date":"2018-05-12T02:22:26.829Z","updated":"2018-05-12T12:08:33.218Z","comments":true,"path":"2018/05/12/C语言的常量与变量/","link":"","permalink":"http://gmle.github.io/2018/05/12/C语言的常量与变量/","excerpt":"常量 const：限定一个变量为只读变量，不建议使用，因为其可以用其他方式修改。 #define：定义一个宏常量。用法：#define PI=3.1415 匿名常量：常量字符、字符串。 例：“aaa” ‘a’","text":"常量 const：限定一个变量为只读变量，不建议使用，因为其可以用其他方式修改。 #define：定义一个宏常量。用法：#define PI=3.1415 匿名常量：常量字符、字符串。 例：“aaa” ‘a’ 变量 变量的三要素： 定义变量必须要变量类型、变量名、变量值。 变量定义 -&gt; 给变量在内存中开辟存储空间 变量声明 -&gt; 不会给变量开辟存储空间。但会向系统注册该变量。 编译器 -&gt; 在编译至变量赋值处，发现该变量尚未被定义，会自动寻找变量声明冰将该声明提升为定义。 标识符：常量和变量的统称。 不能使用C语言中所有的内定关键字、函数等。 只能有数字、字母、下划线组成。 不能以数字开头。 大小写严格区分。 整型 int %d 占位：4字节 short %hd 占位：2字节 long %ld 占位：4/8字节(不同平台中大小不一 windows/unix/linux/macOS) long long %lld 占位：4字节 无符号整型 unsigned int %d 占位：4字节 unsigned short %hd 占位：2字节 unsigned long %ld 占位：4/8字节(不同平台中大小不一 windows/unix/linux/macOS) unsigned long long %lld 占位：4字节 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/12. * FileName: 0x05_printf.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;int main05(int argc, char *argv[]) &#123; // 此关键词 signed 可忽略 signed int a = -10; signed short b = -20; signed long c = 30; signed long long d = 40;// unsigned int e = -10; unsigned int e = 10; unsigned short f = 20; unsigned long g = 30; unsigned long long h = 40; double x = 10.12; float y = 10.222f; float z = 10.2223; char ch = 'b'; printf(\"********** 有符号类型 **********\\n\"); printf(\"%d \\n\", a); printf(\"%hd \\n\", b); printf(\"%ld \\n\", c); printf(\"%lld \\n\", d); printf(\"********** 无符号类型 **********\\n\"); printf(\"%u \\n\", e); printf(\"%hd \\n\", f); printf(\"%ld \\n\", g); printf(\"%lld \\n\", h); printf(\"********** 实型变量 **********\\n\"); printf(\"%lf \\n\", x); printf(\"%f \\n\", y); printf(\"%f \\n\", z); printf(\"%c \\n\", ch);&#125; sizeof() sizeof(变量名) sizeof(a); sizeof(类型名) sizeof(char); sizeof 变量名 语法支持，但不推荐使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/12. * FileName: 0x02_sizeof.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;int main02 (int argc, char *argv[])&#123; int a = 10; short b = 20; long c = 30; long long d = 40; printf(\"int a = %d \\n\", a); printf(\"short b = %d \\n\", b); printf(\"long c = %li \\n\", c); printf(\"long long d = %lli \\n\", d); printf(\"****************************************\\n\"); printf(\"sizeof(int) = %zu \\n\", sizeof(int)); printf(\"sizeof(short) = %zu \\n\", sizeof(short)); printf(\"sizeof(long) = %zu \\n\", sizeof(long)); printf(\"sizeof(long long) = %zu \\n\", sizeof(long long)); printf(\"****************************************\\n\"); int e; printf(\"%d \\n\", e); const int len = e; e = 30; printf(\"%d \\n\", len); return 0;&#125; char类型Char类型是字符型，占位一个字节。长度为 -128 ~ 127 ‘0’ : ASCII 表值为48 ‘a’ : ASCII 表值为97 ‘A’ : ASCII 表值为65 ‘\\0’: ASCII 表值为0 ‘\\n’: ASCII 表值为10 ‘\\t’: 制表符，按八位输出，不足八位空格补齐。 浮点型 float ：单精度浮点型 %f 4字节 double ：双精度浮点型 %lf 8字节 externextern是关键字，为 声明变量,被extern关键字修饰的变量声明表达式，不能提升成为定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Powered by Jetbrains Clion. * Created by 忘了. * Date: 2018/5/12. * FileName: 0x06_printf2.c. *///***** Code is coming! *****//#include &lt;stdio.h&gt;int main() &#123; int a = 100; //格式化输出a。 printf(\"a = %d \\n\", a); //输出变量a在内存中的地址。 printf(\"&amp;a = %p \\n\", &amp;a); //输出一个百分号 printf(\"百分号 %%\"); //输出a的十六进制 (大写和小写) printf(\"十六进制小写a = %X \\n\", a); printf(\"十六进制大写a = %X \\n\", a); //输出a的十进制 printf(\"十进制a = %d \\n\", a); //输出a的八进制 printf(\"八进制a = %o \\n\", a); //输出a的前占位符 四位宽 printf(\"a = %4d \\n\", a); //输出a的后占位符 四位宽 printf(\"a = %-4d \\n\", a); //输出a的0占位符 四位宽 printf(\"a = %0d \\n\", a); //定义 short 类型的变量 赋值并输出。 short b = 102; printf(\"b = %hd \\n\", b); //定义 long 类型的变量 赋值并输出。 long c = 1023; printf(\"b = %ld \\n\", c); //定义 long long 类型的变量 赋值并输出。 long long d = 1234; printf(\"d = %lld \\n\", d); //定义 double 类型的变量 赋值并输出三位小数。 double e = 12.234567; printf(\"e = %3lf \\n\", e); //定义 float 类型的变量 赋值并输出两位小数。 float f = 12.45566; printf(\"f = %2f \\n\", f); //定义 char 类型的变量 赋值并输出。 char ch = 'c'; printf(\"char = %c \\n\", ch); //定义 任意类型的无符号变量 赋值并输出。 unsigned int g = 123; printf(\"unsigned g = %u \\n\", g); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"软技能：代码之外的生存指南","slug":"软技能：代码之外的生存指南","date":"2018-04-07T14:49:30.000Z","updated":"2018-04-07T14:49:30.000Z","comments":true,"path":"2018/04/07/软技能：代码之外的生存指南/","link":"","permalink":"http://gmle.github.io/2018/04/07/软技能：代码之外的生存指南/","excerpt":"","text":"读者续： 很久之前买的这本书了，一直到我辞去我的第一份工作后，整理书架的时候看到它。这是我众多收藏的书中，唯一一本“非技术”的书。当初并未在意，甚至不知道为什么要去买它。 这本书并未讲述一些技术性的东西，所以我真正拿起这本书的时候，我竟然不是去翻阅目录看这本书到底讲了什么，并没有一点要去获取新的知识（框架/算法/语言）的迫切感。 谨以此续当做我开始读此书的开篇。","categories":[{"name":"读与感","slug":"读与感","permalink":"http://gmle.github.io/categories/读与感/"}],"tags":[{"name":"Books","slug":"Books","permalink":"http://gmle.github.io/tags/Books/"}]},{"title":"不同编译器下的差异","slug":"不同编译器对C++的一些影响","date":"2018-03-16T10:21:43.000Z","updated":"2018-07-21T13:54:52.341Z","comments":true,"path":"2018/03/16/不同编译器对C++的一些影响/","link":"","permalink":"http://gmle.github.io/2018/03/16/不同编译器对C++的一些影响/","excerpt":"在学习C++的时候遇到了一些问题。在不同编译器下 某些代码无法实现。","text":"在学习C++的时候遇到了一些问题。在不同编译器下 某些代码无法实现。 在Mac 默认的编译器 clang下：123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;struct TestType&#123; int data;&#125;;int main(int argc, char *argv[]) &#123; const TestType x = &#123;20&#125;; TestType *x1 = const_cast&lt;TestType*&gt;(&amp;x); x1-&gt;data = 200; cout &lt;&lt; x.data &lt;&lt; endl; cout &lt;&lt; x1-&gt;data&lt;&lt; endl; cout &lt;&lt; \"Hello world\"&lt;&lt; endl; return 0;&#125; 编译通过 ，但是运行的时候会出问题。 检查原因，运行到赋值的地方：1x1-&gt;data = 200; 程序会退出。 但是在msvc等其他编译器下执行则不会出现问题。 其实，我们用const时为了提醒一下自己这个值是个常量，不要动了。但是事实证明 const 常量也是可以改变值的。 但是这就完全没有必要了。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"C++基本类中的构造函数，析构函数，拷贝构造器和运算符重载","slug":"C++构造析构拷贝构造运算符重载","date":"2017-12-18T09:39:05.000Z","updated":"2018-07-21T13:53:41.662Z","comments":true,"path":"2017/12/18/C++构造析构拷贝构造运算符重载/","link":"","permalink":"http://gmle.github.io/2017/12/18/C++构造析构拷贝构造运算符重载/","excerpt":"这可能是一道笔试题。","text":"这可能是一道笔试题。 123456789101112class Test&#123;public: Test() = default; virtual ~Test() = 0; Test(const Test &amp;another); Test &amp;operator=(const Test &amp;another);&#125;;int main(int argc, char *argv[])&#123; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"关于Spark环境变量问题","slug":"关于Spark环境变量问题","date":"2017-11-06T08:44:11.000Z","updated":"2017-11-06T08:44:11.000Z","comments":true,"path":"2017/11/06/关于Spark环境变量问题/","link":"","permalink":"http://gmle.github.io/2017/11/06/关于Spark环境变量问题/","excerpt":"记录一次因为spark内置环境问题引发的惨案","text":"记录一次因为spark内置环境问题引发的惨案 问题：Spark在spark-env.sh中的环境变量不生效 错误日志 Terminal12345678[root@ceshi3 sbin]# ./start-slaves.sh - /usr/local/spark-1.6.0-bin-hadoop2.6/conf/spark-env.sh: line 9: export: `/usr/local/spark-1.6.0-bin-hadoop2.6/lib/spark-assembly-1.6.0-hadoop2.6.0.jar': not a valid identifier- ceshi3: /usr/local/spark-1.6.0-bin-hadoop2.6/conf/spark-env.sh: line 9: export: `/usr/local/spark-1.6.0-bin-hadoop2.6/lib/spark-assembly-1.6.0-hadoop2.6.0.jar': not a valid identifier- ceshi3: starting org.apache.spark.deploy.worker.Worker, logging to /usr/local/spark-1.6.0-bin-hadoop2.6/logs/spark-root-org.apache.spark.deploy.worker.Worker-1-ceshi3.out- ceshi3: failed to launch org.apache.spark.deploy.worker.Worker:- ceshi3: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/spark-class: line 87: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/java: 没有那个文件或目录- ceshi3: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/spark-class: line 87: exec: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/java: cannot execute: 没有那个文件或目录- ceshi3: full log in /usr/local/spark-1.6.0-bin-hadoop2.6/logs/spark-root-org.apache.spark.deploy.worker.Worker-1-ceshi3.out 发现启动worker的时候会出现错误：12- ceshi3: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/spark-class: line 87: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/java: 没有那个文件或目录- ceshi3: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/spark-class: line 87: exec: /usr/local/spark-1.6.0-bin-hadoop2.6/bin/java: cannot execute: 没有那个文件或目录 这个bin/java明明是$ JAVA_HOME 的，为什么会变为 $SPARK_HOME 呢 既然启动报错，而且报的是 $JAVA_HOME，那就要看几个东西:一个是正常的系统变量配置，再一个就是在要启动的服务里是否使用了这个配置变量，再确认下自己的配置是否已经有了。 查看 spark 关于环境变量的配置文件1234567891011export SPARK_DAEMON_JAVA_OPTS=\"-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=dk31:2181,dk32:2181,dk34:2181 -Dspark.deploy.zookeeper.dir=/spark\"export JAVA_HOME=$&#123;JAVA_HOME&#125;export HADOOP_HOME=/usr/local/hadoop-2.6.0export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoopexport SCALA_HOME=/usr/local/scala-2.10.4export SPARK_WORKER_MEMORY=4gexport SPARK_EXECUTOR_MEMORY=2gexport SPARK_DRIVER_MEMORY=1gexport SPARK_WORKER_CORES=4export SPARK_CLASSPATH=/usr/local/spark-1.6.0-bin-hadoop2.6/lib/mysql-connector-java.jarexport SPARK_CLASSPATH=$SPARK_CLASSPATH:$CLASSPATH 发现 $JAVA_HOME 变量是取的系统变量·，但是系统变量为什么取不到？ 查了下：在脚本中使用export, 只在脚本中有效，退出这个脚本，设置的变量就没有了。由于spark-class使用了 spark-env.sh 在使用的时候 已经取不到该值，所以无效了。但是想不通为什么会变成 $SPARK_HOME 的变量","categories":[{"name":"Spark","slug":"Spark","permalink":"http://gmle.github.io/categories/Spark/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gmle.github.io/tags/Shell/"},{"name":"Spark","slug":"Spark","permalink":"http://gmle.github.io/tags/Spark/"},{"name":"Linux","slug":"Linux","permalink":"http://gmle.github.io/tags/Linux/"}]},{"title":"Spark-HA的worker问题","slug":"Spark-HA的worker问题","date":"2017-11-06T08:39:00.000Z","updated":"2017-11-06T08:39:00.000Z","comments":true,"path":"2017/11/06/Spark-HA的worker问题/","link":"","permalink":"http://gmle.github.io/2017/11/06/Spark-HA的worker问题/","excerpt":"关于 HA 中 Spark worker节点连接Master的问题","text":"关于 HA 中 Spark worker节点连接Master的问题 问题：Spark Woker 不去连接ALIVE Master机器： 192.168.1.128 Master 192.168.1.129 Master Worker 192.168.1.130 Worker 启动时两个Master的状态不可控，不知道哪个是ALIVE的Master，worker节点在连接Master的时候，会判断当前Master的状态是否为ALIVE，如果为StandBy，则不继续链接，然后去寻找ALIVE，直到找到ALIVE节点的MASTER。 现在的问题是 Worker在找到StandBy节点后，并没有去寻找新的Master，导致了worker注册不到集群上，自动关闭。 原因待定。 根据一些帖子发现，如果配置了Spark on yarn ，则 Spark HA 基本没有任何作用。 错误日志 Terminal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Using Spark's default log4j profile: org/apache/spark/log4j-defaults.properties17/10/09 13:05:08 INFO Worker: Registered signal handlers for [TERM, HUP, INT]17/10/09 13:05:09 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable17/10/09 13:05:09 INFO SecurityManager: Changing view acls to: root17/10/09 13:05:09 INFO SecurityManager: Changing modify acls to: root17/10/09 13:05:09 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: Set(root); users with modify permissions: Set(root)17/10/09 13:05:10 INFO Utils: Successfully started service 'sparkWorker' on port 39766.17/10/09 13:05:10 INFO Worker: Starting Spark worker 192.168.10.129:39766 with 4 cores, 4.0 GB RAM17/10/09 13:05:10 INFO Worker: Running Spark version 1.6.017/10/09 13:05:10 INFO Worker: Spark home: /opt/dkh/spark-1.6.0-bin-hadoop2.617/10/09 13:05:11 INFO Utils: Successfully started service 'WorkerUI' on port 8081.17/10/09 13:05:11 INFO WorkerWebUI: Started WorkerWebUI at http://192.168.10.129:808117/10/09 13:05:11 INFO Worker: Connecting to master dkm:7077...17/10/09 13:05:11 WARN Worker: Failed to connect to master dkm:7077java.io.IOException: Failed to connect to dkm/192.168.10.128:7077 at org.apache.spark.network.client.TransportClientFactory.createClient(TransportClientFactory.java:216) at org.apache.spark.network.client.TransportClientFactory.createClient(TransportClientFactory.java:167) at org.apache.spark.rpc.netty.NettyRpcEnv.createClient(NettyRpcEnv.scala:200) at org.apache.spark.rpc.netty.Outbox$$anon$1.call(Outbox.scala:187) at org.apache.spark.rpc.netty.Outbox$$anon$1.call(Outbox.scala:183) at java.util.concurrent.FutureTask.run(FutureTask.java:262) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)Caused by: java.net.ConnectException: 拒绝连接: dkm/192.168.10.128:7077 at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:739) at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:224) at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:289) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:528) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354) at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111) ... 1 more17/10/09 13:05:24 INFO Worker: Retrying connection to master (attempt # 1)17/10/09 13:05:24 INFO Worker: Connecting to master dkm:7077...17/10/09 13:05:37 INFO Worker: Retrying connection to master (attempt # 2)17/10/09 13:05:37 INFO Worker: Connecting to master dkm:7077...17/10/09 13:05:50 INFO Worker: Retrying connection to master (attempt # 3)17/10/09 13:05:50 INFO Worker: Connecting to master dkm:7077...17/10/09 13:06:03 INFO Worker: Retrying connection to master (attempt # 4)17/10/09 13:06:03 INFO Worker: Connecting to master dkm:7077...17/10/09 13:06:16 INFO Worker: Retrying connection to master (attempt # 5)17/10/09 13:06:16 INFO Worker: Connecting to master dkm:7077...17/10/09 13:06:29 INFO Worker: Retrying connection to master (attempt # 6)17/10/09 13:06:29 INFO Worker: Connecting to master dkm:7077...17/10/09 13:07:47 INFO Worker: Retrying connection to master (attempt # 7)17/10/09 13:07:47 INFO Worker: Connecting to master dkm:7077...17/10/09 13:09:05 INFO Worker: Retrying connection to master (attempt # 8)17/10/09 13:09:05 INFO Worker: Connecting to master dkm:7077...17/10/09 13:10:23 INFO Worker: Retrying connection to master (attempt # 9)17/10/09 13:10:23 INFO Worker: Connecting to master dkm:7077...17/10/09 13:11:41 INFO Worker: Retrying connection to master (attempt # 10)17/10/09 13:11:41 INFO Worker: Connecting to master dkm:7077...17/10/09 13:12:59 INFO Worker: Retrying connection to master (attempt # 11)17/10/09 13:12:59 INFO Worker: Connecting to master dkm:7077...17/10/09 13:14:17 INFO Worker: Retrying connection to master (attempt # 12)17/10/09 13:14:17 INFO Worker: Connecting to master dkm:7077...17/10/09 13:15:35 INFO Worker: Retrying connection to master (attempt # 13)17/10/09 13:15:35 INFO Worker: Connecting to master dkm:7077...17/10/09 13:16:53 INFO Worker: Retrying connection to master (attempt # 14)17/10/09 13:16:53 INFO Worker: Connecting to master dkm:7077...17/10/09 13:18:11 INFO Worker: Retrying connection to master (attempt # 15)17/10/09 13:18:11 INFO Worker: Connecting to master dkm:7077...17/10/09 13:19:29 INFO Worker: Retrying connection to master (attempt # 16)17/10/09 13:19:29 INFO Worker: Connecting to master dkm:7077...17/10/09 13:20:47 ERROR Worker: All masters are unresponsive! Giving up. 既然如此，那干脆不启动第二个Master，Start-all 后，会发现集群正常，但是没有第二个Master。","categories":[{"name":"Spark","slug":"Spark","permalink":"http://gmle.github.io/categories/Spark/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gmle.github.io/tags/Shell/"},{"name":"Spark","slug":"Spark","permalink":"http://gmle.github.io/tags/Spark/"},{"name":"Linux","slug":"Linux","permalink":"http://gmle.github.io/tags/Linux/"}]},{"title":"对C中堆内存的理解","slug":"对堆的内存分配的理解","date":"2017-11-03T09:35:17.000Z","updated":"2018-07-21T13:55:08.023Z","comments":true,"path":"2017/11/03/对堆的内存分配的理解/","link":"","permalink":"http://gmle.github.io/2017/11/03/对堆的内存分配的理解/","excerpt":"初学者对于堆栈的认识，欢迎吐槽","text":"初学者对于堆栈的认识，欢迎吐槽 C++中内存划分c++划分为五个区： 堆 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete.如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 栈 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。 自由存储区 就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。 全局、静态存储区 全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常亮存储区 这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改(当然，你要通过非正当手段也可以修改) C++内存区域中堆和栈的区别：管理方式不同： 栈是由编译器自动管理，无需我们手工控制。 堆的释放由程序员完成，容易产生内存泄漏。 空间大小不同： 堆内存很大。 栈内存可修改，但默认好像非常小。 内存碎片： 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。 对于栈来讲，则不会存在这个问题。 生长方向不同： 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向； 对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。 加深理解的话： 在函数体中定义的变量通常是在栈上，定义一个变量，内存就少一点。就像一杯水喝一口 堆用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上123456789101112int a = 0; //全局初始化区 char *p1; //全局未初始化区 void main() &#123; int b; //栈 char s[] = \"abc\"; //栈 char *p2; //栈 char *p3 = \"123456\"; //123456&#123;post.content&#125;在常量区，p3在栈上 static int c = 0; //全局(静态)初始化区 p1 = (char *)malloc(10); //分配得来得10字节的区域在堆区 p2 = (char *)malloc(20); //分配得来得20字节的区域在堆区 strcpy(p1, \"123456\"); //123456&#123;post.content&#125;放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成一块 &#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://gmle.github.io/tags/内存管理/"},{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/tags/Cpp/"}]},{"title":"Maven一键安装 centos平台","slug":"yum一键安装maven","date":"2017-09-12T02:48:22.000Z","updated":"2017-09-12T02:48:22.000Z","comments":true,"path":"2017/09/12/yum一键安装maven/","link":"","permalink":"http://gmle.github.io/2017/09/12/yum一键安装maven/","excerpt":"maven一键安装","text":"maven一键安装 添加maven的仓库1wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo yum 安装1yum -y install apache-maven","categories":[{"name":"linux","slug":"linux","permalink":"http://gmle.github.io/categories/linux/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://gmle.github.io/tags/Centos/"},{"name":"maven","slug":"maven","permalink":"http://gmle.github.io/tags/maven/"}]},{"title":"C++标准库","slug":"C++标准库","date":"2017-08-04T09:55:45.000Z","updated":"2018-07-21T13:54:09.386Z","comments":true,"path":"2017/08/04/C++标准库/","link":"","permalink":"http://gmle.github.io/2017/08/04/C++标准库/","excerpt":"C++标准库可以分为两个部分： 标准函数库：继承自C语言； 面向对象库：是类及其相关函数的集合；","text":"C++标准库可以分为两个部分： 标准函数库：继承自C语言； 面向对象库：是类及其相关函数的集合； 标准函数库：输入 / 输出I/O ； 字符串和字符处理； 数学； 时间、日期和本地化； 动态分配； 其他； 宽字符函数；面向对象类： 标准的C++ I/O类； String类； 数值类； STL容器类； STL算法； STL函数对象； STL迭代器； STL分配器； 本地化库； 异常处理类； 杂项支持库；","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://gmle.github.io/categories/Cpp/"}],"tags":[{"name":"HDFS","slug":"HDFS","permalink":"http://gmle.github.io/tags/HDFS/"},{"name":"C++","slug":"C","permalink":"http://gmle.github.io/tags/C/"}]},{"title":"Bash/Shell调用MySQL并忽略警告","slug":"Bash调用MySql","date":"2017-06-25T09:26:19.000Z","updated":"2017-06-25T09:26:19.000Z","comments":true,"path":"2017/06/25/Bash调用MySql/","link":"","permalink":"http://gmle.github.io/2017/06/25/Bash调用MySql/","excerpt":"Shell对MySQL的调用与脚本中如何写 Shell脚本如何搞定 MySQL的增删改查","text":"Shell对MySQL的调用与脚本中如何写 Shell脚本如何搞定 MySQL的增删改查 用Shell对mysql操作非常的简单我们利用 mysql 命令去操作数据库里面的所有东西。 shell脚本1234567891011121314# 一坨一坨的运行：mysql -uroot -p123456 -e \"select * from tmp_test where tmp_name = 'a';select * from tmp_test where tmp_name = 'b';select * from tmp_test where tmp_id = 1;select tmp_name from tmp_test where tmp_id = 2;quit\"# 赋值：id=$(mysql -uroot -p123456 -e \"SELECT tmp_id from tmp_test WHERE tmp_name = 'a';\")# 会发现还有字段名字，加参数去掉字段名，只保留我们要查询的：id=$(mysql -uroot -p123456 -Bse \"SELECT tmp_id from tmp_test WHERE tmp_name = 'a';\") 过后我们会发现每次查询之后会出现警告，每次都出：1mysql: [Warning] Using a password on the command line interface can be insecure. MySQL 版本 5.6+ 的安全策略MySQL5.6版本向上有一个密码安全问题，即在命令行输入密码会出现警告： 12mysql -uroot -proot mysql: [Warning] Using a password on the command line interface can be insecure. 读取配置文件的参数也不可以，这样我们 需要指定一个mysql的配置文件作为mysql的配置输入进去： cnf配置文件my.cnf123#!/bin/bash[mysql]password=root 然后再在脚本中调用：123#!/bin/bash# 继续赋值，这样就不会出现警告信息：id=$(mysql --defaults-file=./my.cnf -uroot -Bse \"SELECT tmp_id from tmp_test WHERE tmp_name = 'a';\")","categories":[{"name":"Shell","slug":"Shell","permalink":"http://gmle.github.io/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gmle.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"http://gmle.github.io/tags/Bash/"},{"name":"MySQL","slug":"MySQL","permalink":"http://gmle.github.io/tags/MySQL/"}]},{"title":"在Centos6.5下升级python至3.6.0","slug":"centos6.5下python2.6.6升级至3.6","date":"2017-05-11T07:57:48.000Z","updated":"2017-05-11T07:57:48.000Z","comments":true,"path":"2017/05/11/centos6.5下python2.6.6升级至3.6/","link":"","permalink":"http://gmle.github.io/2017/05/11/centos6.5下python2.6.6升级至3.6/","excerpt":"此次升级保留旧版本的环境。","text":"此次升级保留旧版本的环境。 配置系统环境安装开发工具1yum groupinstall -y developement 安装python3解码支持包1yum install -y zlib-devel openssl-devel sqlite-devel bzip2-devel 准备更新版本验证原有的python版本1python -V python 2.6.6 下载python3.6.0包1wget http://www.python.org/ftp/python/3.6.0/Python-3.6.0.tar.xz 解压编译python安装包解压12xz -d Python-3.6.0.tar.xztar -xvf Python-3.6.0.tar 编译123cd Python-3.6.0# 配置安装路径./configure --prefix=/usr/local 如果出现编译错误可能是因为gcc gcc-c++版本太低或者未安装，使用代码 1yum -y install gcc gcc-c++ 进行安装，然后重新编译./configure 执行安装1make &amp;&amp; make altinstall 建立软连接(就是快捷方式)12mv /usr/bin/python /usr/bin/python2.6.6 ##你的python版本可能不同ln -s /usr/local/bin/python3.6 /usr/bin/python 重新验证python版本， 1python -V python3.6.0 yum指令会报错，将其重新指向旧版本的python1vi /usr/bin/yum 将文件的头部#！/usr/bin/python改为#！/usr/bin/python2.6.6 安装新pip1$ wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate 解压安装pip1234chmod +x pip-1.3.1.tar.gztar xzvf pip-1.3.1.tar.gzcd pip-1.3.1python setup.py install 查看pip安装1pip -V pip 1.3.1 from /usr/local/lib/python3.6/site-packages/pip-1.3.1-py3.6.egg (python 3.6)","categories":[{"name":"Centos","slug":"Centos","permalink":"http://gmle.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://gmle.github.io/tags/Centos/"},{"name":"Python","slug":"Python","permalink":"http://gmle.github.io/tags/Python/"}]},{"title":"Hadoop_HDFS底层架构","slug":"对HDFS的一些认识","date":"2017-05-03T06:38:42.000Z","updated":"2017-05-03T06:38:42.000Z","comments":true,"path":"2017/05/03/对HDFS的一些认识/","link":"","permalink":"http://gmle.github.io/2017/05/03/对HDFS的一些认识/","excerpt":"这是我对HDFS的认知与了解，并结合网上查阅的资料进行的整合。 HDFS设计基础与目标 硬件错误是常态，因此需要冗余。 错误检测和快速、自动的恢复是HDFS最核心的架构目标 小文件不适合存储，适合存储超大文件 流式数据访问","text":"这是我对HDFS的认知与了解，并结合网上查阅的资料进行的整合。 HDFS设计基础与目标 硬件错误是常态，因此需要冗余。 错误检测和快速、自动的恢复是HDFS最核心的架构目标 小文件不适合存储，适合存储超大文件 流式数据访问 流式数据访问，即数据劈来给你读取而非随机读写，Hadoop需要的是数据分析而不是事务处理 大规模数据集 简单一致性模型，为了降低系统复杂度，对文件采用一次写多次读的理念：文件一经写入，关闭，再也不能修改。 程序采用 “数据就近” 原则分配节点执行。 HDFS的底层架构分布式文件系统 优点： - 传统文件系统最大问题是容量和吞吐来那个的限制 - 多用户多应用的并行读写是分布式文件系统产生的根源 - 扩充存储空间的成本低廉 - 物理层存储的分布式 - 基于科户籍/服务器模式 - 通常情况下基于操作系统的本地文件系统 HDFS体系结构 NameNode 管理文件系统的命名空间 记录每个文件数据快再各个DataNode上的文职和副本信息 协调客户端对文件的访问 协调客户端对文件的访问 记录命名空间内的改动或空间本身属性的改动 NameNode使用事务日志记录HDFS元数据的变化，使用映像文件存储文件系统的命名空间，包括文件映射，文件属性等 DataNode 负责所在物理节点的存储管理 一次写入，多次读取（不能修改） 文件由数据块组成，典型块的大小 0-1.0之间版本大小-&gt; 64M 1-2.x 大小为 128M 数据块尽量散布到各个节点内 事务日志 映像文件 SecondaryNameNode HDFS的高可用性 HDFS集群中NameNode存在单点故障。 躲雨只有一个NameNode的集群，如果NameNode及其出现意外downtime，那么整个集群将无法使用，知道NameNode重新启动","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"http://gmle.github.io/tags/HDFS/"}]},{"title":"Hadoop_玩转 HDFS之 ACL","slug":"玩转HDFS-ACL","date":"2017-05-03T06:38:39.000Z","updated":"2017-05-03T06:38:39.000Z","comments":true,"path":"2017/05/03/玩转HDFS-ACL/","link":"","permalink":"http://gmle.github.io/2017/05/03/玩转HDFS-ACL/","excerpt":"Hadoop从2.4.0版本开始支持hdfs的ACL， 通俗的讲就是文件访问控制权限 下面对其进行一些测试： unnamed user (file owner) 文件的拥有者 unnamed group (file group) 文件的所属组 named user 除了文件的拥有者和拥有组之外，的其它用户 named group 除了文件的拥有者和拥有组之外，的其它用户 mask 权限掩码，用于过滤named user和named group的权限","text":"Hadoop从2.4.0版本开始支持hdfs的ACL， 通俗的讲就是文件访问控制权限 下面对其进行一些测试： unnamed user (file owner) 文件的拥有者 unnamed group (file group) 文件的所属组 named user 除了文件的拥有者和拥有组之外，的其它用户 named group 除了文件的拥有者和拥有组之外，的其它用户 mask 权限掩码，用于过滤named user和named group的权限 一、启用ACL启用ACL功能 修改hdfs-site.xml 增加如下属性 开启ACL12345678&lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.acls.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 修改core-site.xml 设置用户组默认权限.1234&lt;property&gt; &lt;name&gt;fs.permissions.umask-mode&lt;/name&gt; &lt;value&gt;002&lt;/value&gt;&lt;/property&gt; 一个访问控制列表（ACL）是一组ACL词目(entries)的集合，每个ACL词目会指定一个用户/组，并赋予读/写/执行上等权限。例如：123456user::rw- user:bruce:rwx #effective:r-- group::r-x #effective:r-- group:sales:rwx #effective:r-- mask::r-- other::r-- 这里面，没有命名的用户/组即该文件的基本所属用户/组。每一个ACL都有一个掩码(mask)，如果用户不提供掩码，那么该掩码会自动根据所有ACL条目的并集来获得(属主除外）。在该文件上运行chmod会改变掩码的权限。由于掩码用于过滤，这有效地限制了权限的扩展ACL条目，而不是仅仅改变组条目，并可能丢失的其他扩展ACL条目。 定义默认 （default）ACL条目，新的子文件和目录会自动继承默认的ACL条目设置，而只有目录会有默认的ACL条目。例如： 123456789user::rwx group::r-x other::r-x default:user::rwx default:user:bruce:rwx #effective:r-x default:group::r-x default:group:sales:rwx #effective:r-x default:mask::r-x default:other::r-x ACL相关的文件API：1234567891011public void modifyAclEntries(Path path, List aclSpec) throws IOException;public void removeAclEntries(Path path, List aclSpec) throws IOException;public void public void removeDefaultAcl(Path path) throws IOException;public void removeAcl(Path path) throws IOException;public void setAcl(Path path, List aclSpec) throws IOException;public AclStatus getAclStatus(Path path) throws IOException; 命令行命令：显示文件和目录的访问控制列表。如果一个目录有默认的ACL，getfacl也可以显示默认的ACL设置。1hdfs dfs -getfacl [-R] path 设置文件和目录的ACL1hdfs dfs -setfacl [-R] [-b|-k -m|-x acl_spec path]|[--set acl_spec path] 12345-R: Use this option to recursively list ACLs for all files and directories.-b: Revoke all permissions except the base ACLs for user, groups and others.-k: Remove the default ACL.-m: Add new permissions to the ACL with this option. Does not affect existing permissions.-x: Remove only the ACL specified. 当ls的权限位输出以+结束时，那么该文件或目录正在启用一个ACL。1hdfs dfs -ls args 实际使用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 默认只有基本的权限控制hdfs dfs -getfacl /data# file: /data# owner: hive# group: hadoopuser::rwxgroup::r-xother::r-x#递归显示/data下所有文件的ACLhdfs dfs -getfacl -R /data# file: /data# owner: hive# group: hadoopuser::rwxgroup::r-xother::r-x# file: /data/test.zero# owner: hive# group: hadoopuser::rw-group::r--other::r--# file: /data/test.zero.2# owner: hive# group: hadoopuser::rw-group::r--other::r--#添加一个用户ACL条目hdfs dfs -setfacl -m user:hbase:rw- /data/test.zero#添加一个组ACL条目和一个用户ACL条目（如果设置一个未命名条目，可以用user::r-x，group::r-w或者other::r-x等来设置）hdfs dfs -setfacl -m group:crm:--x,user:app1:rwx /data/test.zero.2#移除一个ACL条目hdfs dfs -setfacl -x user:app1 /data/test.zero.2#“+”已开启了ACL功能hdfs dfs -ls -R /data-rw-rwxr--+ 3 hive hadoop 1073741824 2014-12-21 15:32 /data/test.zero-rw-r-xr--+ 3 hive hadoop 1073741824 2014-12-21 15:50 /data/test.zero.2# 查看当前ACL，此时mask已经被生成hdfs dfs -getfacl -R /data/test.zero.2# file: /data/test.zero.2# owner: hive# group: hadoopuser::rw-group::r--group:crm:--xmask::r-xother::r--hdfs dfs -getfacl /data/test.zero.2# 为data目录添加default权限hdfs dfs -setfacl -m default:user:debugo:rwx /datahdfs dfs -mkdir /data/d1hdfs dfs -getfacl /data/d1user::rwxuser:debugo:rwx #effective:r-xgroup::r-xmask::r-xother::r-xdefault:user::rwxdefault:user:debugo:rwxdefault:group::r-xdefault:mask::rwxdefault:other::r-x#可以看出，default虽然继承给了d1，但是被mask=r-x所过滤，所以这里还需要设置mask。此时debugo用户的权限可以被正常访问。hdfs dfs -setfacl -m mask::rwx /data/d1hdfs dfs -getfacl /data/d1# file: /data/d1# owner: hdfs# group: hadoopuser::rwxuser:debugo:rwxgroup::r-xmask::rwxother::r-x","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"http://gmle.github.io/tags/HDFS/"},{"name":"ACL","slug":"ACL","permalink":"http://gmle.github.io/tags/ACL/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2017-05-03T06:38:36.000Z","updated":"2017-05-03T06:38:36.000Z","comments":true,"path":"2017/05/03/正则表达式/","link":"","permalink":"http://gmle.github.io/2017/05/03/正则表达式/","excerpt":"正则表达式的基础使用。 正则表达式 --&gt; 专门勇于操作字符串； 可以理解为 ‘正确的规则’。 好处：用了一些符号来代表一些代码，书写起来更为简单。 弊端：可读性差，而且要把符号学完 但是底层也是要配合代码实现的。","text":"正则表达式的基础使用。 正则表达式 --&gt; 专门勇于操作字符串； 可以理解为 ‘正确的规则’。 好处：用了一些符号来代表一些代码，书写起来更为简单。 弊端：可读性差，而且要把符号学完 但是底层也是要配合代码实现的。 正则表达式再每个语言中都大同小异。具体语法查看相应的API 入门学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。 符号学习1、了解一下常见的正则符号： 1.1 [] ：【判断字符位上的内容】 1.2 与定义字符：都带着反斜线 .： 任意字符 \\\\d : 数字 [0-9] \\\\D : 非数字 [^0-9] \\\\w : 单词字符[a-zA-Z_0-9] 1.3 边界字符 ^ : 行开头 $ : 行结尾 \\b : 单词边界 1.4 数量词：必须结合内容 X? : x内容出现零次或一次 X* : x内容出现零次或多次 X+ : x内容出现一次或多次 X(n) : x内容出现n此 X(n,) : x内容出现至少n此 X(n,m) : x内容出现n到m此 常见功能操作字符串String类 匹配 结果为 true | false就是String类中的machers方法 12345678910111213141516171819202122232425package cn.lesion.Regular;import java.util.regex.Pattern;/** * Created in Intellij IDEA . * Author: 王乐. * Date : 16-5-17. * * 匹配手机号 */public class phoneBoolen &#123; public static void main(String[] args) &#123; //手机号 String phone = \"17093548877\"; //定义规则 String phone_Regex = \"^((13[0-9])|(15[^4,\\\\D])|(18[0,5-9]))\\\\d&#123;8&#125;$\"; System.out.println(phone+\"::\"+phone.matches(phone_Regex)); &#125;&#125; 切割 结果为 String[] 字符串数组利用String中的方法 Splite12345678910111213141516171819202122232425262728293031323334353637383940package cn.lesion.Regular;/** * Created in Intellij IDEA . * Author: 王乐. * Date : 16-5-17. */public class splitStr &#123; public static void main(String[] args) &#123;// String str = \"zhagnsan lisi wangwu\";// String regex = \" +\";// String str = \"zhangsan,lisi,wangwu\";// String regex = \",\"// String str = \"zhangsan.lisi.wangwu\";// String regex = \"\\\\.\"; //正则规则的复用：想复用 先封装 正则封装用小括号完成 //封装完成之后有编号，从1开始。规则中被小括号封装的称之为组，直接通过编号就可以调用对应的组 //调用方式直接写已有的组的编号前面加上\\\\ 如 ()\\\\1，在使用已有的第一组内容。原则：必须要先有组 String str = \"zhangsan@@@@lisi###wangwu\"; String regex = \"(.)\\\\1+\"; String[] strs = str.split(regex); for (String s: strs) &#123; System.out.println(\"--\"+s+\"--\"); &#125; &#125;&#125; 替换 结果是一个新的字符串利用String中的方法 replaceAll1234567891011121314151617181920212223242526272829303132package cn.lesion.Regular;/** * Created in Intellij IDEA . * Author: 王乐. * Date : 16-5-17. */public class replace &#123; public static void main(String[] args) &#123;/* String str = \"ajkls@@@@@fbxcv@@@@@@opi\"; //在参数列表中，其他参数钥匙用之前参数中规则的组，需要使用$组编号 str = str.replaceAll(\"(.)\\\\1+\", \"$1\");*//* String str = \"13623372344\"; //136****2344 str = str.replaceAll(\"(\\\\d&#123;3&#125;)\\\\d&#123;4&#125;(\\\\d&#123;4&#125;)\", \"$1****$2\");*/ String str = \"lzxiujcbvil1111111111111111111adgfadkgji23984567289345079\"; //替换N个以上的数字 str = str.replaceAll(\"\\\\d&#123;4,&#125;\", \"***\"); System.out.println(str); &#125;&#125; 获取 结果为 String[] 字符串数组其它三个功能内部最终是用的都是Pattern正则表达式对象。现在需要其他功能时，字符串String类中没有对象的方法。Pattern对象的使用原理 将正则表达式字符串编译成正则对象 pattern 通过pattern对象获取macher对象（匹配器对象） 通过匹配器对象对字符串进行规则的匹配，结果都在匹配器中 通过匹配器对象的功能获取结果 范例：123456//编译为正则对象Pattern p = Pattern.compile(\"a*b\");//返回一个匹配器对象Matcher m = p.matcher(\"aaaaaab\");//判断boolean b = m.matches(); 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.lesion.Regular;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Created in Intellij IDEA . * Author: 王乐. * Date : 16-5-17. * * 取出 */public class takeOutWords &#123; public static void main(String[] args) &#123; String str = \"da jia zhu yi le, ming tian fang jia le!\"; //取出由三个字母组成的单词 String regex = \"\\\\b[a-zA-Z]&#123;3&#125;\\\\b\"; //将正则表达式转换为对象 Pattern p = Pattern.compile(regex); //和要操作的字符串关联，获取对应的匹配器对象 Matcher m = p.matcher(str); while (m.find()) &#123; //第一种取值方式 System.out.println(m.group()); //第二种取值方式 System.out.println(str.substring(m.start(),m.end())); &#125; &#125;&#125;","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://gmle.github.io/categories/正则表达式/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gmle.github.io/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://gmle.github.io/tags/正则表达式/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://gmle.github.io/tags/JavaSE/"}]},{"title":"hadoop常见面试题目（不定期更新）","slug":"hadoop常见面试题目","date":"2017-05-03T06:38:19.000Z","updated":"2017-05-03T06:38:19.000Z","comments":true,"path":"2017/05/03/hadoop常见面试题目/","link":"","permalink":"http://gmle.github.io/2017/05/03/hadoop常见面试题目/","excerpt":"整理一些面试题，以便与日后查看（不定期更新） 2016.04.21 – 更新下面哪个程序负责 HDFS 数据存储？ a)NameNode b)Jobtracker c)Datanode d)secondaryNameNode e)tasktracker","text":"整理一些面试题，以便与日后查看（不定期更新） 2016.04.21 – 更新下面哪个程序负责 HDFS 数据存储？ a)NameNode b)Jobtracker c)Datanode d)secondaryNameNode e)tasktracker HDfS 中的 block 默认保存几份？ a)3 份 b)2 份 c)1 份 d)不确定 下列哪个程序通常与 NameNode 在一个节点启动？ a)SecondaryNameNode b)DataNode c)TaskTracker d)Jobtracker &gt;此题分析： hadoop的集群是基于master/slave模式，namenode和jobtracker属于master，datanode和tasktracker属于slave，master只有一个，而slave有多个SecondaryNameNode内存需求和NameNode在一个数量级上，所以通常secondary NameNode（运行在单独的物理机器上）和NameNode运行在不同的机器上。 JobTracker和TaskTracker； JobTracker 对应于 NameNode； TaskTracker 对应于 DataNode； DataNode 和NameNode 是针对数据存放来而言的； JobTracker和TaskTracker是对于MapReduce执行而言的。 mapreduce中几个主要概念，mapreduce整体上可以分为这么几条执行线索：obclient，JobTracker与TaskTracker。 1、JobClient会在用户端通过JobClient类将应用已经配置参数打包成jar文件存储到hdfs，并把路径提交到Jobtracker,然后由JobTracker创建每一个Task（即MapTask和ReduceTask）并将它们分发到各个TaskTracker服务中去执行。 2、JobTracker是一个master服务，软件启动之后JobTracker接收Job，负责调度Job的每一个子任务task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。一般情况应该把JobTracker部署在单独的机器上。 3、TaskTracker是运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信，接收作业，并负责直接执行每一个任务。TaskTracker都需要运行在HDFS的DataNode上。 Hadoop 作者 答案C Doug cutting a)Martin Fowler b)Kent Beck c)Doug cutting 下列哪项通常是集群的最主要瓶颈: a)CPU b)网络 c)磁盘IO d)内存 &gt;该题解析： 首先集群的目的是为了节省成本，用廉价的pc机，取代小型机及大型机。小型机和大型机有什么特点？ 1.cpu处理能力强 2.内存够大 所以集群的瓶颈不可能是a和d 3.网络是一种稀缺资源，但是并不是瓶颈。 4.由于大数据面临海量数据，读写数据都需要io，然后还要冗余数据，hadoop一般备3份数据，所以IO就会打折扣。 关于 SecondaryNameNode 哪项是正确的？ a)它是 NameNode 的热备 b)它对内存没有要求 c)它的目的是帮助 NameNode 合并编辑日志，减少 NameNode 启动时间 d)SecondaryNameNode 应与 NameNode 部署到一个节点。 下列哪项可以作为集群的管理？ a)Puppet b)Pdsh c)Cloudera Manager d)Zookeeper Cloudera 提供哪几种安装 CDH 的方法？ a)Cloudera manager b)Tarball c)Yum d)Rpm Ganglia 不仅可以进行监控，也可以进行告警。（ 正确） 分析：此题的目的是考Ganglia的了解。严格意义上来讲是正确。ganglia作为一款最常用的Linux环境中的监控软件，它擅长的的是从节点中按照用户的需求以较低的代价采集数据。但是ganglia在预警以及发生事件后通知用户上并不擅长。最新的ganglia已经有了部分这方面的功能。但是更擅长做警告的还有Nagios。Nagios，就是一款精于预警、通知的软件。通过将Ganglia和Nagios组合起来，把Ganglia采集的数据作为Nagios的数据源，然后利用Nagios来发送预警通知，可以完美的实现一整套监控管理的系统。 Block Size 是不可以修改的。（错误 ） 分析：它是可以被修改的Hadoop的基础配置文件是hadoop-default.xml，默认建立一个Job的时候会建立Job的Config，Config首先读入hadoop-default.xml的配置，然后再读入hadoop-site.xml的配置（这个文件初始的时候配置为空），hadoop-site.xml中主要配置需要覆盖的hadoop-default.xml的系统级配置。 Nagios 不可以监控 Hadoop 集群，因为它不提供 Hadoop 支持。（错误 ） 分析：Nagios是集群监控工具，而且是云计算三大利器之一 如果 NameNode 意外终止，SecondaryNameNode 会接替它使集群继续工作。（错误 ） 分析：SecondaryNameNode是帮助恢复，而不是替代，如何恢复，可以查看 Cloudera CDH 是需要付费使用的。（错误 ） 分析：第一套付费产品是Cloudera Enterpris，Cloudera Enterprise在美国加州举行的 Hadoop 大会 (Hadoop Summit) 上公开，以若干私有管理、监控、运作工具加强 Hadoop 的功能。收费采取合约订购方式，价格随用的 Hadoop 叢集大小变动。 Hadoop 是 Java 开发的，所以 MapReduce 只支持 Java 语言编写。（错误 ） 分析：rhadoop是用R语言开发的，MapReduce是一个框架，可以理解是一种思想，可以使用其他语言开发。 Hadoop 支持数据的随机读写。（错 ） 分析：lucene是支持随机读写的，而hdfs只支持随机读。但是HBase可以来补救。HBase提供随机读写，来解决Hadoop不能处理的问题。HBase自底层设计开始即聚焦于各种可伸缩性问题：表可以很“高”，有数十亿个数据行；也可以很“宽”，有数百万个列；水平分区并在上千个普通商用机节点上自动复制。表的模式是物理存储的直接反映，使系统有可能提高高效的数据结构的序列化、存储和检索。 NameNode 负责管理 metadata，client 端每次读写请求，它都会从磁盘中读取或则会写入 metadata 信息并反馈 client 端。（错误） 此题分析： NameNode 不需要从磁盘读取 metadata，所有数据都在内存中，硬盘上的只是序列化的结果，只有每次 namenode 启动的时候才会读取。 1）文件写入 Client向NameNode发起文件写入的请求。 NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。 Client将文件划分为多个Block，根据DataNode的地址信息，按顺序写入到每一个DataNode块中。 2）文件读取 Client向NameNode发起文件读取的请求。 NameNode 本地磁盘保存了 Block 的位置信息。（ 个人认为正确，欢迎提出其它意见） 分析：DataNode是文件存储的基本单元，它将Block存储在本地文件系统中，保存了Block的Meta-data，同时周期性地将所有存在的Block信息发送给NameNode。NameNode返回文件存储的DataNode的信息。 Client读取文件信息。 DataNode 通过长连接与 NameNode 保持通信。（ ） 这个有分歧：具体正在找这方面的有利资料。下面提供资料可参考。 首先明确一下概念： （1）.长连接 Client方与Server方先建立通讯连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在，此种方式常用于点对点通讯。 （2）.短连接 Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server. Hadoop 自身具有严格的权限管理和安全措施保障集群正常运行。（错误 ） hadoop只能阻止好人犯错，但是不能阻止坏人干坏事 Slave 节点要存储数据，所以它的磁盘越大越好。（ 错误） 分析：一旦Slave节点宕机，数据恢复是一个难题 hadoop dfsadmin –report 命令用于检测 HDFS 损坏块。（错误 ） Hadoop 默认调度器策略为 FIFO（正确 ） 集群内每个节点都应该配 RAID，这样避免单磁盘损坏，影响整个节点运行。（错误 ） 分析：首先明白什么是RAID，可以参考百科磁盘阵列。这句话错误的地方在于太绝对，具体情况具体分析。题目不是重点，知识才是最重要的。因为hadoop本身就具有冗余能力，所以如果不是很严格不需要都配备RAID。具体参考第二题。 因为 HDFS 有多个副本，所以 NameNode 是不存在单点问题的。（错误 ） 每个 map 槽就是一个线程。（错误 ） 分析：首先我们知道什么是map 槽,map 槽-&gt;map slotmap slot 只是一个逻辑值 ( org.apache.hadoop.mapred.TaskTracker.TaskLauncher.numFreeSlots )，而不是对应着一个线程或者进程 每个 map 槽就是一个线程。（错误 ） 分析：首先我们知道什么是map 槽,map 槽-&gt;map slotmap slot 只是一个逻辑值 ( org.apache.hadoop.mapred.TaskTracker.TaskLauncher.numFreeSlots )，而不是对应着一个线程或者进程 Mapreduce 的 input split 就是一个 block。（错误 ） Hadoop 环境变量中的 HADOOP_HEAPSIZE 用于设置所有 Hadoop 守护线程的内存。它默认是 200 GB。（ 错误） hadoop为各个守护进程（namenode,secondarynamenode,jobtracker,datanode,tasktracker）统一分配的内存在hadoop-env.sh中设置，参数为HADOOP_HEAPSIZE，默认为1000M。 NameNode 的 Web UI 端口是 50030，它通过 jetty 启动的 Web 服务。（错误 ） DataNode 首次加入 cluster 的时候，如果 log 中报告不兼容文件版本，那需要 NameNode执行“Hadoop namenode -format”操作格式化磁盘。（错误 ） 分析： 首先明白介绍，什么ClusterID ClusterID 添加了一个新的标识符ClusterID用于标识集群中所有的节点。当格式化一个Namenode，需要提供这个标识符或者自动生成。这个ID可以被用来格式化加入集群的其他Namenode。 二次整理 有的同学问题的重点不是上面分析内容：内容如下： 这个报错是说明 DataNode 所装的Hadoop版本和其它节点不一致，应该检查DataNode的Hadoop版本","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"面试","slug":"面试","permalink":"http://gmle.github.io/tags/面试/"}]},{"title":"HBase的列簇","slug":"HBase的列簇","date":"2017-05-03T06:38:13.000Z","updated":"2017-05-03T06:38:13.000Z","comments":true,"path":"2017/05/03/HBase的列簇/","link":"","permalink":"http://gmle.github.io/2017/05/03/HBase的列簇/","excerpt":"对于HBase中的列簇，新手都会有这样的问题 HBase的列有列族前缀和列组成， 那么一个表中列族要怎么设定？ 是只设定一个？还是越多越好？还是根据什么设定几个？","text":"对于HBase中的列簇，新手都会有这样的问题 HBase的列有列族前缀和列组成， 那么一个表中列族要怎么设定？ 是只设定一个？还是越多越好？还是根据什么设定几个？ 何时用HBase1.系统需要适应不同种类的数据格式和数据源，不能预先严格定义模式，需要处理大规模数据； 2.不强调数据之间的关系，所要存储的数据是半结构化或非结构化的； 3.数据非常稀疏； 4.想要更好的进行扩展； 比如谷歌就将BigTable用来存储网页的索引数据，索引数据就很好的满足了上面的几点要求。 HBase的结构表、行、列和单元格 先做一个简单的总结：最基本的单位是列（column），一列或者多列组成一行（row），并且由唯一的行键（row key）来确定存储。 一个表中有很多行，每一列可能有多个版本，在每一个单元格（Cell）中存储了不同的值。 HBase的行与行之间是有序的，按照row key的字典序进行排序，行键是唯一的，在一个表里只出现一次，否则就是在更新同一行，行键可以是任意的字节数组。 一行由若干列组成，其中的某些列又可以构成一个列族（column family），一个列族的所有列存储在同一个底层的存储文件里，这个文件称之为HFile。 列族需要在创建表的时候就定义好，数量也不宜过多。 列族名必须由可打印字符组成，创建表的时候不需要定义好列。 对列的引用格式通常为family：qualifier，qualifier也可以是任意的字节数组。 同一个列族里qualifier的名称应该唯一，否则就是在更新同一列，列的数量没有限制，可以有数百万个。 列值也没有类型和长度限定。 HBase会对row key的长度做检查，默认应该小于65536。 一个可视化的HBase表如下： Timestamp代表时间戳，默认由系统指定，用户也可以显示设置。使用不同的时间戳来区分不同的版本。一个单元格的不同版本的值按照时间戳降序排列在一起，在读取的时候优先取最新的值。用户可以指定每个值能保存的最大版本数. HBase的存取模式如下（表，行键，列族，列，时间戳）-&gt; 值。即一个表中的某一行键的某一列族的某一列的某一个版本的值唯一。 行数据的存取操作是原子的，可以读取任意数目的列。目前还不支持跨行事务和跨表事务。 同一列族下的数据压缩在一起，访问控制磁盘和内存都在列族层面进行。 2.自动分区 HBase中扩展和负载均衡的基本单元称作region，region本质上是以行键排序的连续存储空间。如果region过大，系统就会把它们动态拆分，相反的，就把多个region合并，以减少存储文件数量。 一个表最开始只有一个region，用户开始向表中插入数据时，系统会检查region大小，确保不会超过配置的最大值，如果超过，会从region中行键的中间值一分为二，将该region分为大小大致相等的两个region。 3.存储格式 HFile：HBase中KeyValue数据的存储格式。HFile是Hadoop的二进制格式文件。 HLog：HBase中WAL（Write-Ahead-Log，预写式日志）文件的存储格式，物理上是Hadoop的Sequence File。 HFile的格式如下图： HFile文件的长度可变，唯一固定的是File Info和Trailer。Trailer存储指向其他块的指针，它在持久化数据到文件结束时写入的，写入后，该文件就会变成不可变的数据存储文件。数据块（data blocks）中存储key-values，可以看做是一个MapFile。当block关闭操作时，第一个key会被写入index中，index文件在hfile关闭操作时写入。 KeyValue的具体格式如下图： 上图中，keytype有四种类型，分别是Put、Delete、 DeleteColumn和DeleteFamily。RowLength为2个字节，Row长度不固定，ColumnFamilyLength为2个字节，ColumnFamily长度不固定，ColumnQualifier长度不固定，TimeStamp为4个字节，KeyType为1个字节。之所以不记录ColumnQualifier的长度是因为可以通过其他字段计算得到。 HBase常用操作：List；Create；Put；Scan；Get；Delete；Disable；Drop； 列簇的设计1、列簇的设计需要根据你的业务。那些可能被反复修改的数据表尽量使用单列簇。 每个列簇在HDFS都有一个独立的HFILE，当某个ROWKEY的某个列簇数据被冲刷时，这个ROWKEY连带的其他列簇数据也会被一起冲刷，I/O负担很大。 APACHE官方也提倡多列簇的设计方案，单列簇性能是最高的。 而持久型数据，也就是一次写入，从不修改的数据，可以使用多列簇，原理相同，但目前任然提倡单列簇设计模式 2、多列簇的效率问题参照1 3、所谓列簇分组，就相当于关系习惯数据库中，两个表被纵向合并，形成一张双列簇的表","categories":[{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/categories/HBase/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/tags/HBase/"},{"name":"列族","slug":"列族","permalink":"http://gmle.github.io/tags/列族/"}]},{"title":"HBase的配置(伪分布式)","slug":"HBase的配置(伪分布式)","date":"2017-05-03T06:38:09.000Z","updated":"2017-05-03T06:38:09.000Z","comments":true,"path":"2017/05/03/HBase的配置(伪分布式)/","link":"","permalink":"http://gmle.github.io/2017/05/03/HBase的配置(伪分布式)/","excerpt":"","text":"HBase的CRUD ###源码链接https://github.com/gmle/hbase","categories":[{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/categories/HBase/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/tags/HBase/"}]},{"title":"HBase的数据模型","slug":"HBase的数据模型","date":"2017-05-03T06:38:01.000Z","updated":"2017-05-03T06:38:01.000Z","comments":true,"path":"2017/05/03/HBase的数据模型/","link":"","permalink":"http://gmle.github.io/2017/05/03/HBase的数据模型/","excerpt":"目录介绍概览行列簇时间戳 此篇为参考文章","text":"目录介绍概览行列簇时间戳 此篇为参考文章 介绍HBase 的数据模型是继 Bigtable 数据模型的之后的克隆版，特别适用于密集的数据系统。 也就是HBase是通过Google的BigTable演变而来 概览看简单点，HBase可以概括成一个Map &gt;Map&lt;byte[], Map&lt;byte[], Map&lt;byte[], Map&lt;Long, byte[]&gt;&gt;&gt; 第一个Map是映射从 row keys 到 column families。 第二个Map是映射从 column families 到他们的 column keys。 第三个Map是映射从 column keys 到他们的 timestamps 。 最后，最后的Map映射 timestamps 到一个单一的值。 keys 一般为 字符串 strings， timestamps 是一个长整型 longs。而值则为一个不解释的字节数组。列的 keys 总在其 families 后面，表现如：family:key。因为一个 family 映射到另一个其他的map，这在理论上允许一个 family 包含无限个 column keys。因此，为了获取一个值，用户需要使用三个 keys 来 get ： row key+column key+timestamp -&gt; value 行键+列键+时间戳 -&gt; 值 行HBase 以数组格式来处理 row key，但 row key 本身是有字符串的形式表现。row key Map 一个特性就是以一个词典顺序来保存。例如，从1到100的数字，就是按照 1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99 这样的方式来保存。 要想以自然顺序来保存整型数，row keys 必须在左边以0填充。利用这一点，row key Map 的功能可以通过提供一个 scaner 来增强， scaner 带有一个 start row key 和 一个 stop row key。例如，如果 row keys 是日期格式 YYYYMMDD，获取 2008年7月整个月的内容，就是打开一个 scaner （20080700到20080800）。它并不关心指定的 row keys 存在与否，唯一要关心的，就是这个调用不会返回 stop row key，因此，stop row key 必须给 scaner 指定好。 列簇在 Hbase中，列成员重组具有同一性质的数据，并不限制数据类型。簇是表模式的一部分，为每行保存同种数据。与 froms rows to forws 不同的是 column keys 可以是稀少的。例如，row “20080702” 可以拥有自己的“info:”成员，该成员下有如下几个 column keys：info:aaainfo:bbbinfo:ccc同样，row “20080703”仅有：info:12342在使用 column keys 的时候，开发者必须要非常小心。因为长度为0 的 key是允许的，这说明，在前面的例子中，数据可以被插入到 column key “info:” 中。我们强烈推荐，仅仅在没有其他的 keys 指定时使用空的 key。同样，由于一个成员中的数据是同一种类的，参考性能与时间戳 ，很多属性可以指定。 时间戳根据成员的配置情况，HBase的值可以是以多版本的方式保存。缺省情况下，HBase将每个新值的时间戳设置为当前时间 milliseconds，并且当一个 cell 被请求时，返回最新的版本。开发者可以在插入数据时自定义时间戳，然后再通过指定这个时间戳来重新获取该值。Family Attributes成员属性可以为每一个簇指定下面的属性：","categories":[{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/categories/HBase/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/tags/HBase/"},{"name":"数据模型","slug":"数据模型","permalink":"http://gmle.github.io/tags/数据模型/"}]},{"title":"HBase的Java API","slug":"HBase的JavaAPI详解","date":"2017-05-03T06:37:57.000Z","updated":"2017-05-03T06:37:57.000Z","comments":true,"path":"2017/05/03/HBase的JavaAPI详解/","link":"","permalink":"http://gmle.github.io/2017/05/03/HBase的JavaAPI详解/","excerpt":"HBase的常用Java API","text":"HBase的常用Java API HBase常用操作：List；Create；Put；Scan；Get；Delete；Disable；Drop； Java API的HBase操作实现可以查看前面几篇文章了解下HBase的体系结构和HBase数据视图。 连接HBase，配置必要的配置文件HBaseConfiguration是每一个hbase client都会使用到的对象，它代表的是HBase配置信息。它有两种构造方式：12public HBaseConfiguration()public HBaseConfiguration(final Configuration c) 默认的构造方式会尝试从hbase-default.xml和hbase-site.xml中读取配置。也可以指定位置去读取1234public static Configuration config = new Configuration(); static &#123; config.addResource(\"/conf/hbase-site.xml\"); &#125; 如果classpath没有这两个文件，就需要你自己设置配置。 123456Configuration config = new Configuration();config.set(“hbase.zookeeper.quorum”, “zkServer”);config.set(“hbase.zookeeper.property.clientPort”, “2181″);\\iguration config = new HBaseConfiguration(config); 建表首先加入配置文件 创建表是通过HBaseAdmin对象来操作的。HBaseAdmin负责表的META信息处理。HBaseAdmin提供了createTable这个方法： 1public void createTable(HTableDescriptor desc) HTableDescriptor 代表的是表的schema, 提供的方法中比较有用的有setMaxFileSize，指定最大的region size setMemStoreFlushSize 指定memstore flush到HDFS上的文件大小 增加列簇，也就是增加family。通过 addFamily方法1public void addFamily(final HColumnDescriptor family) HColumnDescriptor 代表的是column的schema，提供的方法比较常用的有 setTimeToLive:指定最大的TTL,单位是ms,过期数据会被自动删除。 setInMemory:指定是否放在内存中，对小表有用，可用于提高效率。默认关闭 setBloomFilter:指定是否使用BloomFilter,可提高随机查询效率。默认关闭 setCompressionType:设定数据压缩类型。默认无压缩。 setMaxVersions:指定数据最大保存的版本个数。默认为3。 简单的例子–&gt; 创建含有两个列簇的表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.lesion.MyPractice;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.HColumnDescriptor;import org.apache.hadoop.hbase.HTableDescriptor;import org.apache.hadoop.hbase.client.HBaseAdmin;import java.io.IOException;/** * Created in Intellij IDEA . * Author: 王乐. * Date : 16-5-4. */public class Create &#123; //定义静态常量 public static Configuration config = new Configuration(); static &#123; config.addResource(\"/conf/hbase-site.xml\"); &#125; public static void createTable(String tableName)&#123; System.out.println(\"开始建表\"); try &#123; HBaseAdmin admin = new HBaseAdmin(config); //如果创建的这个表存在的话，删除此表 if (admin.tableExists(tableName)) &#123; //禁用此表 admin.disableTable(tableName); //删除这个表 System.out.println(\"表已经存在，开始删除这个存在的表...\"); admin.deleteTable(tableName); System.out.println(\"删除表 \"+tableName+\" 成功！\"); &#125; //对象：列族（Column Family) HTableDescriptor tableDescriptor = new HTableDescriptor(tableName); tableDescriptor.addFamily(new HColumnDescriptor(\"info\")); tableDescriptor.addFamily(new HColumnDescriptor(\"message\")); //创建含有两个列簇的表 admin.createTable(tableDescriptor); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(\"Not Found config\"); &#125; &#125; public static void main(String[] args) &#123; createTable(\"mytable\"); &#125;&#125; 删除表删除表也是通过HBaseAdmin来操作。删除表之前首先要disable表。这是一个非常耗时的操作，所以不建议频繁删除表。删除表之前要先禁用这个表：方法：disableTable然后进行删除操作：方法:delete 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.lesion.operateTable;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.MasterNotRunningException;import org.apache.hadoop.hbase.ZooKeeperConnectionException;import org.apache.hadoop.hbase.client.HBaseAdmin;import java.io.IOException;/** * Created in Intellij IDEA . * Author : 王乐. * Date : 2016.05.03.21. */public class Drop_Table &#123; private static Configuration config = new Configuration(); //Loading configuration files on startup！ static &#123; //add Create_Table config config.addResource(\"/conf/hbase-site.xml\"); &#125; public static void main(String[] args) &#123; dropTable(\"hbase_test1\"); &#125; /** * According to table's name to Drop table * @param tableName */ public static void dropTable(String tableName) &#123; try &#123; HBaseAdmin admin = new HBaseAdmin(config); System.out.println(\"Deleting “ \" + tableName + \" ”...\"); admin.disableTable(tableName); admin.deleteTable(tableName); System.out.println(\"Table“ \" + tableName + \" ”delete success\"); &#125; catch (MasterNotRunningException e) &#123; System.out.println(\"HBase service no start！\"); &#125; catch (ZooKeeperConnectionException e) &#123; System.out.println(\"Not connected to zookeeper!\"); &#125; catch (IOException e) &#123; System.out.println(\"Not found config!\");; &#125; &#125;&#125; 查询数据查询分为单条随机查询和批量查询。 单条查询是通过rowkey在table中查询某一行的数据。HTable提供了get方法来完成单条查询。 批量查询是通过制定一段rowkey的范围来查询。HTable提供了个getScanner方法来完成批量查询。 12public Result get(final Get get)public ResultScanner getScanner(final Scan scan) Get对象包含了一个Get查询需要的信息。它的构造方法有两种： 12public Get(byte [] row)public Get(byte [] row, RowLock rowLock) Rowlock是为了保证读写的原子性，你可以传递一个已经存在Rowlock，否则HBase会自动生成一个新的rowlock。 Scan对象提供了默认构造函数，一般使用默认构造函数。 setMaxVersions:指定最大的版本个数。如果不带任何参数调用setMaxVersions,表示取所有的版本。如果不掉用setMaxVersions,只会取到最新的版本。 setTimeRange:指定最大的时间戳和最小的时间戳，只有在此范围内的cell才能被获取。 setTimeStamp:指定时间戳。 setFilter:指定Filter来过滤掉不需要的信息 Scan特有的方法： setStartRow:指定开始的行。如果不调用，则从表头开始。 setStopRow:指定结束的行（不含此行）。 setBatch:指定最多返回的Cell数目。用于防止一行中有过多的数据，导致OutofMemory错误。 ResultScanner是Result的一个容器，每次调用ResultScanner的next方法，会返回Result.12public Result next() throws IOException;public Result [] next(int nbRows) throws IOException; Result代表是一行的数据。常用方法有： getRow:返回rowkey raw:返回所有的key value数组。 getValue:按照column来获取cell的值 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package cn.lesion.operateTable;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.KeyValue;import org.apache.hadoop.hbase.client.*;import org.apache.hadoop.hbase.filter.CompareFilter.CompareOp;import org.apache.hadoop.hbase.filter.Filter;import org.apache.hadoop.hbase.filter.FilterList;import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;import org.apache.hadoop.hbase.util.Bytes;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created in Intellij IDEA . * Author : 王乐. * Date : 2016.05.03.21. */public class Query_Data &#123; private static Configuration config = new Configuration(); //Loading configuration files on startup！ static &#123; //add Create_Table config config.addResource(\"/conf/hbase-site.xml\"); &#125; public static void main(String[] args) &#123; // QueryAll(\"hbase_test\"); // QueryByRowKey(\"hbase_test\"); // QueryByCondition(\"hbase_test\"); QueryByMultiCondition(\"hbase_test\"); &#125; /** * Query all data * @param tableName */ public static void QueryAll(String tableName) &#123; HTablePool pool = new HTablePool(config, 1000); HTableInterface table = pool.getTable(tableName); try &#123; ResultScanner rs = table.getScanner(new Scan()); for (Result r : rs) &#123; System.out.println(\"get the rowkey:\" + new String(r.getRow())); for (KeyValue keyValue : r.raw()) &#123; System.out.println(\"列：\" + new String(keyValue.getFamily()) + \"====value:\" + new String(keyValue.getValue())); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 单条件查询,根据rowkey查询唯一一条记录 * Single condition query,According to rowkey query data * @param tableName */ public static void QueryByRowKey(String tableName) &#123; HTablePool pool = new HTablePool(config, 1000); HTableInterface table = pool.getTable(tableName); try &#123; // Add the rowkey or Can be defined in the parameter Get scan = new Get(\"112233bbbcccc\".getBytes());// 根据rowkey查询 Result r = table.get(scan); System.out.println(\"获得到rowkey:\" + new String(r.getRow())); for (KeyValue keyValue : r.raw()) &#123; System.out.println(\"列：\" + new String(keyValue.getFamily()) + \"====值:\" + new String(keyValue.getValue())); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 单条件查询，查询多条记录 * Single condition query, query multiple records * @param tableName */ public static void QueryByCondition(String tableName) &#123; try &#123; HTablePool pool = new HTablePool(config, 1000); HTableInterface table = pool.getTable(tableName); // 当列column1的值为aaa时进行查询 //Query when the value of the column column1 is aaa Filter filter = new SingleColumnValueFilter(Bytes .toBytes(\"column1\"), null, CompareOp.EQUAL, Bytes .toBytes(\"aaa\")); Scan s = new Scan(); s.setFilter(filter); ResultScanner rs = table.getScanner(s); for (Result r : rs) &#123; System.out.println(\"Get rowkey:\" + new String(r.getRow())); for (KeyValue keyValue : r.raw()) &#123; System.out.println(\"column：\" + new String(keyValue.getFamily()) + \"====value:\" + new String(keyValue.getValue())); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 组合条件查询 * Combination condition query * @param tableName */ public static void QueryByMultiCondition(String tableName) &#123; try &#123; HTablePool pool = new HTablePool(config, 1000); HTableInterface table = pool.getTable(tableName); List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); Filter filter1 = new SingleColumnValueFilter(Bytes .toBytes(\"column1\"), null, CompareOp.EQUAL, Bytes .toBytes(\"aaa\")); filters.add(filter1); Filter filter2 = new SingleColumnValueFilter(Bytes .toBytes(\"column2\"), null, CompareOp.EQUAL, Bytes .toBytes(\"bbb\")); filters.add(filter2); Filter filter3 = new SingleColumnValueFilter(Bytes .toBytes(\"column3\"), null, CompareOp.EQUAL, Bytes .toBytes(\"ccc\")); filters.add(filter3); FilterList filterList1 = new FilterList(filters); Scan scan = new Scan(); scan.setFilter(filterList1); ResultScanner rs = table.getScanner(scan); for (Result r : rs) &#123; System.out.println(\"Get rowkey:\" + new String(r.getRow())); for (KeyValue keyValue : r.raw()) &#123; System.out.println(\"column：\" + new String(keyValue.getFamily()) + \"====value:\" + new String(keyValue.getValue())); &#125; &#125; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 插入数据HTable通过put方法来插入数据。 12public void put(final Put put) throws IOExceptionpublic void put(final List puts) throws IOException 可以传递单个批Put对象或者List put对象来分别实现单条插入和批量插入。 Put提供了3种构造方式： 123public Put(byte [] row)public Put(byte [] row, RowLock rowLock)public Put(Put putToCopy) Put常用的方法有： add:增加一个Cell setTimeStamp:指定所有cell默认的timestamp,如果一个Cell没有指定timestamp,就会用到这个值。如果没有调用，HBase会将当前时间作为未指定timestamp的cell的timestamp. setWriteToWAL: WAL是Write Ahead Log的缩写，指的是HBase在插入操作前是否写Log。默认是打开，关掉会提高性能，但是如果系统出现故障(负责插入的Region Server挂掉)，数据可能会丢失。 另外HTable也有两个方法也会影响插入的性能 setAutoFlash: AutoFlush指的是在每次调用HBase的Put操作，是否提交到HBase Server。默认是true,每次会提交。如果此时是单条插入，就会有更多的IO,从而降低性能. setWriteBufferSize: Write Buffer Size在AutoFlush为false的时候起作用，默认是2MB,也就是当插入数据超过2MB,就会自动提交到Server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.lesion.operateTable;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.client.HTable;import org.apache.hadoop.hbase.client.HTableInterface;import org.apache.hadoop.hbase.client.HTablePool;import org.apache.hadoop.hbase.client.Put;import java.io.IOException;/** * Created in Intellij IDEA . * Author : 王乐. * Date : 2016.05.03.19. */public class Insert_Data &#123; private static Configuration config = new Configuration(); //Loading configuration files on startup！ static &#123; //add Create_Table config config.addResource(\"/conf/hbase-site.xml\"); &#125; public static void main(String[] args) &#123; // Create a new table named is 'abc' insertData(\"mytest\"); &#125; /** * According to tableName to insert data * @param tableName */ private static void insertData(String tableName) &#123; System.out.println(\"start insert data ......\"); HTablePool pool = new HTablePool(config, 1000); //Not Mandatory conversion to HTable pool.getable return HTableInterface HTableInterface table = pool.getTable(tableName); // 一个PUT代表一行数据，再NEW一个PUT表示第二行数据,每行一个唯一的ROWKEY，此处rowkey为put构造方法中传入的值 // one put == a row data, if new a 'put' it's a second row data // This rowkey is unique. Put put = new Put(\"1\".getBytes()); // 本行数据的第一列 // first data --&gt; first column put.addColumn(\"name\".getBytes(), null, \"王乐\".getBytes()); // 本行数据的第三列 // second column put.addColumn(\"age\".getBytes(), null, \"19\".getBytes()); // 本行数据的第三列 // third column put.addColumn(\"sex\".getBytes(), null, \"男\".getBytes()); try &#123; table.put(put); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"end insert data ......\"); &#125;&#125; 删除数据HTable 通过delete方法来删除数据。1public void delete(final Delete delete) Delete构造方法有： 123public Delete(byte [] row)public Delete(byte [] row, long timestamp, RowLock rowLock)public Delete(final Delete d) Delete常用方法有 deleteFamily/deleteColumns:指定要删除的family或者column的数据。如果不调用任何这样的方法，将会删除整行。 注意：如果某个Cell的timestamp高于当前时间，这个Cell将不会被删除，仍然可以查出来。 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.lesion.operateTable;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.client.Delete;import org.apache.hadoop.hbase.client.HTable;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created in Intellij IDEA . * Author : 王乐. * Date : 2016.05.03.21. */public class Delete_Data &#123; private static Configuration config = new Configuration(); //Loading configuration files on startup！ static &#123; //add Create_Table config config.addResource(\"/conf/hbase-site.xml\"); &#125; public static void main(String[] args) &#123; deleteRow(\"hbase_test\",\"1\"); &#125; /** * According to table's rowkey to delete data * @param tablename * @param rowkey */ public static void deleteRow(String tablename, String rowkey) &#123; try &#123; HTable table = new HTable(config, tablename); List&lt;Delete&gt; list = new ArrayList&lt;Delete&gt;(); Delete d1 = new Delete(rowkey.getBytes()); list.add(d1); table.delete(list); System.out.println(\"Delete row success!\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 切分表HBaseAdmin提供split方法来将table 进行split. 1public void split(final String tableNameOrRegionName) 如果提供的tableName，那么会将table所有region进行split ;如果提供的region Name，那么只会split这个region. 由于split是一个异步操作，我们并不能确切的控制region的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void split(String tableName,int number,int timeout) throws Exception &#123; private static Configuration config = new Configuration(); //Loading configuration files on startup！ static &#123; //add Create_Table config config.addResource(\"/conf/hbase-site.xml\"); &#125; HBaseAdmin hAdmin = new HBaseAdmin(config); HTable hTable = new HTable(config,tableName); int oldsize = 0; t = System.currentTimeMillis(); while(true)&#123; int size = hTable.getRegionsInfo().size(); logger.info(“the region number=”+size); if(size&gt;=number ) break; if(size!=oldsize)&#123; hAdmin.split(hTable.getTableName()); oldsize = size; &#125; else if(System.currentTimeMillis()-t&gt;timeout)&#123; break; &#125; Thread.sleep(1000*10); &#125;&#125;","categories":[{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/categories/HBase/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/tags/HBase/"},{"name":"Java","slug":"Java","permalink":"http://gmle.github.io/tags/Java/"},{"name":"API","slug":"API","permalink":"http://gmle.github.io/tags/API/"}]},{"title":"HBase入门 — 操作数据表","slug":"HBase入门_操作数据","date":"2017-05-03T06:37:52.000Z","updated":"2017-05-03T06:37:52.000Z","comments":true,"path":"2017/05/03/HBase入门_操作数据/","link":"","permalink":"http://gmle.github.io/2017/05/03/HBase入门_操作数据/","excerpt":"HBase中数据表的增删改查 其实底层还是最普通的MR(MapReduce)操作。 Source源码地址 GitHub/hbase","text":"HBase中数据表的增删改查 其实底层还是最普通的MR(MapReduce)操作。 Source源码地址 GitHub/hbase Compile environmentOracle JDK_1.8 create table:Position: cn.lesion.operateTable.Create_Table;123public class Create_Table &#123; ...&#125; drop tablePosition: cn.lesion.operateTable.Drop_Table;123public class Drop_Table &#123; ...&#125; delete dataPosition: cn.lesion.operateTable.Delete_Data;123public class Delete_Data &#123; ...&#125; Insert DataPosition: cn.lesion.operateTable.Insert_Data;123public class Insert_Data &#123; ...&#125; Query DataPosition: cn.lesion.operateTable.Query_Data;123public class Query_Data &#123; ...&#125;","categories":[{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/categories/HBase/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HBase","slug":"HBase","permalink":"http://gmle.github.io/tags/HBase/"},{"name":"CRUD","slug":"CRUD","permalink":"http://gmle.github.io/tags/CRUD/"}]},{"title":"Hadoop_对HDFS中文件的操作","slug":"HDFS的文件操作","date":"2017-05-03T06:37:48.000Z","updated":"2017-05-03T06:37:48.000Z","comments":true,"path":"2017/05/03/HDFS的文件操作/","link":"","permalink":"http://gmle.github.io/2017/05/03/HDFS的文件操作/","excerpt":"Hadoop没有当前目录的概念，当然也就没有 “cd” 命令 HDFS文件操作的方法。 命令行方式上一篇文章已经写到命令行方式操作HDFS，不再多说。进入传送门～","text":"Hadoop没有当前目录的概念，当然也就没有 “cd” 命令 HDFS文件操作的方法。 命令行方式上一篇文章已经写到命令行方式操作HDFS，不再多说。进入传送门～ 根据上一篇文章，写入两个文件：Web查看文件的方式：text1 : hello world.text2 : hello hadoop. Java API操作HDFS新建一个Maven项目，不再细说1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.lesion&lt;/groupId&gt; &lt;artifactId&gt;bigData&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- log4j日志包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.0-beta9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Hadoop开发包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-core&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建一个类，写入如下代码：123456789101112131415161718192021222324252627282930package cn.lesion.data;/** * Created in Intellij IDEA . * Author : 王乐. * Date : 2016.04.19.20. * * 说明：读取hdfs中的文件内容 */import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;import java.io.InputStream;import java.net.URI;public class Hello &#123; public static void main(String[] args) throws Exception &#123; //hdfs的地址 String uri = \"hdfs://lele:9000/\"; Configuration config = new Configuration(); FileSystem fs = FileSystem.get(URI.create(uri), config); // 显示在hdfs的/tmp/input下指定文件的内容 InputStream is = fs.open(new Path(\"/user/test1.txt\")); IOUtils.copyBytes(is, System.out, 1024, true); &#125;&#125; 运行之后：Hello","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"http://gmle.github.io/tags/HDFS/"},{"name":"HDFS操作","slug":"HDFS操作","permalink":"http://gmle.github.io/tags/HDFS操作/"}]},{"title":"Hadoop与HDFS的一些常用命令","slug":"HSFS中文件的一些操作命令","date":"2017-05-03T06:37:41.000Z","updated":"2017-05-03T06:37:41.000Z","comments":true,"path":"2017/05/03/HSFS中文件的一些操作命令/","link":"","permalink":"http://gmle.github.io/2017/05/03/HSFS中文件的一些操作命令/","excerpt":"Hadoop与HDFS文件操作的一些常用命令，记个笔记。 Hadoop启动","text":"Hadoop与HDFS文件操作的一些常用命令，记个笔记。 Hadoop启动 12sudo ./sbin/start-dfs.shsudo ./sbin/start-yarn.sh 启动之后的访问地址查看任务的运行情况http://localhost:8088/ 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。http://localhost:50070 HDFS命令查看HDFS基本统计信息1sudo ./bin/hdfs dfsadmin -report 格式化namenode1sudo ./bin/hdfs namenode -format HSFS文件操作列出跟目录下所有的文件1sudo ./bin/hdfs dfs -ls / path1sudo ./bin/hdfs dfs -rm -r /path 增加一个path目录1sudo ./bin/hdfs dfs -mkdir /path 列出跟目录下所有的文件1sudo ./bin/hdfs dfs -ls / 递归显示path下的所有文件1sudo ./bin/hdfs dfs -lsr /path 将本地文件或目录localSrc上传到HDFS中的dest路径1sudo ./bin/hdfs dfs –put /localSrc /dest 与-put命令相同1sudo ./bin/hdfs dfs –copyFromLocal /localSrc /dest 显示文件内容到标准输出上。1sudo ./bin/hdfs dfs –cat /filename","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"http://gmle.github.io/tags/HDFS/"},{"name":"常用命令","slug":"常用命令","permalink":"http://gmle.github.io/tags/常用命令/"}]},{"title":"MacOS下配置Hadoop和Spark","slug":"MacOS安装Hadoop&Spark","date":"2017-05-03T06:37:38.000Z","updated":"2017-05-03T06:37:38.000Z","comments":true,"path":"2017/05/03/MacOS安装Hadoop&Spark/","link":"","permalink":"http://gmle.github.io/2017/05/03/MacOS安装Hadoop&Spark/","excerpt":"首先，准备MacOS环境略过Java、Scala、Python的环境安装，从Hadoop和Spark说起","text":"首先，准备MacOS环境略过Java、Scala、Python的环境安装，从Hadoop和Spark说起 安装Hadoop安装Hadoop，最简单的安装方式：1brew install hadoop 找到安装目录安装完成后，找到Hadoop配置文件目录： 1cd /usr/local/Cellar/hadoop/2.7.3/libexec/etc/hadoop 修改core-site.xml12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/Cellar/hadoop/2.7.3/libexec/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:8020&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改hdfs-site.xml1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/Cellar/hadoop/2.7.3/libexec/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/Cellar/hadoop/2.7.3/libexec/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 添加环境变量123#Hadoop environment configs export HADOOP_HOME=/usr/local/Cellar/hadoop/2.7.3/libexec export PATH=$PATH:$&#123;HADOOP_HOME&#125;/bin 格式化HDFS12cd /usr/local/Cellar/hadoop/2.7.3/bin ./hdfs namenode -format 启动Hadoop12cd /usr/local/Cellar/hadoop/2.7.3/sbin ./start-all.sh 在终端输入 jps 查看java进程1231206 DataNode 1114 NameNode 1323 SecondaryNameNode 安装SparkSpark的安装也是使用 brew1brew install apache-spark 找到安装目录找到Spark配置文件目录1cd /usr/local/Cellar/apache-spark/2.1.0/libexec/conf 修改spark-env.sh1234cp spark-env.sh.template spark-env.shvi spark-env.shexport SPARK_HOME=/usr/local/Cellar/apache-spark/2.1.0/libexec export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home 加入环境变量12export SPARK_HOME=/usr/local/Cellar/apache-spark/2.1.0/libexec export PATH=$PATH:$&#123;SPARK_HOME&#125;/bin 启动Spark12cd /usr/local/Cellar/apache-spark/1.6.0/bin ./start-all.sh 查看进程12345678910jps6052 Worker6022 Master6728 Jps5546 NameNode5739 SecondaryNameNode5947 NodeManager5630 DataNode5855 ResourceManager 配置Pycharm开发spark应用打开Pycharm（我的python版本是2.7）新建xxxx，新建类：一个简单的wordcount12345678910from pyspark import SparkContextlogFile = \"/Users/admin/Desktop/BackUp\"sc = SparkContext(\"local\",\"Simple App\")logData = sc.textFile(logFile).cache()numAs = logData.filter(lambda s: 'a' in s).count()numBs = logData.filter(lambda s: 'b' in s).count()print(\"Lines with a: %i, lines with b: %i\"%(numAs, numBs)) F4打开当前可运行代码的配置项Environment Variables 选项填写：1PYTHONPATH /usr/local/Cellar/apache-spark/2.1.0/libexec/python 至此，环境完成。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://gmle.github.io/categories/MacOS/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"MacOS","slug":"MacOS","permalink":"http://gmle.github.io/tags/MacOS/"},{"name":"Spark","slug":"Spark","permalink":"http://gmle.github.io/tags/Spark/"}]},{"title":"MapReduce架构及原理","slug":"MapReduce架构原理","date":"2017-05-03T06:37:15.000Z","updated":"2017-05-03T06:37:15.000Z","comments":true,"path":"2017/05/03/MapReduce架构原理/","link":"","permalink":"http://gmle.github.io/2017/05/03/MapReduce架构原理/","excerpt":"Hadoop中MapReduce的架构以及原理。 MapReduce介绍 MapReduce 编程模型 Google提出的框架 主要用于搜索领域 一种分布式计算模型框架解决海量数据的计算问题 MapReduce将整个并行计算过程抽象到两个函数 map（映射）：对一些独立元素组成的列表的每一个元素进行指定的操作，可以高度并行 Reduce（化简）：队一个列表的元素进行合并 一个简单的MapReduce程序只需要指定map()、reduce()、input和output，剩下的事由框架来执行。","text":"Hadoop中MapReduce的架构以及原理。 MapReduce介绍 MapReduce 编程模型 Google提出的框架 主要用于搜索领域 一种分布式计算模型框架解决海量数据的计算问题 MapReduce将整个并行计算过程抽象到两个函数 map（映射）：对一些独立元素组成的列表的每一个元素进行指定的操作，可以高度并行 Reduce（化简）：队一个列表的元素进行合并 一个简单的MapReduce程序只需要指定map()、reduce()、input和output，剩下的事由框架来执行。 MapReduce特点- 高容错 - 高扩展 - 编程简单 - 适合大数据离线批量处理 Map任务处理* 读取输入文件内容，解析成key，value对。对输入文件的没一行，解析成key，value对。每一个键值对调用一次map函数 * 写自己的逻辑，处理输入的key，value，转换成新的key，value输出 * 对输出的key、value进行分区 * 对不同分区的数据，按照key进行排序】分组。相同的key的value放到一个集合中。 reduce 任务处理* 对多个map任务的输出，按照不用的分区，通过网络copy到不同的reduce节点 * 对多个map任务的输出进行合并、排序。写reduce函数自己的逻辑，对哦输入的key、value处理，转换成新的key、value输出。 * 把reduce的输出保存到文件中 MapReduce键值对格式：因为会有不同的结果，所以Reduce的 v2 会是数组的形式存储多个值。 MR过程中各个角色的作用：* jobClient：提交作业 * jobTracker：初始化作业，分配作业，TaskTracker与其进行通信，协调监控整个作业 * TaskTracker：定期与JobTracker通信，执行Map任务和Reduce任务 * HDFS：保存作业的数据、配置、jar包、结果等。 作业提交流程* 提交作业准备 * 编写自己的MR程序 * 配置作业，保罗输入输出路径等等 * 提交作业 *配置完成后，通过JobClient提交作业 * 具体功能 * 与JobTracker通信得到一个jar的存储路径和JobId * 输入输出路径检查、讲job jar拷贝到的HDFS * 写job.xml、真正提交作业。 作业初始化* 客户端提交作业后，jobTracker会讲作业加入到队列，然后进行调度，默认的是FIFO方式 * 具体功能 * 作业初始化主要是指 JobInProgress中完成的 * 读取分片信息 * 创建task包括Map和Reduce创建task包括Map和Reduce任务 ## 任务分配 * TaskTracker 与JobTracker之间的通信和任务分配是通过心跳机制实现的 * TaskTracker会主动定期向JobTracker发送报告 询问是否有任务要做， 如果有，就会申请到任务 任务执行* 如果TaskTracker拿到任务，会将所有信息拷贝到本地，包括代码、配置、分片信息等 * TarkTacker中的localizeJob()方法会被调用进行本地化，拷贝job.jar,jobconf.job.xml到本地 * TaskTracker调用launchTaskForJob()方法加载启动任务","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://gmle.github.io/tags/MapReduce/"},{"name":"架构","slug":"架构","permalink":"http://gmle.github.io/tags/架构/"},{"name":"原理","slug":"原理","permalink":"http://gmle.github.io/tags/原理/"}]},{"title":"Scala中的 Option、Some、None、Null、Nil、Nothing","slug":"Scala中的几个类型","date":"2017-05-03T06:37:09.000Z","updated":"2018-06-06T12:13:32.293Z","comments":true,"path":"2017/05/03/Scala中的几个类型/","link":"","permalink":"http://gmle.github.io/2017/05/03/Scala中的几个类型/","excerpt":"Scala的一些类型。","text":"Scala的一些类型。 Scala的Option类型：Option可以存储任意类型的值，而Option的实例就是 Some 和 None 对象实例。 Some 和 None 都是 Option 的子类，而且都是 final 类型，所以没有派生子类。 Option的数据存取Option的数据存取就是对 Some 对象的操作。 12345678910class optionTest extends TestCase&#123; val capitals = Map(\"france\" -&gt; \"paris\", \"japan\" -&gt; \"tokyo\") def test1() &#123; val a = capitals get \"france\" val b = capitals get \"a\" println(a) //Some（paris） println(b) //None &#125; 结果对象类型为Some或者None 当程序给你回传Some的时候，代表这个函数成功的给了你一个String， 而你可以通过get()函数拿到那个String； 如果程序返回的是None，也就是没有String返回的时候，如果还要调用，则会抛出异常：NoSuchElementExpection。 Scala的Null类型：Null是所有AnyRef的子类，在Scala的类型系统中，AnyRef是Any的子类，同是Any子类的还有AnyVal。 对应Java值类型的所有类型都是AnyVal的子类。 所以Null可以赋值给虽有的引用类型，而不能赋值给值类型，这个java的语义是相同的。 null是Null的唯一对象。 Scala的Nothing类型：Nothing是所有类型的子类，也是Null的子类，Nothing没有对象，但是可以用来定义类型。 例如，如果一个方法抛出异常，则异常的返回值类型就是Nothing（不会返回） 1234def get(index:Int):Int = &#123; if(x&lt;0) throw new Expection(...) else ...&#125; if是表达式，必然有返回值，返回值必然会有类型。 如果x&lt;0抛出异常，返回值的类型为Nothing，Nothing也是Int的子类， 所以，if表达式的返回类型为Int，get方法的返回值类型也为Int Scala的Nil类型：Nil是一个空List,定义为 List[Nothing]，根据List的定义 LIst[+A]，所有的Nil是虽有List[T]的子类。","categories":[{"name":"Scala","slug":"Scala","permalink":"http://gmle.github.io/categories/Scala/"}],"tags":[{"name":"Scala","slug":"Scala","permalink":"http://gmle.github.io/tags/Scala/"}]},{"title":"Hadoop_Yarn架构详解","slug":"Yarn架构详解","date":"2017-05-03T06:37:01.000Z","updated":"2017-05-03T06:37:01.000Z","comments":true,"path":"2017/05/03/Yarn架构详解/","link":"","permalink":"http://gmle.github.io/2017/05/03/Yarn架构详解/","excerpt":"Yarn架构概述 Yarn Shell操作 Yarn 高可用的配置 Yarn 架构概述* 直接源于MRv1的缺陷(原MapReduce框架的不足) * JobTracker是集群事务的集中处理点，存在单点故障(一个失败，全部受影响) * JobTracker需要完成的任务太多，既要维护job的状态又要维护job的task的状态，造成过多的资源消耗(扩展性受限)","text":"Yarn架构概述 Yarn Shell操作 Yarn 高可用的配置 Yarn 架构概述* 直接源于MRv1的缺陷(原MapReduce框架的不足) * JobTracker是集群事务的集中处理点，存在单点故障(一个失败，全部受影响) * JobTracker需要完成的任务太多，既要维护job的状态又要维护job的task的状态，造成过多的资源消耗(扩展性受限) * 在taskTracker端，用map/reduce task作为资源的表示过于简单，没有考虑到cpu、内存等资源情况，当把两个需要消耗大内存的task调度到一起，很容易出现OOM * 把资源强制划分为map/reduce slot,当只有map task时，reduce slot不能用；当只有reduce task时，map slot不能用，容易造成资源利用不足。(多计算框架各自为战，数据共享困难). Hadoop Yarn基本架构* Yarn 各模块组成 * ResourceManager * 处理客户端请求 * 启动/监控ApplicationMaster * 监控NodeManager * 资源分配与调度 * NodeManager * 单个节点上的资源管理 * 处理来自ResourceManager的名年龄 * 处理来自ApplicationMaster的命令 * ApplicationMaster * 数据切分 * 为应用程序申请资源，并分配给内部任务 * 任务监控与容错 * Yarn的容错 * ResourceManager * 存在单点故障 * 2.X版本基于ZooKeeper实现HA * NodeManager * 失败后，RM将失败任务告诉对应的AM * AM决定如何处理失败的任务 * ApplicationMaster * 失败后，由RM负责重启，AM需处理内部任务的容错问题 - Hadoop Yarn调度框架 * 双层电镀框架 * RM将资源分配给AM * AM讲资源进一步分配给各个Task * 基于资源预留的调度策略 * 资源不足时，会为Task预留，知道资源充足 * 与“all or nothing”策略不同（Apache Mesos） * HadoopYarn资源调度器 * 多类型资源调度 * 采用DRF算法 * 目前只支持CPU和内存两种资源 * 提供多种资源调度器 * FIFO：先进先出 * Fair Scheduler：公平调度器 * Capacity Scheduler：容量调度器 * 多租户资源调度器 * 支持资源按比例分配 * 支持层级队列划分方式 * 支持资源抢占 * Hadoop Yarn 的资源隔离方案 * 支持内存和CPU两种资源隔离 * 内存是一种 “决定生死`” 的资源(集群内存不够，内存一处，任务崩溃) * CPU是一种 “你更想快慢” 的资源 * 内存隔离 * 基于县城监控的方案 * 基于Cgroups的方案 * CPU隔离 * 默认不对CPu资源进行隔离 * 基于Cgroups的方案 * Hadoop Yarn资源调度语义 * 支持的语义 * 请求某个铁定节点/机架上的特定资源量 * 讲某些节点加入或移除黑名单，不再自己分配这些节点上的资源 * 请求归还某些资源 * 部支持的语义 * 请求任意节点/机架上的特定资源量 * 请求一组或几组符合某种特质的资源 * 超细粒度资源 * 动态调整Container资源 * 运行在Yarn上的计算框架 * 离线计算框架：MapReduce（处理海量数据） * DAG计算框架：Tez * 流式计算框架：Storm：（处理流式数据） * 内存计算框架：Spark（因为基于内存处理，所以特别快） * 图计算框架：Giraph、GraphLib 运行在Yarn上的计算框架(MapReduce, Spark)AM* 框架 * 离线计算框架：MapReduce（处理海量数据） * DAG计算框架：Tez * 流式计算框架：Storm：（处理流式数据） * 内存计算框架：Spark（因为基于内存处理，所以特别快） * 图计算框架：Giraph、GraphLib * Yarn应用程序类型 * 长应用程序 * Service、HTTP Server等 * 短应用程序 * MR job、Spark Job等。 Yarn 的发展前景* 服务自动化部署（集群一键安装） * 调度框架的完善 * 支持更多的资源类型（网络、磁盘等） * 支持更多的调度语义 * 长作业的在线升级 * storm的在吸纳升级 * Container资源动态调整 * 容错机制 * ResourceMapager自身容错 * NOdeManager宕机，任务不受影响 * ApplicationMaster个性化容错","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://gmle.github.io/tags/Hadoop/"},{"name":"Yarn","slug":"Yarn","permalink":"http://gmle.github.io/tags/Yarn/"}]}]}