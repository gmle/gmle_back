<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忘lele</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gmle.github.io/"/>
  <updated>2018-10-25T12:43:16.822Z</updated>
  <id>http://gmle.github.io/</id>
  
  <author>
    <name>忘了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL中各个容器实现的原理</title>
    <link href="http://gmle.github.io/2018/10/20/STL%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://gmle.github.io/2018/10/20/STL中各个容器的实现原理/</id>
    <published>2018-10-20T07:19:50.511Z</published>
    <updated>2018-10-25T12:43:16.822Z</updated>
    
    <content type="html"><![CDATA[<p>STL有7 种主要的容器：分别是：vector、list、deque、map、multimap、set、multiset。</p><a id="more"></a><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector是一个顺序容器，它是一个动态数组，并且它的内存段是连续的。<br>支持随机插入、删除、查找等操作。</p><p>vector是一个连续的内存空间，当插入元素并且内存空间不够的时候，它会开辟一个新的内存(新内存在较小容量的时候是以2倍方式扩容，越大则扩充的越少)，并将旧的数据复制到新的内存空间中，再在新的内存空间的后面添加新元素，并且释放旧的内存空间，然后由于新的内存空间的开辟，使得指向旧的内存空间地址的迭代器失效。</p><p>vector 中数据的随机存取效率很高，O(1)的时间的复杂度，但是在vector 中随机插入元素，需要移动的元素数量较多，效率比较低下。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是以键值对存储的关联容器，通过使用key值来查找/索引value值</p><p>关键字起到索引的作用，值则表示与索引相关联的数据。它的底层实现结构是红黑树，插入元素、删除元素等操作都在O(logN)的时间复杂度。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set也是关联容器，但et的元素不像map那样可以同时拥有实值(value)和键值(key),set元素的键值就是实值，实值就是键值。</p><p>set不允许两个元素有相同的键值。</p><p>并且所有元素都会根据元素的键值自动排序。</p><p>set 的底层实现结构也是红黑树，它同样支持高效的元素插入、元素删除等操作，并且set可以高效的查找元素是否存在。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL有7 种主要的容器：分别是：vector、list、deque、map、multimap、set、multiset。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="STL" scheme="http://gmle.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象</title>
    <link href="http://gmle.github.io/2018/10/18/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3/"/>
    <id>http://gmle.github.io/2018/10/18/C++面向对象的深层次理解/</id>
    <published>2018-10-18T12:37:22.933Z</published>
    <updated>2018-11-16T00:39:49.612Z</updated>
    
    <content type="html"><![CDATA[<p>对面向对象的含义，大概每个人都会有每个人的看法吧。</p><a id="more"></a><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>说道面向对象，最基本的应该都会说出 继承，多态。<br>而大多数人会加上封装(封装在C中也会用到，只不过C++体现的更加明显)</p><p>C++并不只是一种面向对象语言，它可以支持好几种编程风格，包含面向对象编程风格和泛型编程风格。</p><h2 id="封装，继承，多态"><a href="#封装，继承，多态" class="headerlink" title="封装，继承，多态"></a>封装，继承，多态</h2><p><strong><em>面向对象编程和泛型编程</em></strong></p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>可以使我们将对象的状态和处理这些状态的函数绑定在一起，将程序模块化</p><ul><li>封装的目标就是实现软件的高内聚，低耦合</li><li>对象的属性用变量定义，行为用方法定义</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>即拿到父类的相关属性由子类使用而不必再次定义。</p><ul><li>可以对父类的方法进行重写来更加符合特殊需求</li><li>继承是子类共享父类数据和方法的机制</li></ul><h5 id="派生类与虚函数-纯虚函数"><a href="#派生类与虚函数-纯虚函数" class="headerlink" title="派生类与虚函数/纯虚函数"></a>派生类与虚函数/纯虚函数</h5><p>基类中的虚函数被派生类继承过去之后，是希望派生类根据自己的实际需求进行重新定义，以实现特定的功能。</p><p>如果派生类没有重新定义基类中的某个虚函数，则在调用的时候会使用基类中定义的版本。</p><p>但如果基类存在纯虚函数(基类应称之为虚基类)，则会编译错误。</p><p>基类中被声明为虚函数，在派生类中也依然是虚函数。</p><p>派生类中函数的声明必须和基类中定义的方式完全匹配。</p><p>继承之后，在派生类中对纯虚函数进行重新定义，然后这个派生类才是我们常见的正常的类。</p><p>如果在派生类中没有对这个纯虚函数重新定义，那么这个派生类也将成为虚基类。</p><p>虚函数在派生类中是可以不重新被定义的，但是纯虚函数在派生类中必须得被重新定义。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在子类里面重新实现父类已有的方法，重新实现包含了重写和重载</p><ul><li>重写：覆盖写，将子类从父类继承下来的方法重新实现</li><li>重载：发生在同一个类中，相同方法名，不同形参，但返回值类型必须相同</li></ul><p>多态可以简单的理解为一个接口，多个方法<br>C++的多态是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义弗雷的做法称为override</p><h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><ul><li>可以使我们编写出一些函数和类</li><li>对没有定义的，没有关联的和未知的类型函数和对象进行操作</li><li>减少程序中耦合性和相互依赖型提供的一种独特方式</li><li>泛型编程-&gt;模板编程</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装是为了模块化（重用）；<br>继承是为了代码扩展和重用；<br>多态是为了接口重用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对面向对象的含义，大概每个人都会有每个人的看法吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux-shebang</title>
    <link href="http://gmle.github.io/2018/10/18/linux-shebang%E8%AF%A6%E8%A7%A3/"/>
    <id>http://gmle.github.io/2018/10/18/linux-shebang详解/</id>
    <published>2018-10-18T01:21:21.849Z</published>
    <updated>2018-10-18T01:27:21.434Z</updated>
    
    <content type="html"><![CDATA[<p>shebang 是linux shell脚本中的第一行的符号<br>即 “#!”</p><a id="more"></a><p>Shebang这个符号通常在Unix系统的脚本中第一行开头中写到，它指明了执行这个脚本文件的解释程序。</p><p>如果脚本文件中没有“#！”这一行，那么他执行时会默认使用当前shell去解释这个脚本（即$SHELL环境变量）。</p><p> 如果“#！”之后的解释程序是一个可执行文件，那么执行这个脚本是，他就会把文件名及其参数作为参数传给那个解释程序去执行。</p><p> 如果“#！”指定的解释程序没有可执行权限，则会报错“bad interpreter：Permission denied”（拒绝访问，也就是没有权限）。如果“#！”指定的解释程序不是一个可执行文件，那么指定的解释程序会被忽略，转而给当前的shell去执行这个脚本。</p><p> 如果“#！”指定的解释程序不存在，那么会报错“bad interpret ： No such file ordirectory”，注意：“#！”之后的解释程序，需要些其绝对路径（例如：/bin/bash）,他是不会自动到$PATH中寻找解释器的。</p><p> 当然，如果你使用的“bash test.sh”这样的命令来执行脚本，那么“#！”这一行将被忽略，解释器当然是用命令行中显示式指定的bash。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shebang 是linux shell脚本中的第一行的符号&lt;br&gt;即 “#!”&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gmle.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="http://gmle.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Terark面试</title>
    <link href="http://gmle.github.io/2018/10/16/%E5%A5%87%E7%AE%80%E4%BA%91%E4%B8%80%E9%9D%A2/"/>
    <id>http://gmle.github.io/2018/10/16/奇简云一面/</id>
    <published>2018-10-16T03:25:41.923Z</published>
    <updated>2018-10-16T10:48:12.278Z</updated>
    
    <content type="html"><![CDATA[<p>该公司主推数据库产品，所以招聘需求为算法岗。<br>面试过程中学到了很多(因为被虐很惨)。</p><a id="more"></a><h2 id="简单谈一下对数据库的认识"><a href="#简单谈一下对数据库的认识" class="headerlink" title="简单谈一下对数据库的认识"></a>简单谈一下对数据库的认识</h2><ul><li>数据库分为关系型和非关系型数据库</li><li>数据库是按照数据结构来组织、存储和管理数据的仓库</li><li>数据按照一定格式存放，数据大都持久化在磁盘</li><li>数据的共享性高、冗余度低，容易扩充</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>有一个坐标(x,y)(data)带了一个数据实现一个稀疏矩阵，现有两种存储方式供选择：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;pair&lt;x,y&gt;, data&gt;</span><br><span class="line"><span class="built_in">map</span>&lt;x,<span class="built_in">map</span>&lt;y, data&gt;&gt;</span><br></pre></td></tr></table></figure><p>据此计算出两者的时间复杂度。</p><p><img src="/images/terark/01_matrix.png" alt="(x,y)(data)所实现的稀疏矩阵"></p><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p>对于一维map，因为在索引data的时候可以直接查找x并判断y是否相等即可。<br>若存在条件 x&gt;y,则时间复杂度为 O(x);<br>若存在条件 x&lt;y,则时间复杂度为 O(y);</p><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>对于二维map，在索引data的时候，需要先找出x，再找出y，<br>所以时间复杂度应该为O(n²)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在数据足够多的情况下，一维的时间复杂度总是要比二维的时间复杂度小。</p><h2 id="map实现通讯录-国外-的存储方式"><a href="#map实现通讯录-国外-的存储方式" class="headerlink" title="map实现通讯录(国外)的存储方式"></a>map实现通讯录(国外)的存储方式</h2><p>通讯录面对国外用户，首先想到的应该是大小写字母和排序问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例：Jack Davied</span></span><br><span class="line"><span class="comment">// 排序问题需要map中的一个</span></span><br><span class="line"><span class="built_in">map</span>&lt;"JACK DAVIED", "Jack Davied"&gt;</span><br></pre></td></tr></table></figure><p>重载比较运算符进行排序</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该公司主推数据库产品，所以招聘需求为算法岗。&lt;br&gt;面试过程中学到了很多(因为被虐很惨)。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://gmle.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://gmle.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>fastDFS使用与介绍</title>
    <link href="http://gmle.github.io/2018/10/14/fastDFS/"/>
    <id>http://gmle.github.io/2018/10/14/fastDFS/</id>
    <published>2018-10-14T02:21:43.545Z</published>
    <updated>2018-10-15T07:31:52.866Z</updated>
    
    <content type="html"><![CDATA[<p>fastDFS是用c写的一款开源的分布式文件系统，可以很容易地搭建一套分布式文件系统。</p><a id="more"></a><h2 id="fastDFS中的三个角色"><a href="#fastDFS中的三个角色" class="headerlink" title="fastDFS中的三个角色"></a>fastDFS中的三个角色</h2><ul><li>追踪器(Tracker)-&gt;管理者：管理存储节点，类似于Hadoop中的namenode<ul><li>需要多个Tracker以避免单点故障</li><li>与Hadoop不同的是Tracker是以轮询的方式实现的</li></ul></li><li>存储节点(storage)-&gt;存储节点：存储数据，类似于Hadoop中的DataNode</li><li>(实现)客户端(client)-&gt;界面管理：上传下载功能的实现</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载 libfastcommon与fastdfs<br>安装过程相同：<br>​    先安装libfastcommon<br>​    ./make.sh &amp;&amp; ./make.sh install<br>​    再安装fastdfs<br>​    ./make.sh &amp;&amp; ./make.sh install</p><h2 id="工作顺序"><a href="#工作顺序" class="headerlink" title="工作顺序"></a>工作顺序</h2><ul><li>启动Tracker<ul><li>Tracker接收storage的心跳信息并与其建立映射</li></ul></li><li>启动storage<ul><li>单独开启一个线程<ul><li>汇报节点状态</li><li>汇报当前存储节点的磁盘信息</li><li>汇报数据同步情况</li><li>汇报数据被下载的次数</li></ul></li></ul></li><li>启动客户端<ul><li>上传<ul><li>连接Tracker，询问存储节点信息</li><li>Tracker查询符合上传文件大小的存储节点并返回节点信息</li><li>Tracker将节点信息返回给client</li><li>(集群)选择需要连接的Tracker</li><li>发送文件</li><li>选择存储的group</li><li>存储上传文件后返回的一个文件地址</li></ul></li><li>下载<ul><li>连接Tracker，查询文件所在节点</li><li>Tracker返回存储文件的节点信息，返回节点的ip:端口</li><li>(集群)选择需要连接的Tracker</li><li>下载文件</li></ul></li></ul></li></ul><h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>libfastcommon-1.36.zip（fastdfs的基础库包 ）</p><ul><li>unzip libfastcommon-1.36.zip </li><li>./make.sh </li><li>./make.sh install</li></ul><p>fastdfs-5.10.tar.gz<br>​    tar zxvf fastdfs-5.10.tar.gz<br>​    ./make.sh<br>​    ./make.sh install</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>fastDFS安装的所有的可执行程序: /usr/bin/fdfs_*</span><br><span class="line">fdfs_test</span><br></pre></td></tr></table></figure><h3 id="fastDFS配置文件"><a href="#fastDFS配置文件" class="headerlink" title="fastDFS配置文件"></a>fastDFS配置文件</h3><hr><p>配置文件默认位置: /etc/fdfs</p><ul><li>client.conf.sample</li><li>storage.conf.sample</li><li>storage_ids.conf.sample</li><li>tracker.conf.sample</li></ul><hr><h4 id="tracker-conf"><a href="#tracker-conf" class="headerlink" title="tracker.conf"></a>tracker.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将追踪器和部署的主机的IP地址进程绑定, 也可以不指定</span><br><span class="line"><span class="meta">#</span> 如果不指定, 会自动绑定当前主机IP, 如果是云服务器建议不要写 bind_addr=192.168.247.135</span><br><span class="line"><span class="meta">#</span> 追踪器监听的端口</span><br><span class="line">port=22122</span><br><span class="line"><span class="meta">#</span> 追踪器存储日志信息的目录, xxx.pid文件, 必须是一个存在的目录 base_path=/home/yuqing/fastdfs</span><br></pre></td></tr></table></figure><h4 id="storage-conf"><a href="#storage-conf" class="headerlink" title="storage.conf"></a>storage.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当前存储节点对应的主机属于哪一个组 group_name=group1</span><br><span class="line">  group_name=group1</span><br><span class="line"><span class="meta">#</span> 当前存储节点和所应该的主机进行IP地址的绑定, 如果不写, 有fastdfs自动绑定 bind_addr=</span><br><span class="line"><span class="meta">#</span> 存储节点绑定的端口</span><br><span class="line">port=23000</span><br><span class="line"><span class="meta">#</span> 存储节点写log日志的路径 base_path=/home/yuqing/fastdfs</span><br><span class="line"><span class="meta">#</span> 存储节点提供的存储文件的路径个数 store_path_count=2</span><br><span class="line"><span class="meta">#</span> 具体的存储路径 store_path0=/home/yuqing/fastdfs store_path1=/home/yuqing/fastdfs1</span><br><span class="line"><span class="meta">#</span> 追踪器的地址信息 tracker_server=192.168.247.135:22122 tracker_server=192.168.247.136:22122</span><br><span class="line">tracker_server=192.168.247.135:22122</span><br><span class="line">tracker_server=192.168.247.136:22122</span><br></pre></td></tr></table></figure><h4 id="client-conf"><a href="#client-conf" class="headerlink" title="client.conf"></a>client.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 客户端写log日志的目录</span><br><span class="line"><span class="meta">#</span> 该路径必须存在</span><br><span class="line"><span class="meta">#</span> 当前的用户对于该路径中的文件有读写权限</span><br><span class="line"><span class="meta">#</span> 当前用户robin</span><br><span class="line"><span class="meta">#</span> 指定的路径属于root base_path=/home/yuqing/fastdfs</span><br><span class="line"><span class="meta">#</span> 要连接的追踪器的地址信息 tracker_server=192.168.247.135:22122 tracker_server=192.168.247.136:22122</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><h4 id="tracker追踪器的启动"><a href="#tracker追踪器的启动" class="headerlink" title="tracker追踪器的启动"></a>tracker追踪器的启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动程序在 /usr/bin/fdfs_*</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">fdfs_trackerd 追踪器的配置文件(/etc/fdfs/tracker.conf)</span><br><span class="line"><span class="meta">#</span> 关闭</span><br><span class="line">fdfs_trackerd 追踪器的配置文件(/etc/fdfs/tracker.conf) stop</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">fdfs_trackerd 追踪器的配置文件(/etc/fdfs/tracker.conf) restart</span><br></pre></td></tr></table></figure><h4 id="storage存储节点的启动"><a href="#storage存储节点的启动" class="headerlink" title="storage存储节点的启动"></a>storage存储节点的启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">fdfs_storaged 存储节点的配置文件(/etc/fdfs/stroga.conf)</span><br><span class="line"><span class="meta">#</span> 关闭</span><br><span class="line">fdfs_storaged 存储节点的配置文件(/etc/fdfs/stroga.conf) stop</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">fdfs_storaged 存储节点的配置文件(/etc/fdfs/stroga.conf) restart</span><br></pre></td></tr></table></figure><h4 id="client客户端启动"><a href="#client客户端启动" class="headerlink" title="client客户端启动"></a>client客户端启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 上传</span><br><span class="line">fdfs_upload_file 客户端的配置文件(/etc/fdfs/client.conf) 要上传的文件</span><br><span class="line"><span class="meta">#</span> 得到的结果字符串: group1/M00/00/00/wKj3h1vC-PuAJ09iAAAHT1YnUNE31352.c</span><br><span class="line"><span class="meta">#</span> 下载</span><br><span class="line">fdfs_download_file 客户端的配置文件(/etc/fdfs/client.conf) 上传成功之后得到的字符串(fileID)</span><br></pre></td></tr></table></figure><h4 id="fastdfs状态检测"><a href="#fastdfs状态检测" class="headerlink" title="fastdfs状态检测"></a>fastdfs状态检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 检测命令</span><br><span class="line">fdfs_monitor /etc/fdfs/client.conf</span><br></pre></td></tr></table></figure><p>storage的七种状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:INIT:初始化，尚未得到同步已有数据的源服务器</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:WAIT_SYNC :等待同步，已得到同步已有数据的源服务器</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:SYNCING:同步中</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:DELETED:已删除，该服务器从本组中摘除</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:OFFLINE:离线</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:ONLINE:在线，尚不能提供服务</span><br><span class="line"><span class="meta">#</span> FDFS_STORAGE_STATUS:ACTIVE:在线，可以提供服务</span><br></pre></td></tr></table></figure><h2 id="fileID"><a href="#fileID" class="headerlink" title="fileID"></a>fileID</h2><p>file.md -&gt; group1/M00/00/00wKhS_VlrEf0AdIZyAAAJT0wCgr43848.md</p><ul><li>group1<ul><li>文件上传到的存储节点的哪个组</li><li>如果有多个组，组名是变化的</li></ul></li><li>M00<ul><li>虚拟目录</li><li>和存储节点的配置项映射<ul><li>store_path0=/home/yuqing/fastdfs/data -&gt; M00</li><li>store_path1=/home/yuqing/fastdfs1/data -&gt; M01</li></ul></li></ul></li><li>00/00<ul><li>实际路径</li><li>可变</li></ul></li><li>wKhS_VlrEfOAdIZyAAAJTOwCGr43848.md<ul><li>文件名包含的信息，</li><li>Base64编码，信息包括：<ul><li>源storage server ip地址</li><li>文件创建时间</li><li>文件大小</li><li>文件CRC32校验码<ul><li>循环冗余校验</li></ul></li><li>随机数</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fastDFS是用c写的一款开源的分布式文件系统，可以很容易地搭建一套分布式文件系统。&lt;/p&gt;
    
    </summary>
    
      <category term="fastDFS" scheme="http://gmle.github.io/categories/fastDFS/"/>
    
    
      <category term="fastDFS" scheme="http://gmle.github.io/tags/fastDFS/"/>
    
  </entry>
  
  <entry>
    <title>SSL秘钥协商过程</title>
    <link href="http://gmle.github.io/2018/09/19/SSL%E7%A7%98%E9%92%A5%E5%8D%8F%E5%95%86%E8%BF%87%E7%A8%8B/"/>
    <id>http://gmle.github.io/2018/09/19/SSL秘钥协商过程/</id>
    <published>2018-09-19T02:32:24.728Z</published>
    <updated>2018-09-20T02:21:52.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在SSL之前"><a href="#写在SSL之前" class="headerlink" title="写在SSL之前"></a>写在SSL之前</h2><p>加密必须要有明文，密文，加密算法。</p><a id="more"></a><h2 id="常见加密"><a href="#常见加密" class="headerlink" title="常见加密"></a>常见加密</h2><ul><li><p>对称加密-秘钥长度越长，加密效率越低，但是安全性高</p><ul><li>DES：已经被破解<ul><li>要求秘钥长度八字节</li><li>在对数据进行加密之前先对数据按每组八个字节进行分组，然后分段加密，最后在将每一段加密数据进行组合</li></ul></li><li>3DES：效率低<ul><li>秘钥疮毒24字节，内部会将秘钥分为三分</li><li>需要加密的数据线按每组8个字节进行分组，然后分别使用3份秘钥进行加密-&gt;解密-&gt;加密；</li><li>若三份秘钥都相同，加密成功。</li></ul></li><li>TAES<ul><li>使用最广泛的对称加密算法</li><li>16、24、32字节</li></ul></li><li>TDEA</li><li>……</li></ul></li><li><p>非对称加密-非对称加密对数据加密的效率低，但是加密的强度高</p><ul><li>RSA(数字签名和密钥交换)</li><li>ECC(椭圆曲线加密算法)</li></ul></li><li><p>Hash算法<br>不可逆，不用于加密，只用于计算，将任意长度的数据，生成一个固定长度的字符串</p></li><li>MD4/MD5<ul><li>散列值长度16、32字节</li></ul></li><li>SHA-1/2</li><li>…..</li></ul><h2 id="加密过程-摘自TSL协议"><a href="#加密过程-摘自TSL协议" class="headerlink" title="加密过程(摘自TSL协议)"></a>加密过程(摘自TSL协议)</h2><pre><code>Client                            ServerClientHello           --------&gt;                                  ServerHello                                  Certificate*                                  ServerKeyExchange*                                  CertificateRequest*                      &lt;--------   ServerHelloDoneCertificate*ClientKeyExchangeCertificateVerify*[ChangeCipherSpec]Finished              --------&gt;                                  [ChangeCipherSpec]                      &lt;--------   FinishedApplication Data      &lt;-------&gt;   Application Data</code></pre><p>简单的说便是：<br>SSL客户端在TCP链接建立之后，发起一个握手请求ClientHello，这个消息里面包含了自己可实现的加密算法列表和自己的相关信息；<br>SSL的服务器端会回应一个ServerHello，这里面确定了这次通信所需要的算法，然后发过去自己的证书（里面包含了身份和自己的公钥）。<br>Client在收到这个消息后会生成一个秘密消息，用SSL服务器的公钥加密后传过去，<br>SSL服务器端用自己的私钥解密后，会话密钥协商成功，<br>双方可以用同一份会话密钥来通信了。</p><p>如果上面的说明不够清晰，这里我们用个形象的比喻，我们假设A与B通信，A是SSL客户端，B是SSL服务器端，加密后的消息放在方括号[]里，以突出明文消息的区别。双方的处理动作的说明用圆括号（）括起。</p><p>A：我想和你安全的通话，我这里的对称加密算法有DES,RC5,密钥交换算法有RSA和DH，摘要算法有MD5和SHA。</p><p>B：我们用DES－RSA－SHA这对组合好了。<br>  这是我的证书，里面有我的名字和公钥，你拿去验证一下我的身份（把证书发给A）。<br>  目前没有别的可说的了。</p><p>A：（查看证书上B的名字是否无误，并通过手头早已有的CA的证书验证了B的证书的真实性，如果其中一项有误，发出警告并断开连接，这一步保证了B的公钥的真实性）<br>  （产生一份秘密消息，这份秘密消息处理后将用作加密密钥，加密初始化向量和hmac的密钥。将这份秘密消息-协议中称为 per_master_secret-用B的公钥加密，封装成称作ClientKeyExchange的消息。由于用了B的公钥，保证了第三方无法窃听）<br>  我生成了一份秘密消息，并用你的公钥加密了，给你（把ClientKeyExchange发给B）<br>  注意，下面我就要用加密的办法给你发消息了！<br>  （将秘密消息进行处理，生成加密密钥，加密初始化向量和hmac的密钥）<br>  [我说完了]</p><p>B：（用自己的私钥将ClientKeyExchange中的秘密消息解密出来，然后将秘密消息进行处理，生成加密密钥，加密初始化向量和hmac的密钥，这时双方已经安全的协商出一套加密办法了）<br>  注意，我也要开始用加密的办法给你发消息了！<br>  [我说完了]</p><p>A: [我的秘密是…]</p><p>B: [其它人不会听到的…]  </p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL是一个安全套接字层密码库，C语言实现。<br>主要提供于Internet上提供加密传输。</p><p>openssl提供了两种运行模式：交互模式/批处理模式</p><ul><li>直接输入openssl回车进入交互模式，输入带命令选项的openssl进入批处理模式。</li></ul><p>OpenSSL整个软件包大概可以分成三个主要的功能部分：密码算法库、SSL协议库以及应用程序。<br>OpenSSL的目录结构自然也是围绕这三个功能部分进行规划的。</p><h3 id="消息摘要算法应用"><a href="#消息摘要算法应用" class="headerlink" title="消息摘要算法应用"></a>消息摘要算法应用</h3><p>Example:消息摘要算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 用SHA1算法计算文件file.txt的哈西值，输出到<span class="built_in">stdout</span></span><br><span class="line">openssl dgst -sha1 file.txt</span><br><span class="line"></span><br><span class="line"># 用SHA1算法计算文件file.txt的哈西值，输出到文件digest.txt：</span><br><span class="line">openssl sha1 -out digest.txt file.txt</span><br><span class="line"></span><br><span class="line"># 用DSS1(SHA1)算法为文件file.txt签名，输出到文件dsasign.bin。签名的<span class="keyword">private</span> key必须为DSA算法产生的，保存在文件dsakey.pem中。</span><br><span class="line">openssl dgst -dss1 -sign dsakey.pem -out dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用dss1算法验证file.txt的数字签名dsasign.bin，验证的<span class="keyword">private</span> key为DSA算法产生的文件dsakey.pem。</span><br><span class="line">openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的<span class="keyword">private</span> key为RSA算法产生的文件rsaprivate.pem。</span><br><span class="line">openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt</span><br><span class="line"></span><br><span class="line"># 用sha1算法验证file.txt的数字签名rsasign.bin，验证的<span class="keyword">public</span> key为RSA算法生成的rsapublic.pem。</span><br><span class="line">openssl sha1 -verify rsapublic.pem -signature rsasign.bin file.txt</span><br></pre></td></tr></table></figure></p><h3 id="对称加密算法应用"><a href="#对称加密算法应用" class="headerlink" title="对称加密算法应用"></a>对称加密算法应用</h3><p>Example:对称加密算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#对称加密应用例子，用DES3算法的CBC模式加密文件plaintext.doc，加密结果输出到文件ciphertext.bin。</span><br><span class="line">openssl enc -des3 -salt -in plaintext.doc -out ciphertext.bin</span><br><span class="line"></span><br><span class="line"># 用DES3算法的OFB模式解密文件ciphertext.bin，提供的口令为trousers，输出到文件plaintext.doc。注意：因为模式不同，该命令不能对以上的文件进行解密。</span><br><span class="line">openssl enc -des-ede3-ofb -d -in ciphertext.bin -out plaintext.doc -pass pass:trousers</span><br><span class="line"></span><br><span class="line"># 用Blowfish的CFB模式加密plaintext.doc，口令从环境变量PASSWORD中取，输出到文件ciphertext.bin。</span><br><span class="line">openssl bf-cfb -salt -in plaintext.doc -out ciphertext.bin -pass env:PASSWORD</span><br><span class="line"></span><br><span class="line">#给文件ciphertext.bin用base64编码，输出到文件base64.txt。</span><br><span class="line">openssl base64 -in ciphertext.bin -out base64.txt</span><br></pre></td></tr></table></figure></p><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><p>Example:DSA<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生成<span class="number">1024</span>位DSA参数集，并输出到文件dsaparam.pem。</span><br><span class="line">openssl dsaparam -out dsaparam.pem <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 使用参数文件dsaparam.pem生成DSA私钥匙，采用<span class="number">3</span>DES加密后输出到文件dsaprivatekey.pem</span><br><span class="line">openssl gendsa -out dsaprivatekey.pem -des3 dsaparam.pem</span><br><span class="line"></span><br><span class="line"># 使用私钥匙dsaprivatekey.pem生成公钥匙，输出到dsapublickey.pem</span><br><span class="line">openssl dsa -in dsaprivatekey.pem -pubout -out dsapublickey.pem</span><br><span class="line"></span><br><span class="line"># 从dsaprivatekey.pem中读取私钥匙，解密并输入新口令进行加密，然后写回文件dsaprivatekey.pem</span><br><span class="line">openssl dsa -in dsaprivatekey.pem -out dsaprivatekey.pem -des3 -passin</span><br></pre></td></tr></table></figure></p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 产生<span class="number">1024</span>位RSA私匙，用<span class="number">3</span>DES加密它，口令为trousers，输出到文件rsaprivatekey.pem</span><br><span class="line">openssl genrsa -out rsaprivatekey.pem -passout pass:trousers -des3 <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># 从文件rsaprivatekey.pem读取私匙，用口令trousers解密，生成的公钥匙输出到文件rsapublickey.pem</span><br><span class="line">openssl rsa -in rsaprivatekey.pem -passin pass:trousers -pubout -out rsapubckey.pem</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem加密文件plain.txt，输出到文件cipher.txt</span><br><span class="line">openssl rsautl -encrypt -pubin -inkey rsapublickey.pem -in plain.txt -out cipher.txt</span><br><span class="line"></span><br><span class="line"># 使用私钥匙rsaprivatekey.pem解密密文cipher.txt，输出到文件plain.txt</span><br><span class="line">openssl rsautl -decrypt -inkey rsaprivatekey.pem -in cipher.txt -out plain.txt</span><br><span class="line"></span><br><span class="line"># 用私钥匙rsaprivatekey.pem给文件plain.txt签名，输出到文件signature.bin</span><br><span class="line">openssl rsautl -sign -inkey rsaprivatekey.pem -in plain.txt -out signature.bin</span><br><span class="line"></span><br><span class="line"># 用公钥匙rsapublickey.pem验证签名signature.bin，输出到文件plain.txt</span><br><span class="line">openssl rsautl -verify -pubin -inkey rsapublickey.pem -in signature.bin -out plain</span><br><span class="line"></span><br><span class="line"># 从X<span class="number">.509</span>证书文件cert.pem中获取公钥匙，用<span class="number">3</span>DES加密mail.txt，输出到文件mail.enc</span><br><span class="line">openssl smime -encrypt -in mail.txt -des3 -out mail.enc cert.pem</span><br><span class="line"></span><br><span class="line"># 从X<span class="number">.509</span>证书文件cert.pem中获取接收人的公钥匙，用私钥匙key.pem解密S/MIME消息mail.enc，结果输出到文件mail.txt</span><br><span class="line">openssl smime -decrypt -in mail.enc -recip cert.pem -inkey key.pem -out mail.txt</span><br><span class="line"></span><br><span class="line"><span class="meta"># cert.pem为X.509证书文件，用私匙key,pem为mail.txt签名，证书被包含在S/MIME消息中，输出到文件mail.sgn</span></span><br><span class="line">openssl smime -sign -in mail.txt -signer cert.pem -inkey key.pem -out mail.sgn</span><br><span class="line"></span><br><span class="line"># 验证S/MIME消息mail.sgn，输出到文件mail.txt，签名者的证书应该作为S/MIME消息的一部分包含在mail.sgn中</span><br><span class="line">openssl smime -verify -in mail.sgn -out mail.txt</span><br></pre></td></tr></table></figure><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/md5.h&gt; // md5 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMD5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> *result)</span> </span>&#123;</span><br><span class="line">    MD5_CTX ctx;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    MD5_Init(&amp;ctx);</span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    MD5_Update(&amp;ctx, str, <span class="built_in">strlen</span>(str)); <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> md[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    MD5_Final(md, &amp;ctx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;result[i * <span class="number">2</span>], <span class="string">"%02x"</span>, md[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">33</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getMD5(<span class="string">"hello, md5"</span>, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"md5 value: %s\n"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>此处两个示例，第一个不能在win下使用。</p><p>Example1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/hmac.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> key[] = <span class="string">"012345678"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * len);</span><br><span class="line"></span><br><span class="line">    HMAC_CTX ctx;</span><br><span class="line">    HMAC_CTX_init(&amp;ctx);</span><br><span class="line"></span><br><span class="line">    HMAC_Init_ex(&amp;ctx, key, (<span class="keyword">int</span>) <span class="built_in">strlen</span>(key), EVP_sha1(), <span class="literal">NULL</span>);</span><br><span class="line">    HMAC_Update(&amp;ctx, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) &amp;data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    HMAC_Final(&amp;ctx, result, &amp;len);</span><br><span class="line">    HMAC_CTX_cleanup(&amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HMAC digest: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) result[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Example2：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/hmac.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> key[] = <span class="string">"1999"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> data[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *md = <span class="built_in">malloc</span>(EVP_MAX_MD_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(md, <span class="number">0x00</span>, EVP_MAX_MD_SIZE);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len_md = <span class="keyword">sizeof</span>(md);</span><br><span class="line"></span><br><span class="line">    HMAC(EVP_sha1(), key, (<span class="keyword">int</span>) <span class="built_in">strlen</span>(key), (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) data, <span class="built_in">strlen</span>(data), md, &amp;len_md);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data = %s,len = %d\n"</span>, md, len_md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mdString[<span class="number">40</span>] = &#123;<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;mdString[i * <span class="number">2</span>], <span class="string">"%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) md[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HMAC digest: %s\n"</span>, mdString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在SSL之前&quot;&gt;&lt;a href=&quot;#写在SSL之前&quot; class=&quot;headerlink&quot; title=&quot;写在SSL之前&quot;&gt;&lt;/a&gt;写在SSL之前&lt;/h2&gt;&lt;p&gt;加密必须要有明文，密文，加密算法。&lt;/p&gt;
    
    </summary>
    
      <category term="SSL" scheme="http://gmle.github.io/categories/SSL/"/>
    
    
      <category term="C" scheme="http://gmle.github.io/tags/C/"/>
    
      <category term="SSL" scheme="http://gmle.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>结构体数据对齐详解</title>
    <link href="http://gmle.github.io/2018/09/18/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"/>
    <id>http://gmle.github.io/2018/09/18/结构体数据对齐/</id>
    <published>2018-09-18T06:46:21.626Z</published>
    <updated>2018-09-20T06:26:32.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>结构体数据对齐：指结构体内各个数据的内存地址的对齐<br><strong>在结构体中的第一个成员的首地址等于整个结构体的变量的首地址</strong><br>后面的成员地址随着它声明的首地址和实际占用的字节数递增。<br>而为了总的结构体大小对齐，会在结构体中插入一些没有实际意义的字符填充结构体</p><a id="more"></a><p>通俗点讲，计算机系统对基本类型的数据在内存中存放的位置有限制，系统会要求这些数据的首地址的值是某个数(这个数一般为4或者8的)的倍数，这就是所谓的内存对齐</p><p>而32位机器上默认的对齐模数一般为4，64位机上位8。</p><p>在结构体中，成员数据对齐满足以下规则：</p><ul><li>结构体重的第一个成员的首地址即时结构体变量的首地址。</li><li>结构体中的每一个成员的首地址相对于结构体IDE首地址的偏移量是该成员数据类型大小的整数倍。</li><li>结构体的总大小是对齐模数（对齐模数等于#pragma pack(n)所指定的n与结构体重最大数据类型的成员大小的最小值）的整数倍</li></ul><p>Example：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">One</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Two</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>struct</th><th>type</th><th>pack(4)</th><th>pack(8)</th></tr></thead><tbody><tr><td>one</td><td>double</td><td>8</td><td>8</td></tr><tr><td></td><td>char</td><td>1+3</td><td>1+3</td></tr><tr><td></td><td>int</td><td>4</td><td>4</td></tr><tr><td>result</td><td></td><td>16</td><td>16</td></tr><tr><td>two</td><td></td><td></td><td></td></tr><tr><td></td><td>char</td><td>1+3</td><td>1+7</td></tr><tr><td></td><td>double</td><td>8</td><td>8</td></tr><tr><td></td><td>int</td><td>4</td><td>4+4</td></tr><tr><td>result</td><td></td><td>16</td><td>24</td></tr></tbody></table><h2 id="进阶C"><a href="#进阶C" class="headerlink" title="进阶C++"></a>进阶C++</h2><h3 id="C-中的数据对齐"><a href="#C-中的数据对齐" class="headerlink" title="C++中的数据对齐"></a>C++中的数据对齐</h3><p>环境：macOS 11.13.6 64位<br>编译器：clang-902.0.39.2<br>系统int大小为4字节，指针大小为8字节。</p><h4 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><p>空类sizeof的结果为1，为什么不是0呢？因为C++标准规定两个不同实例的内存地址必须不同，所以用这一个字节来占用不同的内存地址，让空类的两个实例可以相互区分。</p><h4 id="单个数据类型"><a href="#单个数据类型" class="headerlink" title="单个数据类型"></a>单个数据类型</h4><p>大多数编译器支持空基类优化（Empty Base Class Optimization, EBCO），即从空基类中派生出来的类并不会增加1字节，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>sizeof(B)的结果为4而不是5或8。</p><h4 id="静态数据成员类型"><a href="#静态数据成员类型" class="headerlink" title="静态数据成员类型"></a>静态数据成员类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof 结果为4,静态数据成员被存放在类对象之外。</p><h4 id="带非虚函数成员的类"><a href="#带非虚函数成员的类" class="headerlink" title="带非虚函数成员的类"></a>带非虚函数成员的类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(D)结果为1，无论是普通成员函数还是静态成员函数都被存放在类对象之外。</p><h4 id="带虚函数成员的类"><a href="#带虚函数成员的类" class="headerlink" title="带虚函数成员的类"></a>带虚函数成员的类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(E)结果为8，带虚函数成员的类对象会包含一个指向该类的virtual table的指针。</p><h4 id="普通派生类"><a href="#普通派生类" class="headerlink" title="普通派生类"></a>普通派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> :</span> <span class="keyword">public</span> C &#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(G)的结果为8，派生类会存放基类中非静态数据成员(C中的a)的副本。</p><h4 id="基类带虚函数的派生类"><a href="#基类带虚函数的派生类" class="headerlink" title="基类带虚函数的派生类"></a>基类带虚函数的派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> :</span> <span class="keyword">public</span> E &#123;&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(H)结果为8，由于基类中带虚函数，派生类中也必须保存一个指向派生类的virtual table的指针。</p><h4 id="多重继承的派生类"><a href="#多重继承的派生类" class="headerlink" title="多重继承的派生类"></a>多重继承的派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E3</span> :</span><span class="keyword">public</span> E1, <span class="keyword">public</span> E2&#123;&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(E3)结果为16，子类中保存了两个virtual table的指针</p><h4 id="虚继承的派生类"><a href="#虚继承的派生类" class="headerlink" title="虚继承的派生类"></a>虚继承的派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H1</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H3</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> H1, <span class="keyword">public</span> <span class="keyword">virtual</span> H2&#123;&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(H3)的结果为16，是两个基类中的virtual table指针</p><h3 id="普通类的对齐规则"><a href="#普通类的对齐规则" class="headerlink" title="普通类的对齐规则"></a>普通类的对齐规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span>  b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(F)的结果为8而不是5，由于F的最大对齐值为4（int），因此a和b之间被补齐3字节。</p><h3 id="多重继承下的对齐规则"><a href="#多重继承下的对齐规则" class="headerlink" title="多重继承下的对齐规则"></a>多重继承下的对齐规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G1</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G3</span>:</span><span class="keyword">public</span> G1, <span class="keyword">public</span> G2&#123;&#125;;</span><br></pre></td></tr></table></figure><p>sizeof(G3)的结果为48，默认对齐模数为8的情况下<br>G1 = （8）+（4）+（8）+（8）<br>G2 = （4+4）+（1+7）+（8）<br>G3 = 48</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据对齐&quot;&gt;&lt;a href=&quot;#数据对齐&quot; class=&quot;headerlink&quot; title=&quot;数据对齐&quot;&gt;&lt;/a&gt;数据对齐&lt;/h2&gt;&lt;p&gt;结构体数据对齐：指结构体内各个数据的内存地址的对齐&lt;br&gt;&lt;strong&gt;在结构体中的第一个成员的首地址等于整个结构体的变量的首地址&lt;/strong&gt;&lt;br&gt;后面的成员地址随着它声明的首地址和实际占用的字节数递增。&lt;br&gt;而为了总的结构体大小对齐，会在结构体中插入一些没有实际意义的字符填充结构体&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://gmle.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://gmle.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>网络分层模型</title>
    <link href="http://gmle.github.io/2018/08/30/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://gmle.github.io/2018/08/30/网络分层模型/</id>
    <published>2018-08-30T01:33:31.120Z</published>
    <updated>2018-10-18T01:27:36.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><a id="more"></a><h3 id="网络分层OSI七层模型-自底向上-："><a href="#网络分层OSI七层模型-自底向上-：" class="headerlink" title="网络分层OSI七层模型(自底向上)："></a>网络分层OSI七层模型(自底向上)：</h3><ul><li>物理层        - 通信介质：双绞线、光纤等，将模拟信号转换为数字信号的设备<ul><li>网络传输开始发送的为高低电平，八个为一比特位</li></ul></li><li>数据链路层     - 数据校验，定义了网络传输的基本单位：帧</li><li>网络层        - 定义网络，两台机器之间传输的路径选择点到点的传输协议：ip协议，设备：路由器(链接不同网段的桥梁)</li><li>传输层        - 传输数据，TCP、UDP，端到端的传输</li><li>会话层        - 建立会话和保持会话：通过传输层建立数据传输的通道。</li><li>表示层        - 编码、解码，翻译工作</li><li>应用层        - 为客户停工各种应用服务</li></ul><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><pre><code>两个字节的数据发送后还是两个字节吗？</code></pre><p>数据发送方将数据层层打包，将数据发送到对方处接受，然后按照发送方的解包方式进行解包，最终再得到原始数据。</p><p>所以，数据通信过程就是发送方层层打包的过程<br>接收方层层解包的过程</p><h2 id="网络应用程序常见的两种模式"><a href="#网络应用程序常见的两种模式" class="headerlink" title="网络应用程序常见的两种模式"></a>网络应用程序常见的两种模式</h2><p>用户所使用的模式有两种</p><ul><li>C/S模式<ul><li>客户端、服务器模式<ul><li>例：游戏客户端</li></ul></li><li>优点：<ul><li>可以缓存数据、对网络要求不大，不需要频繁访问服务器</li><li>协议选择灵活</li></ul></li><li>缺点：<ul><li>开发周期长</li><li>无法确定程序是否携带木马、病毒等</li></ul></li></ul></li><li>B/S模式<ul><li>浏览器、服务器模式</li><li>优点：<ul><li>开发周期短</li></ul></li><li>缺点：<ul><li>由于浏览器限制，只能选择少数协议</li></ul></li></ul></li></ul><h2 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h2><p>指网络字节序的存储方式。</p><p>查看机器大小端的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; un2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line">&#125; un4;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%zu][%zu][%zu]\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试short类型</span></span><br><span class="line">    un2.s = <span class="number">0x0102</span>;<span class="comment">// 0x0102 =? 16*16+2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>, un2.c[<span class="number">0</span>], un2.c[<span class="number">1</span>], un2.s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试int类型</span></span><br><span class="line">    <span class="comment">//un4.s = 0x12345678;</span></span><br><span class="line">    un4.s = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%d,%d\n"</span>, un4.c[<span class="number">0</span>], un4.c[<span class="number">1</span>], un4.c[<span class="number">2</span>], un4.c[<span class="number">3</span>], un4.s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-S开发流程"><a href="#C-S开发流程" class="headerlink" title="C/S开发流程"></a>C/S开发流程</h2><ul><li><p>服务端</p><ul><li>创建socket，返回文件描述符用于监听客户端连接：socket</li><li>将文件描述符和ip port进行绑定：bind</li><li>将文件描述符由主动变为被动监听：listen()</li><li>接受一个新的连接，得到一个文件描述符：accept(用于与客户端进行通信)</li><li>接收数据：read、recv<ul><li>若读不到数据则阻塞</li></ul></li><li>发送数据：write、send</li><li>关闭文件描述符：close</li></ul></li><li><p>客户端</p><ul><li>创建socket，返回文件描述符用于与服务端通信：socket</li><li>连接服务端：connect()</li><li>发送数据：write、send</li><li>接收数据：read、recv<ul><li>若读不到数据则阻塞</li></ul></li><li>关闭文件描述符：close</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络分层模型&quot;&gt;&lt;a href=&quot;#网络分层模型&quot; class=&quot;headerlink&quot; title=&quot;网络分层模型&quot;&gt;&lt;/a&gt;网络分层模型&lt;/h2&gt;
    
    </summary>
    
      <category term="网络" scheme="http://gmle.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="http://gmle.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="http://gmle.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>kill &amp;&amp; kill -9</title>
    <link href="http://gmle.github.io/2018/08/25/kill%E4%B8%8Ekill%20-9%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://gmle.github.io/2018/08/25/kill与kill -9的区别/</id>
    <published>2018-08-25T01:35:51.228Z</published>
    <updated>2018-09-20T01:42:36.403Z</updated>
    
    <content type="html"><![CDATA[<p>测试kill和kill -9信号的区别。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Powered by Jetbrains Clion.</span></span><br><span class="line"><span class="comment">  * Created by 王乐.</span></span><br><span class="line"><span class="comment">  * Date: 2018/8/25.</span></span><br><span class="line"><span class="comment">  * FileName: kill.c.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***** Code is coming! *****//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"signo = %d\n"</span>, sig);</span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> signals;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, sigHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置空信号集</span></span><br><span class="line">    sigemptyset(&amp;signals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有位置1，与上个函数相反</span></span><br><span class="line">    <span class="comment">// sigfillset(&amp;signals);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加和删除信号。</span></span><br><span class="line">    sigaddset(&amp;signals, SIGINT);</span><br><span class="line">    sigaddset(&amp;signals, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIGKILL 进程不能被阻塞和拦截，该处阻塞无效</span></span><br><span class="line">    sigaddset(&amp;signals, SIGKILL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合中的信号加入到阻塞信号集中</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;signals, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> pending;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取未决信号集</span></span><br><span class="line">        sigemptyset(&amp;pending);</span><br><span class="line">        sigpending(&amp;pending);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigismember(&amp;pending, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j++ % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;signals, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行<br>按CTRL-C可以发送信号SIGINT。<br>按CTRL-\可以发送信号SIGQUIT。</p><p>发送完成可直接捕获到这两个信号。<br>我们可以使用man手册查看信号部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 7 signal</span><br></pre></td></tr></table></figure><p>其中有一句话：<br> The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</p><p> 表示SIGKILL和SIGSTOP信号不能被捕获。</p><p> 再查看信号的详细信息：<br>  SIGKILL       9       Term    Kill signal<br>  SIGTERM      15       Term    Termination signal</p><p>  不难发现 信号9是kill信号，直接杀死该进程，而kill默认发送的信号SIGTERM则是kill命令(例：kill 1234)则默认发送15号信号。</p><p>  15号信号可以被捕获到，而我们的程序捕获到15号信号之后可以做一些回收资源、打印日志等操作。<br>  但当接收到信号9的时候，则直接被杀死，不会来得及释放内存，打印日志等。</p><p>  综合来看，我们应尽量使用kill而不是kill -9.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试kill和kill -9信号的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://gmle.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://gmle.github.io/tags/C/"/>
    
      <category term="Linux" scheme="http://gmle.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>for与while循环</title>
    <link href="http://gmle.github.io/2018/07/30/for&amp;while/"/>
    <id>http://gmle.github.io/2018/07/30/for&amp;while/</id>
    <published>2018-07-30T12:02:11.266Z</published>
    <updated>2018-07-30T12:04:48.763Z</updated>
    
    <content type="html"><![CDATA[<pre><code>C/C++中for循环和while循环的使用时机</code></pre><a id="more"></a><p>在循环次数已知的情况下，显然使用for循环更加合适，而且更为简洁<br>而循环次数未知时，使用while循环。用特定条件控制while循环是否继续执行，循环体中的条件语句可能会影响循环判定条件发生变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;C/C++中for循环和while循环的使用时机
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>范围for语句</title>
    <link href="http://gmle.github.io/2018/07/21/%E8%8C%83%E5%9B%B4%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>http://gmle.github.io/2018/07/21/范围循环语句/</id>
    <published>2018-07-21T13:02:16.969Z</published>
    <updated>2018-07-21T13:55:41.669Z</updated>
    
    <content type="html"><![CDATA[<p>范围for语句是C++11的特性，这种语句可以遍历容器或其他序列的所有元素。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围for语句语法：</span></span><br><span class="line">    <span class="comment">// 范围变量必须是引用类型，这样才能对元素执行写操作。</span></span><br><span class="line">    <span class="comment">// 对于arr中的每个元素 ：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:arr)&#123;  </span><br><span class="line">        i *= <span class="number">2</span>; <span class="comment">// 将arr中的每个元素值翻倍。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n®----------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:arr)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;范围for语句是C++11的特性，这种语句可以遍历容器或其他序列的所有元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载</title>
    <link href="http://gmle.github.io/2018/07/21/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://gmle.github.io/2018/07/21/运算符重载/</id>
    <published>2018-07-21T11:42:34.903Z</published>
    <updated>2018-07-21T13:55:56.456Z</updated>
    
    <content type="html"><![CDATA[<p>运算符重载：</p><ul><li>对于系统内置的数据类型，编译器知道如何运算。</li><li>对于自定义的数据类型则不会运算了。</li><li>利用运算符重载，可以让符号有新的含义。</li></ul><a id="more"></a><p>Example: + 运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"></span><br><span class="line">    Person() : m_A(), m_B() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : m_A(a), m_B(b) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Person <span class="keyword">operator</span>+(Person &amp;person) &#123;</span><br><span class="line">        Person tmp;</span><br><span class="line">        tmp.m_A = <span class="keyword">this</span>-&gt;m_A + person.m_A;</span><br><span class="line">        tmp.m_B = <span class="keyword">this</span>-&gt;m_B + person.m_B;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + num;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + num;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">":::"</span> &lt;&lt; p3.m_B;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p1 + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">":::"</span> &lt;&lt; p3.m_B;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    test02();</span><br><span class="line">    test03();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example：&lt;&lt; 左移运算符重载<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getM_A</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setM_A</span><span class="params">(<span class="keyword">int</span> m_A)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getM_B</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setM_B</span><span class="params">(<span class="keyword">int</span> m_B)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Person &amp;person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::getM_A() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Person::setM_A(<span class="keyword">int</span> m_A) &#123;</span><br><span class="line">    Person::m_A = m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::getM_B() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Person::setM_B(<span class="keyword">int</span> m_B) &#123;</span><br><span class="line">    Person::m_B = m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Person &amp;person) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"m_A: "</span> &lt;&lt; person.getM_A() &lt;&lt; <span class="string">" m_B: "</span> &lt;&lt; person.getM_B();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p1;</span><br><span class="line"></span><br><span class="line">    p1.setM_A(<span class="number">10</span>);</span><br><span class="line">    p1.setM_B(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Example: ++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInter</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInter &amp;inter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInter() &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置++重载</span></span><br><span class="line">    MyInter &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置++重载</span></span><br><span class="line">    MyInter <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">        MyInter tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, MyInter &amp;inter) &#123;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; inter.m_Num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyInter inter;</span><br><span class="line"></span><br><span class="line">    inter++;</span><br><span class="line"></span><br><span class="line">    ++inter;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (inter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example：指针运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person的有参构造调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄为： "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person的析构调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPoint</span><span class="params">(Person *person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    Person *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 * 运算符</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SmartPoint() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_person) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_person = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *m_person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Person * p = new Person(18);</span></span><br><span class="line">    <span class="comment">//(*p).showAge();</span></span><br><span class="line">    <span class="comment">//p-&gt;showAge();</span></span><br><span class="line">    <span class="comment">//delete p;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用智能指针 管理 new出来的person的释放操作</span></span><br><span class="line">    SmartPoint sp(new Person(18));</span><br><span class="line"></span><br><span class="line"><span class="comment">//    sp-&gt;showAge(); // 本质sp-&gt;-&gt;showAge(); 编译器简化为 sp-&gt;showAge();</span></span><br><span class="line"></span><br><span class="line">    sp.m_person-&gt;showAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    (*sp).showAge();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example：赋值运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器 默认给一个类4个函数   默认构造   析构   拷贝构造 （值拷贝）  operator= (值拷贝)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 =</span></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="comment">//先判断原来堆区释放有内容，如果有先释放</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.m_Name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name, p.m_Name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = p.m_Age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.m_Name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name, p.m_Name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Jerry"</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">""</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person p4 = p3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1姓名： "</span> &lt;&lt; p1.m_Name &lt;&lt; <span class="string">"  p1年龄： "</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2姓名： "</span> &lt;&lt; p2.m_Name &lt;&lt; <span class="string">"  p2年龄： "</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p3姓名： "</span> &lt;&lt; p3.m_Name &lt;&lt; <span class="string">" p3年龄： "</span> &lt;&lt; p3.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">    int b = 20;</span></span><br><span class="line"><span class="comment">    int c;</span></span><br><span class="line"><span class="comment">    c = a = b;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = " &lt;&lt; c &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运算符重载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于系统内置的数据类型，编译器知道如何运算。&lt;/li&gt;
&lt;li&gt;对于自定义的数据类型则不会运算了。&lt;/li&gt;
&lt;li&gt;利用运算符重载，可以让符号有新的含义。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>构造函数的初始化列表</title>
    <link href="http://gmle.github.io/2018/07/21/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
    <id>http://gmle.github.io/2018/07/21/构造函数的初始化列表/</id>
    <published>2018-07-21T11:38:22.516Z</published>
    <updated>2018-07-21T13:55:29.003Z</updated>
    
    <content type="html"><![CDATA[<p>初始化列表语法。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数名称后  ： 属性(值), 属性（值）...</span></span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"m_A = "</span> &lt;&lt; p.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"m_B = "</span> &lt;&lt; p.m_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"m_C = "</span> &lt;&lt; p.m_C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初始化列表语法。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>构造、析构。拷贝构造</title>
    <link href="http://gmle.github.io/2018/07/21/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0/"/>
    <id>http://gmle.github.io/2018/07/21/构造、析构、拷贝构造/</id>
    <published>2018-07-21T11:35:00.189Z</published>
    <updated>2018-07-21T13:55:17.361Z</updated>
    
    <content type="html"><![CDATA[<p>构造函数、析构函数、拷贝构造函数</p><p>构造函数：</p><ul><li>构造函数在函数被调用的时候调用并初始化。</li><li>构造函数必须要声明在全局作用域。</li><li>没有返回值，也不需要写void</li><li>函数名与类名相同</li><li>可以有参数，可以发生重载</li><li>构造函数由编译器自动调用且只调用一次，无需手动调用。</li></ul><a id="more"></a><p>构造函数分类：</p><ul><li>按照参数分类：无参构造（默认构造函数）和有参构造。</li><li>按照类型分类：普通构造函数，拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数：</span></span><br><span class="line"><span class="comment">     *  构造函数在函数被调用的时候调用并初始化。</span></span><br><span class="line"><span class="comment">     *  构造函数必须要声明在全局作用域。</span></span><br><span class="line"><span class="comment">     *  没有返回值，也不需要写void</span></span><br><span class="line"><span class="comment">     *  函数名与类名相同</span></span><br><span class="line"><span class="comment">     *  可以有参数，可以发生重载</span></span><br><span class="line"><span class="comment">     *  构造函数由编译器自动调用且只调用一次，无需手动调用。</span></span><br><span class="line"><span class="comment">     * 构造函数分类：</span></span><br><span class="line"><span class="comment">     *  按照参数分类：无参构造（默认构造函数）和有参构造。</span></span><br><span class="line"><span class="comment">     *  按照类型分类：普通构造函数，拷贝构造函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hei二狗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        _age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hei有参二狗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝构造</span></span><br><span class="line"><span class="comment">     * 1、用已有对象初始化新的对象。</span></span><br><span class="line"><span class="comment">     * 2、值传递的方式给函数参数传值。</span></span><br><span class="line"><span class="comment">     * 3、以值的方式返回局部对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;person) &#123;</span><br><span class="line">        _age = person._age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 析构函数</span></span><br><span class="line"><span class="comment">     * 没有返回值，不需要写void</span></span><br><span class="line"><span class="comment">     * 函数名与类名相同 函数名前加 ~</span></span><br><span class="line"><span class="comment">     * 不可以有参数，不可以重载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ha二狗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> _age)</span> </span>&#123;</span><br><span class="line">        Person::_age = _age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名对象：特点：当执行完该函数后立即释放。</span></span><br><span class="line">    <span class="comment">// 不要用拷贝构造函数初始化匿名对象。</span></span><br><span class="line">    Person(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    Person person1 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.get_age() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main03</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构造函数、析构函数、拷贝构造函数&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数在函数被调用的时候调用并初始化。&lt;/li&gt;
&lt;li&gt;构造函数必须要声明在全局作用域。&lt;/li&gt;
&lt;li&gt;没有返回值，也不需要写void&lt;/li&gt;
&lt;li&gt;函数名与类名相同&lt;/li&gt;
&lt;li&gt;可以有参数，可以发生重载&lt;/li&gt;
&lt;li&gt;构造函数由编译器自动调用且只调用一次，无需手动调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>友元函数</title>
    <link href="http://gmle.github.io/2018/07/21/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
    <id>http://gmle.github.io/2018/07/21/友元函数/</id>
    <published>2018-07-21T11:29:27.206Z</published>
    <updated>2018-07-21T13:55:00.073Z</updated>
    
    <content type="html"><![CDATA[<p>友元函数：</p><ul><li>为在该类中提供一个对外访问的接口</li><li>友元函数不属于该类的成员函数</li><li>友元函数是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员</li></ul><a id="more"></a><p>使用注意：</p><ul><li>类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。</li><li>一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。</li><li>友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</li><li>友元函数在调用上同一般函数一样，不必通过对对象进行引用。</li></ul><p>例子：好基友进卧室。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Gay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Home(<span class="built_in">string</span> sitting, <span class="built_in">string</span> bed);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> BedRoom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Home::Home() &#123;</span></span><br><span class="line"><span class="comment">//    this-&gt;setBedRoom("卧室");</span></span><br><span class="line"><span class="comment">//    this-&gt;setSittingRoom("客厅");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gay</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gay(Home* h);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Home *home&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Home::Home(<span class="built_in">string</span> sitting, <span class="built_in">string</span> bed) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;SittingRoom = sitting;</span></span><br><span class="line"><span class="comment">//    this-&gt;BedRoom = bed;</span></span><br><span class="line"></span><br><span class="line">    Home::BedRoom = bed;</span><br><span class="line">    Home::SittingRoom = sitting;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Gay::Gay(Home* h) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;home = new Home;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;home = h;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    this-&gt;home = &amp;h;</span></span><br><span class="line"><span class="comment">//        this-&gt;home = &amp;h;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Gay::visit() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gay vising "</span> &lt;&lt; <span class="keyword">this</span>-&gt;home-&gt;SittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gay vising "</span> &lt;&lt; <span class="keyword">this</span>-&gt;home-&gt;BedRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Home <span class="title">hh</span><span class="params">(<span class="string">"客厅"</span>,<span class="string">"卧室"</span>)</span></span>;</span><br><span class="line">    <span class="function">Gay <span class="title">gay</span><span class="params">(&amp;hh)</span></span>;</span><br><span class="line">    gay.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;友元函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为在该类中提供一个对外访问的接口&lt;/li&gt;
&lt;li&gt;友元函数不属于该类的成员函数&lt;/li&gt;
&lt;li&gt;友元函数是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：单例</title>
    <link href="http://gmle.github.io/2018/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://gmle.github.io/2018/07/21/设计模式：单例模式/</id>
    <published>2018-07-21T11:15:24.799Z</published>
    <updated>2018-07-21T13:55:50.724Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式的设计思想：<br>    在一些情形下，保持类的实例只有一个非常重要。例如：一个表示文件系统的Class。一个操作系统一定是只有一个文件系统的，因此，我们希望表示文件系统的类实例有且仅有一个。单例模式 是设计模式中一种实现这一类需求的设计方法。</p><a id="more"></a><p>该代码线程不安全。<br>线程安全的两个操作：</p><ul><li>对象在类外创建。</li><li>加锁。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;test)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo() &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"销毁"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~Singleton()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1123123"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//delete m_pInstance;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数私有化，防止创建多个对象。</span></span><br><span class="line">    Singleton() : count(<span class="number">0</span>) &#123;</span><br><span class="line">        setCount(<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数私有化，防止在堆区创建对象。</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span> &amp;) : count() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Singleton::getCount() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Singleton::setCount(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    Singleton::count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::CGarbo Garbo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton *s1 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line">    s1-&gt;printTest(<span class="string">"1"</span>);</span><br><span class="line">    s1-&gt;printTest(<span class="string">"2"</span>);</span><br><span class="line">    s1-&gt;printTest(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1:count"</span> &lt;&lt; s1-&gt;getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Singleton *s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line">    s2-&gt;printTest(<span class="string">"4"</span>);</span><br><span class="line">    s2-&gt;printTest(<span class="string">"5"</span>);</span><br><span class="line">    s2-&gt;printTest(<span class="string">"6"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2:count"</span> &lt;&lt; s2-&gt;getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例设计模式的设计思想：&lt;br&gt;    在一些情形下，保持类的实例只有一个非常重要。例如：一个表示文件系统的Class。一个操作系统一定是只有一个文件系统的，因此，我们希望表示文件系统的类实例有且仅有一个。单例模式 是设计模式中一种实现这一类需求的设计方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://gmle.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://gmle.github.io/tags/Cpp/"/>
    
      <category term="设计模式" scheme="http://gmle.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://gmle.github.io/2018/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://gmle.github.io/2018/07/12/二叉树/</id>
    <published>2018-07-12T13:36:40.536Z</published>
    <updated>2018-07-12T13:45:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>一对二</p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>每个结点最多只有两棵子树（不存在度大于2的结点）；</li><li>左子树和右子树次序不能颠倒（有序树）。</li></ul><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>二叉树的遍历</p><ul><li>DLR — 先序遍历，即先根再左再右</li><li>LDR — 中序遍历，即先左再根再右</li><li>LRD — 后序遍历，即先左再右再根</li></ul><p>“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。<br>从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> *<span class="title">LeftChirld</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> *<span class="title">RightChirld</span>;</span></span><br><span class="line">&#125; BubaryNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(BubaryNode *pBINARYNODE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BubaryNode nodeA = &#123;<span class="string">'A'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeB = &#123;<span class="string">'B'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeC = &#123;<span class="string">'C'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeD = &#123;<span class="string">'D'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeE = &#123;<span class="string">'E'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeF = &#123;<span class="string">'F'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeG = &#123;<span class="string">'G'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BubaryNode nodeH = &#123;<span class="string">'H'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立关系</span></span><br><span class="line">    nodeA.LeftChirld = &amp;nodeB;</span><br><span class="line">    nodeA.RightChirld = &amp;nodeF;</span><br><span class="line">    nodeB.RightChirld = &amp;nodeC;</span><br><span class="line">    nodeC.LeftChirld = &amp;nodeD;</span><br><span class="line">    nodeC.RightChirld = &amp;nodeE;</span><br><span class="line">    nodeF.RightChirld = &amp;nodeG;</span><br><span class="line">    nodeG.LeftChirld = &amp;nodeH;</span><br><span class="line"></span><br><span class="line">    recursion(&amp;nodeA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树递归</span></span><br><span class="line"><span class="comment"> * @param rootNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(BubaryNode *rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历 ：先根，再左，再右。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, rootNode-&gt;ch);</span><br><span class="line">    recursion(rootNode-&gt;LeftChirld);</span><br><span class="line">    recursion(rootNode-&gt;RightChirld);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历 ：先左，再右，再根。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    recursion(rootNode-&gt;LeftChirld);</span></span><br><span class="line"><span class="comment">    printf("%c ", rootNode-&gt;ch);</span></span><br><span class="line"><span class="comment">    recursion(rootNode-&gt;RightChirld);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历 ： 先左，再右，再根。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    recursion(rootNode-&gt;LeftChirld);</span></span><br><span class="line"><span class="comment">    recursion(rootNode-&gt;RightChirld);</span></span><br><span class="line"><span class="comment">    printf("%c ", rootNode-&gt;ch);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的使用"><a href="#二叉树的使用" class="headerlink" title="二叉树的使用"></a>二叉树的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> *<span class="title">LeftChirld</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">BINARYNODE</span> *<span class="title">RightChirld</span>;</span></span><br><span class="line">&#125; BinaryNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算二叉树高度：左子树与右子树同时为NULL，则为叶子</span></span><br><span class="line"><span class="comment"> * @param rootnode</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calLeaves</span><span class="params">(BinaryNode *rootnode, <span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootnode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootnode-&gt;LeftChirld == <span class="literal">NULL</span> &amp;&amp; rootnode-&gt;RightChirld == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (*p)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    calLeaves(rootnode-&gt;LeftChirld, p);</span><br><span class="line">    calLeaves(rootnode-&gt;RightChirld, p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树遍历</span></span><br><span class="line"><span class="comment"> * @param rootNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(BinaryNode *rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, rootNode-&gt;ch);</span><br><span class="line">    recursion(rootNode-&gt;LeftChirld);</span><br><span class="line">    recursion(rootNode-&gt;RightChirld);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">BinaryTreeHeight</span><span class="params">(BinaryNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = BinaryTreeHeight(root-&gt;LeftChirld);</span><br><span class="line">    <span class="keyword">int</span> right = BinaryTreeHeight(root-&gt;RightChirld);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BinaryNode *<span class="title">copyTree</span><span class="params">(BinaryNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryNode *leftChild = copyTree(root-&gt;LeftChirld);</span><br><span class="line">    BinaryNode *rightChild = copyTree(root-&gt;RightChirld);</span><br><span class="line"></span><br><span class="line">    BinaryNode *newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinaryNode));</span><br><span class="line">    newNode-&gt;ch = root-&gt;ch;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;LeftChirld = leftChild;</span><br><span class="line">    newNode-&gt;RightChirld = rightChild;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的内存释放</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeTree</span><span class="params">(BinaryNode *root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    freeTree(root-&gt;LeftChirld);</span><br><span class="line">    freeTree(root-&gt;RightChirld);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Free:%c\n"</span>, root-&gt;ch);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    BinaryNode nodeA = &#123;<span class="string">'A'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeB = &#123;<span class="string">'B'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeC = &#123;<span class="string">'C'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeD = &#123;<span class="string">'D'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeE = &#123;<span class="string">'E'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeF = &#123;<span class="string">'F'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeG = &#123;<span class="string">'G'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    BinaryNode nodeH = &#123;<span class="string">'H'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立关系</span></span><br><span class="line">    nodeA.LeftChirld = &amp;nodeB;</span><br><span class="line">    nodeA.RightChirld = &amp;nodeF;</span><br><span class="line">    nodeB.RightChirld = &amp;nodeC;</span><br><span class="line">    nodeC.LeftChirld = &amp;nodeD;</span><br><span class="line">    nodeC.RightChirld = &amp;nodeE;</span><br><span class="line">    nodeF.RightChirld = &amp;nodeG;</span><br><span class="line">    nodeG.LeftChirld = &amp;nodeH;</span><br><span class="line"></span><br><span class="line">    calLeaves(&amp;nodeA, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二叉树叶子数量：%d\n"</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BinaryNode *newTree = copyTree(&amp;nodeA);</span><br><span class="line">    recursion(newTree);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n二叉树高度：%d\n"</span>, BinaryTreeHeight(&amp;nodeA));</span><br><span class="line"></span><br><span class="line">    freeTree(newTree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">":::%c\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>) newTree-&gt;RightChirld-&gt;RightChirld);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://gmle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://gmle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>队列的链表存储结构</title>
    <link href="http://gmle.github.io/2018/07/12/%E9%98%9F%E5%88%97/"/>
    <id>http://gmle.github.io/2018/07/12/队列/</id>
    <published>2018-07-12T13:27:23.985Z</published>
    <updated>2018-07-21T13:55:59.396Z</updated>
    
    <content type="html"><![CDATA[<p>队列的链表存储结构实现</p><a id="more"></a><p>FILE1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LINKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LINKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">QUEUENODE</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QUEUENODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LISTQUEUE</span>&#123;</span></span><br><span class="line">    QueueNode header;</span><br><span class="line">    <span class="keyword">int</span> ListQueueSize;</span><br><span class="line"></span><br><span class="line">    QueueNode *tail;</span><br><span class="line"></span><br><span class="line">&#125; ListQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">LinkQueue <span class="title">init_LinkQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_LinkQueue</span><span class="params">(LinkQueue q, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop__LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty_LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">front_LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">back_LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_LinkQueue</span><span class="params">(LinkQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_LINKQUEUE_H</span></span></span><br></pre></td></tr></table></figure><p>FILE2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linkQueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">LinkQueue <span class="title">init_LinkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListQueue));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;header.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;ListQueueSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = &amp;<span class="built_in">queue</span>-&gt;header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_LinkQueue</span><span class="params">(LinkQueue lq, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lq == <span class="literal">NULL</span> || data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = lq;</span><br><span class="line">    QueueNode *qNode = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail-&gt;next = qNode;</span><br><span class="line">    qNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = qNode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;ListQueueSize++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop__LinkQueue</span><span class="params">(LinkQueue q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *listQueue = q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有要删除的元素</span></span><br><span class="line">    <span class="keyword">if</span> (listQueue-&gt;ListQueueSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个节点，则将尾部节点指向头节点。</span></span><br><span class="line">    <span class="keyword">if</span> (listQueue-&gt;ListQueueSize == <span class="number">1</span>) &#123;</span><br><span class="line">        listQueue-&gt;header.next = <span class="literal">NULL</span>;</span><br><span class="line">        listQueue-&gt;tail = &amp;listQueue-&gt;header;</span><br><span class="line">        listQueue-&gt;ListQueueSize--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于一个节点的情况</span></span><br><span class="line">    QueueNode *headNode = listQueue-&gt;header.next;</span><br><span class="line"></span><br><span class="line">    listQueue-&gt;header.next = headNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    listQueue-&gt;ListQueueSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_LinkQueue</span><span class="params">(LinkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;ListQueueSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty_LinkQueue</span><span class="params">(LinkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;ListQueueSize == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">front_LinkQueue</span><span class="params">(LinkQueue q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;header.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">back_LinkQueue</span><span class="params">(LinkQueue q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListQueue *<span class="built_in">queue</span> = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory_LinkQueue</span><span class="params">(LinkQueue q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FILE3:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linkQueue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *node;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    LinkQueue myQueue = init_LinkQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> = &#123;</span><span class="literal">NULL</span>, <span class="string">"aaa"</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span> = &#123;</span><span class="literal">NULL</span>, <span class="string">"bbb"</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p3</span> = &#123;</span><span class="literal">NULL</span>, <span class="string">"ccc"</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p4</span> = &#123;</span><span class="literal">NULL</span>, <span class="string">"ddd"</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    push_LinkQueue(myQueue, &amp;p1);</span><br><span class="line">    push_LinkQueue(myQueue, &amp;p2);</span><br><span class="line">    push_LinkQueue(myQueue, &amp;p3);</span><br><span class="line">    push_LinkQueue(myQueue, &amp;p4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队列大小为：%d\n"</span>, size_LinkQueue(myQueue));</span><br><span class="line">    <span class="keyword">while</span> (isEmpty_LinkQueue(myQueue) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//访问队头</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">pFront</span> = <span class="title">front_LinkQueue</span>(<span class="title">myQueue</span>);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链式存储::队头元素 -- 姓名：%s  年龄： %d\n"</span>, pFront-&gt;name, pFront-&gt;age);</span><br><span class="line">        <span class="comment">//访问队尾</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">pBack</span> = <span class="title">back_LinkQueue</span>(<span class="title">myQueue</span>);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链式存储::队尾元素 -- 姓名：%s  年龄： %d\n"</span>, pBack-&gt;name, pBack-&gt;age);</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        pop__LinkQueue(myQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队列大小为：%d\n"</span>, size_LinkQueue(myQueue));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁队列</span></span><br><span class="line">    destory_LinkQueue(myQueue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;队列的链表存储结构实现&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://gmle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://gmle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://gmle.github.io/2018/07/12/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://gmle.github.io/2018/07/12/插入排序/</id>
    <published>2018-07-12T13:24:43.925Z</published>
    <updated>2018-07-12T13:27:16.043Z</updated>
    
    <content type="html"><![CDATA[<p>插入排序实现思路：</p><ul><li>从I = 1位置开始  做外层循环 </li><li>判断 如果  I -1 &gt; I 将i指向的数据缓存</li><li>j开始做内侧循环，找到要插入的位置 将缓存数据插入到 j +1位置上</li><li>i++</li></ul><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序.</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j--) &#123;</span><br><span class="line">                <span class="comment">//数据后移</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    insertSort(arr, <span class="keyword">sizeof</span>(arr)/ <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    assert(arr[<span class="number">0</span>]==<span class="number">0</span>);</span><br><span class="line">    assert(arr[<span class="number">1</span>]==<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;插入排序实现思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从I = 1位置开始  做外层循环 &lt;/li&gt;
&lt;li&gt;判断 如果  I -1 &amp;gt; I 将i指向的数据缓存&lt;/li&gt;
&lt;li&gt;j开始做内侧循环，找到要插入的位置 将缓存数据插入到 j +1位置上&lt;/li&gt;
&lt;li&gt;i++&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C" scheme="http://gmle.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://gmle.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>利用栈规则做就近括号匹配</title>
    <link href="http://gmle.github.io/2018/07/11/%E5%88%A9%E7%94%A8%E6%A0%88%E8%A7%84%E5%88%99%E5%81%9A%E5%B0%B1%E8%BF%91%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    <id>http://gmle.github.io/2018/07/11/利用栈规则做就近括号匹配/</id>
    <published>2018-07-11T13:50:43.276Z</published>
    <updated>2018-07-11T13:53:48.751Z</updated>
    
    <content type="html"><![CDATA[<p>利用栈规则做就近括号匹配<br><a id="more"></a></p><p>从第一个字符开始扫描<br>当遇见普通字符时忽略，<br>当遇见左括号时压入栈中<br>当遇见右括号时从栈中弹出栈顶符号，并进行匹配<br>匹配成功：继续读入下一个字符<br>匹配失败：立即停止，并报错<br>结束：<br>成功: 所有字符扫描完毕，且栈为空<br>失败：匹配失败或所有字符扫描完毕但栈非空</p><p>FILE1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SEQSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SEQSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data[MAX];  <span class="comment">//栈的数组</span></span><br><span class="line">    <span class="keyword">int</span> m_Size; <span class="comment">//栈大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *SeqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">SeqStack <span class="title">init_SeqStack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">top_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_SEQSTACK_H</span></span></span><br></pre></td></tr></table></figure><p>FILE2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqStack.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">SeqStack <span class="title">init_SeqStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">myStack</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">SStack</span>));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myStack == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数组</span></span><br><span class="line">    <span class="built_in">memset</span>(myStack-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) * MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化栈大小</span></span><br><span class="line">    myStack-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myStack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入栈本质  --- 数组尾插</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">mystack</span> = <span class="title">stack</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (mystack-&gt;m_Size == MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mystack-&gt;data[mystack-&gt;m_Size] = data;</span><br><span class="line"></span><br><span class="line">    mystack-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//出栈本质  --- 数组尾删</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">mystack</span> = <span class="title">stack</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mystack-&gt;m_Size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mystack-&gt;data[mystack-&gt;m_Size - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mystack-&gt;m_Size--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">top_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">mystack</span> = <span class="title">stack</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mystack-&gt;m_Size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mystack-&gt;data[mystack-&gt;m_Size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">mystack</span> = <span class="title">stack</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mystack-&gt;m_Size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回-1代表真  空栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SStack</span> *<span class="title">mystack</span> = <span class="title">stack</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mystack-&gt;m_Size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//返回0 代表 不是空栈</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_SeqStack</span><span class="params">(SeqStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FILE3:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLeft</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">'('</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isRight</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"123*(was)s(sd)sdb(fs())())))(()"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line"></span><br><span class="line">    SeqStack *<span class="built_in">stack</span> = init_SeqStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是左括号，入栈</span></span><br><span class="line">        <span class="keyword">if</span> (isLeft(*p)) &#123;</span><br><span class="line">            push_SeqStack(<span class="built_in">stack</span>, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight(*p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size_SeqStack(<span class="built_in">stack</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pop_SeqStack(<span class="built_in">stack</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error(str, <span class="string">"Error!"</span>, p);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (size_SeqStack(<span class="built_in">stack</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        error(str, <span class="string">"Error"</span>, top_SeqStack(<span class="built_in">stack</span>));</span><br><span class="line">        pop_SeqStack(<span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroy_SeqStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> b = isEmpty_SeqStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n=-=-=-=-=-=-=-====-=-=\n%d\n"</span>,b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%s\n"</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (p - str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用栈规则做就近括号匹配&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://gmle.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://gmle.github.io/tags/C/"/>
    
  </entry>
  
</feed>
